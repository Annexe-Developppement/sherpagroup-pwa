{"map":"{\"version\":3,\"sources\":[\"14.85e6d77ac23628dd7290.js\"],\"names\":[\"window\",\"push\",\"./node_modules/informed/dist/esm/index.js\",\"module\",\"__webpack_exports__\",\"__webpack_require__\",\"eval\"],\"mappings\":\"CAACA,OAAqB,aAAIA,OAAqB,cAAK,IAAIC,KAAK,CAAC,CAAC,IAAI,CAE7DC;;;;iiBAKA,SAAUC,OAAQC,oBAAqBC,qBAE7C,aACAC,KAAK\"}","code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{\"./node_modules/informed/dist/esm/index.js\":\n/*!*************************************************!*\\\n  !*** ./node_modules/informed/dist/esm/index.js ***!\n  \\*************************************************/\n/*! exports provided: ArrayField, BasicCheckbox, BasicRadio, BasicRadioGroup, BasicSelect, BasicText, BasicTextArea, Checkbox, Form, FormComponents, FormField, FormFields, FormProvider, FormState, Input, Multistep, Option, Radio, RadioGroup, Relevant, SchemaFields, Scope, Select, Text, TextArea, asField, useArrayField, useArrayFieldApi, useArrayFieldItemApi, useField, useFieldApi, useFieldState, useForm, useFormApi, useFormState, useMultistepApi, useMultistepState, withFieldApi, withFieldState, withFormApi, withFormState, withRadioGroup */function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval('__webpack_require__.r(__webpack_exports__);\\n/* WEBPACK VAR INJECTION */(function(process) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ArrayField\", function() { return ArrayField; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BasicCheckbox\", function() { return Checkbox; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BasicRadio\", function() { return Radio; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BasicRadioGroup\", function() { return RadioGroup; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BasicSelect\", function() { return Select; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BasicText\", function() { return Text; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BasicTextArea\", function() { return TextArea; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Checkbox\", function() { return Checkbox$1; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Form\", function() { return Form; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FormComponents\", function() { return FormComponents; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FormField\", function() { return FormField; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FormFields\", function() { return FormFields; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FormProvider\", function() { return FormProvider; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FormState\", function() { return FormState; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Input\", function() { return Input; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Multistep\", function() { return Multistep; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Option\", function() { return Option; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Radio\", function() { return Radio$1; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RadioGroup\", function() { return RadioGroup$1; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Relevant\", function() { return Relevant; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SchemaFields\", function() { return SchemaFields; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Scope\", function() { return Scope; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Select\", function() { return Select$1; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Text\", function() { return Text$1; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TextArea\", function() { return TextArea$1; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"asField\", function() { return asField; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useArrayField\", function() { return useArrayField; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useArrayFieldApi\", function() { return useArrayFieldApi; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useArrayFieldItemApi\", function() { return useArrayFieldItemApi; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useField\", function() { return useField; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useFieldApi\", function() { return useFieldApi; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useFieldState\", function() { return useFieldState; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useForm\", function() { return useForm; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useFormApi\", function() { return useFormApi; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useFormState\", function() { return useFormState; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useMultistepApi\", function() { return useMultistepApi; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useMultistepState\", function() { return useMultistepState; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"withFieldApi\", function() { return withFieldApi; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"withFieldState\", function() { return withFieldState; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"withFormApi\", function() { return withFormApi; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"withFormState\", function() { return withFormState; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"withRadioGroup\", function() { return withRadioGroup; });\\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_1__);\\n\\n\\n\\nfunction _classCallCheck(instance, Constructor) {\\n  if (!(instance instanceof Constructor)) {\\n    throw new TypeError(\"Cannot call a class as a function\");\\n  }\\n}\\n\\nfunction _defineProperties(target, props) {\\n  for (var i = 0; i < props.length; i++) {\\n    var descriptor = props[i];\\n    descriptor.enumerable = descriptor.enumerable || false;\\n    descriptor.configurable = true;\\n    if (\"value\" in descriptor) descriptor.writable = true;\\n    Object.defineProperty(target, descriptor.key, descriptor);\\n  }\\n}\\n\\nfunction _createClass(Constructor, protoProps, staticProps) {\\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\\n  if (staticProps) _defineProperties(Constructor, staticProps);\\n  return Constructor;\\n}\\n\\nfunction _defineProperty(obj, key, value) {\\n  if (key in obj) {\\n    Object.defineProperty(obj, key, {\\n      value: value,\\n      enumerable: true,\\n      configurable: true,\\n      writable: true\\n    });\\n  } else {\\n    obj[key] = value;\\n  }\\n\\n  return obj;\\n}\\n\\nfunction _extends() {\\n  _extends = Object.assign || function (target) {\\n    for (var i = 1; i < arguments.length; i++) {\\n      var source = arguments[i];\\n\\n      for (var key in source) {\\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\\n          target[key] = source[key];\\n        }\\n      }\\n    }\\n\\n    return target;\\n  };\\n\\n  return _extends.apply(this, arguments);\\n}\\n\\nfunction ownKeys(object, enumerableOnly) {\\n  var keys = Object.keys(object);\\n\\n  if (Object.getOwnPropertySymbols) {\\n    var symbols = Object.getOwnPropertySymbols(object);\\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\\n    });\\n    keys.push.apply(keys, symbols);\\n  }\\n\\n  return keys;\\n}\\n\\nfunction _objectSpread2(target) {\\n  for (var i = 1; i < arguments.length; i++) {\\n    var source = arguments[i] != null ? arguments[i] : {};\\n\\n    if (i % 2) {\\n      ownKeys(Object(source), true).forEach(function (key) {\\n        _defineProperty(target, key, source[key]);\\n      });\\n    } else if (Object.getOwnPropertyDescriptors) {\\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\\n    } else {\\n      ownKeys(Object(source)).forEach(function (key) {\\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\\n      });\\n    }\\n  }\\n\\n  return target;\\n}\\n\\nfunction _inherits(subClass, superClass) {\\n  if (typeof superClass !== \"function\" && superClass !== null) {\\n    throw new TypeError(\"Super expression must either be null or a function\");\\n  }\\n\\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\\n    constructor: {\\n      value: subClass,\\n      writable: true,\\n      configurable: true\\n    }\\n  });\\n  if (superClass) _setPrototypeOf(subClass, superClass);\\n}\\n\\nfunction _getPrototypeOf(o) {\\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\\n    return o.__proto__ || Object.getPrototypeOf(o);\\n  };\\n  return _getPrototypeOf(o);\\n}\\n\\nfunction _setPrototypeOf(o, p) {\\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\\n    o.__proto__ = p;\\n    return o;\\n  };\\n\\n  return _setPrototypeOf(o, p);\\n}\\n\\nfunction _isNativeReflectConstruct() {\\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\\n  if (Reflect.construct.sham) return false;\\n  if (typeof Proxy === \"function\") return true;\\n\\n  try {\\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\\n    return true;\\n  } catch (e) {\\n    return false;\\n  }\\n}\\n\\nfunction _objectWithoutPropertiesLoose(source, excluded) {\\n  if (source == null) return {};\\n  var target = {};\\n  var sourceKeys = Object.keys(source);\\n  var key, i;\\n\\n  for (i = 0; i < sourceKeys.length; i++) {\\n    key = sourceKeys[i];\\n    if (excluded.indexOf(key) >= 0) continue;\\n    target[key] = source[key];\\n  }\\n\\n  return target;\\n}\\n\\nfunction _objectWithoutProperties(source, excluded) {\\n  if (source == null) return {};\\n\\n  var target = _objectWithoutPropertiesLoose(source, excluded);\\n\\n  var key, i;\\n\\n  if (Object.getOwnPropertySymbols) {\\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\\n\\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\\n      key = sourceSymbolKeys[i];\\n      if (excluded.indexOf(key) >= 0) continue;\\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\\n      target[key] = source[key];\\n    }\\n  }\\n\\n  return target;\\n}\\n\\nfunction _assertThisInitialized(self) {\\n  if (self === void 0) {\\n    throw new ReferenceError(\"this hasn\\'t been initialised - super() hasn\\'t been called\");\\n  }\\n\\n  return self;\\n}\\n\\nfunction _possibleConstructorReturn(self, call) {\\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\\n    return call;\\n  }\\n\\n  return _assertThisInitialized(self);\\n}\\n\\nfunction _createSuper(Derived) {\\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\\n\\n  return function _createSuperInternal() {\\n    var Super = _getPrototypeOf(Derived),\\n        result;\\n\\n    if (hasNativeReflectConstruct) {\\n      var NewTarget = _getPrototypeOf(this).constructor;\\n\\n      result = Reflect.construct(Super, arguments, NewTarget);\\n    } else {\\n      result = Super.apply(this, arguments);\\n    }\\n\\n    return _possibleConstructorReturn(this, result);\\n  };\\n}\\n\\nfunction _slicedToArray(arr, i) {\\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\\n}\\n\\nfunction _toConsumableArray(arr) {\\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\\n}\\n\\nfunction _arrayWithoutHoles(arr) {\\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\\n}\\n\\nfunction _arrayWithHoles(arr) {\\n  if (Array.isArray(arr)) return arr;\\n}\\n\\nfunction _iterableToArray(iter) {\\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\\n}\\n\\nfunction _iterableToArrayLimit(arr, i) {\\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\\n  var _arr = [];\\n  var _n = true;\\n  var _d = false;\\n  var _e = undefined;\\n\\n  try {\\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\\n      _arr.push(_s.value);\\n\\n      if (i && _arr.length === i) break;\\n    }\\n  } catch (err) {\\n    _d = true;\\n    _e = err;\\n  } finally {\\n    try {\\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\\n    } finally {\\n      if (_d) throw _e;\\n    }\\n  }\\n\\n  return _arr;\\n}\\n\\nfunction _unsupportedIterableToArray(o, minLen) {\\n  if (!o) return;\\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\\n  var n = Object.prototype.toString.call(o).slice(8, -1);\\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\\n}\\n\\nfunction _arrayLikeToArray(arr, len) {\\n  if (len == null || len > arr.length) len = arr.length;\\n\\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\\n\\n  return arr2;\\n}\\n\\nfunction _nonIterableSpread() {\\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\\n}\\n\\nfunction _nonIterableRest() {\\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\\n}\\n\\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\\n  var it;\\n\\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\\n      if (it) o = it;\\n      var i = 0;\\n\\n      var F = function () {};\\n\\n      return {\\n        s: F,\\n        n: function () {\\n          if (i >= o.length) return {\\n            done: true\\n          };\\n          return {\\n            done: false,\\n            value: o[i++]\\n          };\\n        },\\n        e: function (e) {\\n          throw e;\\n        },\\n        f: F\\n      };\\n    }\\n\\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\\n  }\\n\\n  var normalCompletion = true,\\n      didErr = false,\\n      err;\\n  return {\\n    s: function () {\\n      it = o[Symbol.iterator]();\\n    },\\n    n: function () {\\n      var step = it.next();\\n      normalCompletion = step.done;\\n      return step;\\n    },\\n    e: function (e) {\\n      didErr = true;\\n      err = e;\\n    },\\n    f: function () {\\n      try {\\n        if (!normalCompletion && it.return != null) it.return();\\n      } finally {\\n        if (didErr) throw err;\\n      }\\n    }\\n  };\\n}\\n\\nfunction createCommonjsModule(fn, module) {\\n\\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\\n}\\n\\nvar debug = createCommonjsModule(function (module) {\\n/**\\n * \\n * I stole most of this code from the debug lib\\n * https://github.com/visionmedia/debug\\n * \\n * Just wanted it to be easy to debug without relying on the dependency!\\n */\\n\\n/**\\n\\t* Selects a color for a debug namespace\\n  * @param {String} namespace The namespace string for the for the debug instance to be colored\\n  * @param {String} colors color pallette to choose from\\n\\t* @return {Number|String} An ANSI color code for the given namespace\\n\\t* @api private\\n\\t*/\\nfunction selectColor(namespace, colors) {\\n  var hash = 0;\\n\\n  for (var i = 0; i < namespace.length; i++) {\\n    hash = (hash << 5) - hash + namespace.charCodeAt(i);\\n    hash |= 0; // Convert to 32bit integer\\n  }\\n\\n  return colors[Math.abs(hash) % colors.length];\\n}\\n/**\\n * Adds ANSI color escape codes if enabled.\\n *\\n * @api public\\n */\\n\\n\\nfunction formatNodeArgs(args, config) {\\n  var name = config.namespace;\\n\\n  if (config.useColors) {\\n    var c = config.color;\\n    var colorCode = \"\\\\x1B[3\" + (c < 8 ? c : \\'8;5;\\' + c);\\n    var prefix = \"  \".concat(colorCode, \";1m\").concat(name, \" \\\\x1B[0m\");\\n    args[0] = prefix + args[0].split(\\'\\\\n\\').join(\\'\\\\n\\' + prefix);\\n  } else {\\n    args[0] = name + \\' \\' + args[0];\\n  }\\n}\\n/**\\n * Colorize log arguments if enabled.\\n *\\n */\\n\\n\\nfunction formatBrowserArgs(args, config) {\\n  args[0] = (config.useColors ? \\'%c\\' : \\'\\') + config.namespace;\\n\\n  if (!config.useColors) {\\n    return;\\n  }\\n\\n  var c = \\'color: \\' + config.color; // The final \"%c\" is somewhat tricky, because there could be other\\n  // arguments passed either before or after the %c, so we need to\\n  // figure out the correct index to insert the CSS into\\n\\n  var index = 0;\\n  var lastC = 0;\\n  args[0].replace(/%[a-zA-Z%]/g, function (match) {\\n    if (match === \\'%%\\') {\\n      return;\\n    }\\n\\n    index++;\\n\\n    if (match === \\'%c\\') {\\n      // We only are interested in the *last* %c\\n      // (the user may have provided their own)\\n      lastC = index;\\n    }\\n  });\\n  args.splice(lastC, 0, c);\\n}\\n\\nvar browserColors = [\\'#0000CC\\', \\'#0000FF\\', \\'#0033CC\\', \\'#0033FF\\', \\'#0066CC\\', \\'#0066FF\\', \\'#0099CC\\', \\'#0099FF\\', \\'#00CC00\\', \\'#00CC33\\', \\'#00CC66\\', \\'#00CC99\\', \\'#00CCCC\\', \\'#00CCFF\\', \\'#3300CC\\', \\'#3300FF\\', \\'#3333CC\\', \\'#3333FF\\', \\'#3366CC\\', \\'#3366FF\\', \\'#3399CC\\', \\'#3399FF\\', \\'#33CC00\\', \\'#33CC33\\', \\'#33CC66\\', \\'#33CC99\\', \\'#33CCCC\\', \\'#33CCFF\\', \\'#6600CC\\', \\'#6600FF\\', \\'#6633CC\\', \\'#6633FF\\', \\'#66CC00\\', \\'#66CC33\\', \\'#9900CC\\', \\'#9900FF\\', \\'#9933CC\\', \\'#9933FF\\', \\'#99CC00\\', \\'#99CC33\\', \\'#CC0000\\', \\'#CC0033\\', \\'#CC0066\\', \\'#CC0099\\', \\'#CC00CC\\', \\'#CC00FF\\', \\'#CC3300\\', \\'#CC3333\\', \\'#CC3366\\', \\'#CC3399\\', \\'#CC33CC\\', \\'#CC33FF\\', \\'#CC6600\\', \\'#CC6633\\', \\'#CC9900\\', \\'#CC9933\\', \\'#CCCC00\\', \\'#CCCC33\\', \\'#FF0000\\', \\'#FF0033\\', \\'#FF0066\\', \\'#FF0099\\', \\'#FF00CC\\', \\'#FF00FF\\', \\'#FF3300\\', \\'#FF3333\\', \\'#FF3366\\', \\'#FF3399\\', \\'#FF33CC\\', \\'#FF33FF\\', \\'#FF6600\\', \\'#FF6633\\', \\'#FF9900\\', \\'#FF9933\\', \\'#FFCC00\\', \\'#FFCC33\\'];\\n/**\\n * Load `namespaces`.\\n *\\n * @return {String} returns the debug modes\\n * @api private\\n */\\n\\nfunction loadBrowser() {\\n  var namespaces;\\n\\n  try {\\n    namespaces = localStorage.getItem(\\'debug\\');\\n  } catch (error) {// Swallow\\n    // XXX (@Qix-) should we be logging these?\\n  } // If debug isn\\'t set in LS, and we\\'re in Electron, try to load $DEBUG\\n\\n\\n  if (!namespaces && typeof process !== \\'undefined\\' && \\'env\\' in process) {\\n    namespaces = process.env.DEBUG;\\n  }\\n\\n  return {\\n    namespaces: namespaces || \\'\\',\\n    colors: browserColors,\\n    useColors: true,\\n    formatArgs: formatBrowserArgs\\n  };\\n}\\n/**\\n * Load `namespaces`.\\n *\\n * @return {String} returns the debug modes\\n * @api private\\n */\\n\\n\\nfunction loadNode() {\\n  return {\\n    namespaces: process.env.DEBUG || \\'\\',\\n    colors: [6, 2, 3, 4, 5, 1],\\n    useColors: true,\\n    formatArgs: formatNodeArgs\\n  };\\n}\\n\\nfunction createLogger() {\\n  var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\\n  var config = arguments.length > 1 ? arguments[1] : undefined;\\n  return function () {\\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\\n      args[_key] = arguments[_key];\\n    }\\n\\n    if (prefix) {\\n      args.unshift(prefix);\\n    } // Create a namespace regex for each namespace\\n\\n\\n    var matches = config.namespaces.split(\\',\\').map(function (namespace) {\\n      // Remove wildcard and add to regex if wildcard\\n      if (namespace[namespace.length - 1] === \\'*\\') {\\n        return new RegExp(\\'^\\' + namespace.slice(0, namespace.length - 1) + \\'.*\\' + \\'$\\');\\n      }\\n\\n      return new RegExp(\\'^\\' + namespace + \\'$\\');\\n    }); // Does the prefix match a namespace\\n\\n    var match = matches.some(function (regex) {\\n      return regex.test(prefix);\\n    });\\n    var conf = {\\n      color: selectColor(prefix, config.colors),\\n      namespace: prefix,\\n      useColors: config.useColors\\n    };\\n\\n    if ( true && match) {\\n      var _console;\\n\\n      config.formatArgs(args, conf);\\n\\n      (_console = console).log.apply(_console, args);\\n    }\\n  };\\n}\\n\\nfunction nodeLogger(prefix) {\\n  return createLogger(prefix, loadNode());\\n}\\n\\nfunction browserLogger(prefix) {\\n  return createLogger(prefix, loadBrowser());\\n}\\n/**\\n * Detect Electron renderer / nwjs process, which is node, but we should\\n * treat as a browser.\\n */\\n\\n\\nif (typeof process === \\'undefined\\' || process.type === \\'renderer\\' || process.browser === true || process.__nwjs) {\\n  module.exports = browserLogger;\\n} else {\\n  module.exports = nodeLogger;\\n}\\n});\\n\\nvar debug$1 = debug(\\'informed:ObjMap\\' + \\'\\\\t\\');\\n/* -------------------- toPath -------------------- */\\n\\nvar ldtoPath = function ldtoPath() {\\n  var path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \\'\\';\\n  return String.prototype.replace.call(path, /\\\\[\\'(.+?)\\'\\\\]/g, \\'.$1\\').split(/[,[\\\\].]+?/).filter(Boolean);\\n};\\n/* --------------------- get --------------------- */\\n\\n\\nvar ldget = function ldget(obj) {\\n  var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \\'\\';\\n  var defaultValue = arguments.length > 2 ? arguments[2] : undefined;\\n  var result = String.prototype.replace.call(path, /\\\\[\\'(.+?)\\'\\\\]/g, \\'.$1\\').split(/[,[\\\\].]+?/).filter(Boolean).reduce(function (res, key) {\\n    return res !== null && res !== undefined ? res[key] : res;\\n  }, obj);\\n  return result === undefined || result === obj ? defaultValue : result;\\n};\\n/* --------------------- has --------------------- */\\n// foo --\\x3e\\n// foo.bar --\\x3e foo\\n// foo.bar[3] --\\x3e foo.bar\\n// foo.bar.baz[2].raz.taz[5].laz --\\x3e foo.bar.baz[2].raz.taz[5]\\n\\n\\nvar parentPath = function parentPath(path) {\\n  return \".\".concat(path).replace(/(.*)[.[].*/, \\'$1\\').replace(/\\\\./, \\'\\');\\n}; // foo --\\x3e foo\\n// foo.bar --\\x3e bar\\n// foo.bar[3] --\\x3e [3]\\n// foo.bar.baz[2].raz.taz[5].laz --\\x3e laz\\n\\n\\nvar pathKey = function pathKey(path) {\\n  return path.replace(parentPath(path), \\'\\').replace(/\\\\./, \\'\\');\\n};\\n\\nvar ldhas = function ldhas(obj, path) {\\n  var pPath = parentPath(path);\\n  var key = pathKey(path); // If we have parent path then get the object at that location\\n  // .. otherwise its the root object\\n\\n  var parentObj = pPath ? get(obj, pPath) : obj; // If its [3] turn key into 3\\n\\n  return !!(parentObj && Object.hasOwnProperty.call(parentObj, key.replace(/\\\\[(.*)\\\\]/, \\'$1\\')));\\n};\\n/* --------------------- set --------------------- */\\n\\n\\nvar ldset = function ldset(obj) {\\n  var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \\'\\';\\n  var val = arguments.length > 2 ? arguments[2] : undefined;\\n  String.prototype.replace.call(path, /\\\\[\\'(.+?)\\'\\\\]/g, \\'.$1\\').split(/[,[\\\\].]+?/).filter(Boolean).reduce(function (res, key, i, arr) {\\n    //console.log(\\'RES\\', res, \\'Key\\', key, \\'I\\', i, \\'Arr\\', arr, \\'OBJ\\', obj);\\n    // At the leaf set the value\\n    if (i === arr.length - 1) {\\n      res[key] = val;\\n      return res[key];\\n    } // Initialize to new array or object if needed\\n\\n\\n    if (res[key] === undefined) {\\n      if (Number.isInteger(+arr[i + 1])) {\\n        res[key] = [];\\n      } else {\\n        res[key] = {};\\n      }\\n\\n      return res[key];\\n    } // Exception for if the value is changeing to an array\\n\\n\\n    if (Number.isInteger(+arr[i + 1]) && !Array.isArray(res[key])) {\\n      res[key] = [];\\n    } //TODO exception for if object ??\\n    // Otherwise keep whats there\\n\\n\\n    return res[key];\\n  }, obj);\\n};\\n/* --------------------- unset --------------------- */\\n\\n\\nvar ldunset = function ldunset(obj) {\\n  var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \\'\\';\\n  var found = false;\\n  String.prototype.replace.call(path, /\\\\[\\'(.+?)\\'\\\\]/g, \\'.$1\\').split(/[,[\\\\].]+?/).filter(Boolean).reduce(function (res, key, i, arr) {\\n    // Base case res is undefined\\n    if (res === undefined) {\\n      return res;\\n    } // At the leaf delete the value\\n\\n\\n    if (i === arr.length - 1) {\\n      delete res[key];\\n      found = true;\\n      return res[key];\\n    } // Otherwise keep going\\n\\n\\n    return res[key];\\n  }, obj);\\n  return found;\\n};\\n/* --------------------- pullAt --------------------- */\\n\\n\\nvar ldpullAt = function ldpullAt(obj) {\\n  var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \\'\\';\\n  var pulled;\\n  String.prototype.replace.call(path, /\\\\[\\'(.+?)\\'\\\\]/g, \\'.$1\\').split(/[,[\\\\].]+?/).filter(Boolean).reduce(function (res, key, i, arr) {\\n    // Base case res is undefined\\n    if (res === undefined) {\\n      return res;\\n    } // At the leaf delete the value\\n\\n\\n    if (i === arr.length - 1 && Array.isArray(res)) {\\n      // Pull out one value at index ( key )\\n      pulled = res.splice(key, 1);\\n      return res[key];\\n    } // Otherwise keep going\\n\\n\\n    return res[key];\\n  }, obj);\\n  return pulled;\\n};\\n/* --------------------- values --------------------- */\\n\\n\\nvar ldvalues = function ldvalues() {\\n  var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n  var props = Object.keys(obj);\\n  return props.map(function (key) {\\n    return obj[key];\\n  });\\n};\\n\\nvar pathToArrayElem = function pathToArrayElem(path) {\\n  var pathArray = ldtoPath(path);\\n  return Number.isInteger(+pathArray[pathArray.length - 1]);\\n};\\n\\nvar ObjectMap = /*#__PURE__*/function () {\\n  function ObjectMap() {\\n    _classCallCheck(this, ObjectMap);\\n  }\\n\\n  _createClass(ObjectMap, null, [{\\n    key: \"empty\",\\n    value: function empty(object) {\\n      return ldvalues(object).length === 0;\\n    }\\n  }, {\\n    key: \"get\",\\n    value: function get(object, path) {\\n      var val = ldget(object, path); //debug(\\'GOT\\', path, val);\\n\\n      return val;\\n    }\\n  }, {\\n    key: \"has\",\\n    value: function has(object, path) {\\n      return ldhas(object, path);\\n    }\\n  }, {\\n    key: \"set\",\\n    value: function set(object, path, value) {\\n      if (value !== undefined) {\\n        debug$1(\\'SETTING\\', path, value);\\n        ldset(object, path, value);\\n      } else {\\n        // Setting things to undefined in informed is special!\\n        // so in this else statement we deal with that\\n        // If the path is to an array leaf then we want to set to undefined\\n        // Example:\\n        // path = \\'foo.bar[2]\\'\\n        // foo.bar = [ \\'baz\\', \\'raz\\', \\'taz\\' ]\\n        // setting taz to undefined   ^^^\\n        if (pathToArrayElem(path) && ObjectMap.get(object, path) !== undefined) {\\n          debug$1(\\'Special case SETTING\\', path, \\'to undefined\\');\\n          ldset(object, path, undefined);\\n          var pathArray = ldtoPath(path);\\n          pathArray = pathArray.slice(0, pathArray.length - 1);\\n          cleanup(object, pathArray);\\n        } // Only delete the field if it needs to be deleted and its not a path to an array ( array leaf )\\n        // Example:\\n        // path = \\'foo.bar\\'\\n        // foo.bar = \\'baz\\'\\n        // removing foo.bar from the object completley\\n        else if (!pathToArrayElem(path) && ObjectMap.get(object, path) !== undefined) {\\n            debug$1(\\'Special case REMOVING\\', path, \\'from object completley\\');\\n            ObjectMap[\"delete\"](object, path);\\n          }\\n      }\\n    }\\n  }, {\\n    key: \"delete\",\\n    value: function _delete(object, path) {\\n      debug$1(\\'DELETE\\', path); // Special case for arrays\\n\\n      if (pathToArrayElem(path)) {\\n        debug$1(\\'ARRAY\\', path); //ldunset(object, path);\\n\\n        this.pullOut(object, path);\\n      } else {\\n        ldunset(object, path);\\n      }\\n\\n      var pathArray = ldtoPath(path);\\n      pathArray = pathArray.slice(0, pathArray.length - 1);\\n      cleanup(object, pathArray);\\n    } // Very important ;)\\n\\n  }, {\\n    key: \"pullOut\",\\n    value: function pullOut(object, path) {\\n      // Get the path to the array\\n      var pathArray = ldtoPath(path); // debug(\\'PathArray1\\', pathArray);\\n\\n      var index = pathArray[pathArray.length - 1];\\n      pathArray = pathArray.slice(0, pathArray.length - 1);\\n      debug$1(\\'Pulling out:\\', pathArray, \\'index\\', index); // Get the array\\n\\n      var arr = ldget(object, pathArray);\\n      debug$1(\\'Array\\', arr); // Pull out of array\\n\\n      if (Array.isArray(arr)) {\\n        ldpullAt(arr, index);\\n      }\\n\\n      cleanup(object, pathArray);\\n    }\\n  }]);\\n\\n  return ObjectMap;\\n}();\\n\\nfunction cleanup(obj, path) {\\n\\n  // Base case no path left\\n  if (path.length === 0) {\\n    return;\\n  }\\n\\n  var object = ldget(obj, path); // Clean up undefined from array\\n  // if (Array.isArray(object) && pull) {\\n  //   ldpull(object, undefined);\\n  // }\\n  // Delete object if its empty\\n\\n  if (Array.isArray(object) ? object.every(function (e) {\\n    return e == null;\\n  }) : JSON.stringify(object) === \\'{}\\') {\\n    ldunset(obj, path);\\n  } // Recur\\n\\n\\n  cleanup(obj, path.slice(0, path.length - 1));\\n}\\n\\nvar FormRegisterContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createContext({\\n  register: function register() {},\\n  deregister: function deregister() {},\\n  setValue: function setValue() {},\\n  setTouched: function setTouched() {},\\n  setError: function setError() {},\\n  update: function update() {},\\n  getField: function getField() {},\\n  expectRemoval: function expectRemoval() {},\\n  getInitialValue: function getInitialValue() {}\\n});\\nvar FormStateContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createContext({});\\nvar FormApiContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createContext({\\n  getFullField: function getFullField() {},\\n  getValues: function getValues() {},\\n  getOptions: function getOptions() {\\n    return {};\\n  },\\n  setInitialValue: function setInitialValue() {},\\n  getInitialValue: function getInitialValue() {},\\n  getDerrivedValue: function getDerrivedValue() {},\\n  getSavedValue: function getSavedValue() {},\\n  removeSavedState: function removeSavedState() {}\\n});\\nvar GroupContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createContext();\\nvar ArrayFieldStateContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createContext();\\nvar ArrayFieldApiContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createContext();\\nvar ArrayFieldItemApiContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createContext();\\nvar ArrayFieldItemStateContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createContext();\\nvar MultistepStateContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createContext();\\nvar MultistepApiContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createContext();\\nvar MultistepStepContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createContext();\\n\\nfunction useFormApi() {\\n  var formApi = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useContext\"])(FormApiContext);\\n  return formApi;\\n}\\n\\n// https://github.com/facebook/react/issues/14543\\n\\nfunction useStateWithGetter(initial) {\\n  var ref = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])();\\n  var mounted = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(true);\\n\\n  var _useState = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useState\"])(initial),\\n      _useState2 = _slicedToArray(_useState, 2),\\n      state = _useState2[0],\\n      setState = _useState2[1];\\n\\n  ref.current = state;\\n\\n  var set = function set(value) {\\n    ref.current = value;\\n    if (mounted.current) setState(value);\\n  };\\n\\n  var get = function get() {\\n    return ref.current;\\n  };\\n\\n  Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"])(function () {\\n    return function () {\\n      mounted.current = false;\\n    };\\n  }, []);\\n  return [state, set, get];\\n}\\n\\nvar getChildDisplayName = function getChildDisplayName(WrappedComponent) {\\n  // fix for \"memo\" components\\n  if (WrappedComponent.type && WrappedComponent.type.name) {\\n    return WrappedComponent.type.name;\\n  }\\n\\n  return WrappedComponent.displayName || WrappedComponent.name || \\'Component\\';\\n};\\nvar yupToFormErrors = function yupToFormErrors(yupError) {\\n  var errors = {};\\n\\n  if (yupError.inner) {\\n    if (yupError.inner.length === 0) {\\n      // console.log(yupError.path);\\n      ObjectMap.set(errors, yupError.path, yupError.message);\\n      return;\\n    }\\n\\n    var _iterator = _createForOfIteratorHelper(yupError.inner),\\n        _step;\\n\\n    try {\\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\\n        var err = _step.value;\\n\\n        if (!ObjectMap.get(errors, err.path)) {\\n          // console.log(errors, err.path, err.message);\\n          ObjectMap.set(errors, err.path, err.message);\\n        }\\n      }\\n    } catch (err) {\\n      _iterator.e(err);\\n    } finally {\\n      _iterator.f();\\n    }\\n  }\\n\\n  return errors;\\n};\\nvar validateYupSchema = function validateYupSchema(schema, values) {\\n  try {\\n    schema.validateSync(values, {\\n      abortEarly: false\\n    });\\n  } catch (e) {\\n    var formErrors = yupToFormErrors(e);\\n    return formErrors;\\n  }\\n};\\nvar yupToFormError = function yupToFormError(yupError) {\\n  if (yupError.inner) {\\n    if (yupError.inner.length === 0) {\\n      return;\\n    }\\n\\n    var err = yupError.inner[0];\\n    return err.message;\\n  }\\n};\\nvar validateYupField = function validateYupField(schema, value) {\\n  try {\\n    schema.validateSync(value, {\\n      abortEarly: false\\n    });\\n  } catch (e) {\\n    return yupToFormError(e);\\n  }\\n};\\nvar validateAjvSchema = function validateAjvSchema(validate, data) {\\n  validate(data);\\n  var errors = {};\\n\\n  if (validate.errors) {\\n    validate.errors.forEach(function (_ref) {\\n      var message = _ref.message,\\n          dataPath = _ref.dataPath,\\n          keyword = _ref.keyword,\\n          params = _ref.params;\\n      var path = dataPath; // Special case for required\\n\\n      if (keyword === \\'required\\') {\\n        path = \"\".concat(path, \".\").concat(params.missingProperty);\\n      } // Get rid of leading dot\\n\\n\\n      path = path.replace(\\'.\\', \\'\\'); // console.log(\\'PATH\\', path, message);\\n      // TODO get message from informed if present\\n\\n      ObjectMap.set(errors, path, message);\\n    });\\n  }\\n\\n  return errors;\\n}; // https://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript\\n\\nvar uuidv4 = function uuidv4() {\\n  return \\'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\\'.replace(/[xy]/g, function (c) {\\n    var r = Math.random() * 16 | 0,\\n        v = c == \\'x\\' ? r : r & 0x3 | 0x8;\\n    return v.toString(16);\\n  });\\n};\\nvar computeFieldFromProperty = function computeFieldFromProperty(propertyName, property, prefix) {\\n  var uiControl = property[\\'ui:control\\'],\\n      informedProps = property[\\'informed:props\\'],\\n      inputProps = property[\\'input:props\\'],\\n      uiBefore = property[\\'ui:before\\'],\\n      uiAfter = property[\\'ui:after\\'],\\n      oneOf = property.oneOf,\\n      items = property.items,\\n      schemaEnum = property[\"enum\"],\\n      label = property.title,\\n      min = property.minimum,\\n      max = property.maximum,\\n      minLength = property.minLength,\\n      maxLength = property.maxLength,\\n      pattern = property.pattern,\\n      type = property.type,\\n      subProperties = property.properties; // Set Id if not passed\\n\\n  var id = uuidv4();\\n\\n  if (inputProps && inputProps.id) {\\n    id = inputProps.id;\\n  }\\n\\n  var field = {\\n    componentType: uiControl,\\n    field: prefix ? \"\".concat(prefix, \".\").concat(propertyName) : propertyName,\\n    type: type,\\n    uiBefore: uiBefore,\\n    uiAfter: uiAfter,\\n    properties: type === \\'object\\' ? subProperties : undefined,\\n    items: type === \\'array\\' ? items : undefined,\\n    props: _objectSpread2(_objectSpread2({\\n      label: label,\\n      id: id,\\n      min: min,\\n      max: max,\\n      minLength: minLength,\\n      maxLength: maxLength,\\n      pattern: pattern\\n    }, informedProps), inputProps)\\n  };\\n\\n  if (oneOf) {\\n    var options = property.oneOf.map(function (option) {\\n      var _option$inputProps = option[\\'input:props\\'],\\n          inputProps = _option$inputProps === void 0 ? {} : _option$inputProps;\\n      return _objectSpread2({\\n        value: option[\"const\"],\\n        label: option.title\\n      }, inputProps);\\n    });\\n    field.props.options = options;\\n  }\\n\\n  if (schemaEnum) {\\n    var _options = property[\"enum\"].map(function (val) {\\n      return {\\n        value: val,\\n        label: val\\n      };\\n    });\\n\\n    field.props.options = _options;\\n  }\\n\\n  if (items && items.oneOf) {\\n    var _options2 = items.oneOf.map(function (option) {\\n      var _option$inputProps2 = option[\\'input:props\\'],\\n          inputProps = _option$inputProps2 === void 0 ? {} : _option$inputProps2;\\n      return _objectSpread2({\\n        value: option[\"const\"],\\n        label: option.title\\n      }, inputProps);\\n    });\\n\\n    field.props.options = _options2;\\n  }\\n\\n  return field;\\n};\\nvar computeFieldsFromSchema = function computeFieldsFromSchema(schema, onlyValidateSchema, prefix) {\\n  if (!schema || onlyValidateSchema) {\\n    return [];\\n  } // Grab properties and items off of schema\\n\\n\\n  var _schema$properties = schema.properties,\\n      properties = _schema$properties === void 0 ? {} : _schema$properties,\\n      allOf = schema.allOf,\\n      _schema$propertyOrder = schema.propertyOrder,\\n      propertyOrder = _schema$propertyOrder === void 0 ? [] : _schema$propertyOrder;\\n\\n  if (Object.keys(properties).length > 0) {\\n    // Attempt to generate fields from properties\\n    var fields = Object.keys(properties).sort(function (a, b) {\\n      var aIndex = propertyOrder.indexOf(a);\\n      var bIndex = propertyOrder.indexOf(b);\\n      return (aIndex > -1 ? aIndex : propertyOrder.length + 1) - (bIndex > -1 ? bIndex : propertyOrder.length + 1);\\n    }).map(function (propertyName) {\\n      var property = properties[propertyName];\\n      var field = computeFieldFromProperty(propertyName, property, prefix);\\n      return field;\\n    }); // Check for all of ( we have conditionals )\\n\\n    if (allOf) {\\n      fields.push({\\n        componentType: \\'conditionals\\',\\n        // Each element of the \"allOf\" array is a conditional\\n        allOf: allOf\\n      });\\n    }\\n\\n    return fields;\\n  }\\n\\n  return [];\\n}; // Examples\\n// field = \"name\" ---\\x3e properties.name\\n// field = \"brother.name\" ---\\x3e properties.brother.properties.name\\n// field = \"brother.siblings[1].friend.name\" ---\\x3e properties.brother.properties.siblings.items[1].properties.friend.properties.name\\n\\nvar getSchemaPathFromJsonPath = function getSchemaPathFromJsonPath(jsonPath) {\\n  // Convert\\n  var schemaPath = jsonPath.replace(/\\\\./g, \\'.properties.\\').replace(/\\\\[/g, \\'.itmes[\\'); // Add first properties\\n\\n  schemaPath = \"properties.\".concat(schemaPath);\\n  return schemaPath;\\n};\\n/* -------------------------- Formatter ----------------------------- */\\n\\nvar getFormatter = function getFormatter(formatter, value) {\\n  // If mask is a string turn it into an array;\\n  if (typeof formatter === \\'string\\') {\\n    return formatter.split(\\'\\').map(function (_char) {\\n      if (_char === \\'#\\') {\\n        return /\\\\d/;\\n      }\\n\\n      if (_char === \\'*\\') {\\n        return /[\\\\w]/;\\n      }\\n\\n      return _char;\\n    });\\n  } // If mask is a function use it to genreate current mask\\n\\n\\n  if (typeof formatter === \\'function\\') {\\n    return formatter(value);\\n  }\\n\\n  if (Array.isArray(formatter)) {\\n    return formatter;\\n  } // Should never make it here throw\\n\\n\\n  throw new Error(\\'Formatter must be string, array, or function\\');\\n};\\n\\nvar matchingIndex = function matchingIndex(a, b) {\\n  var i = 0;\\n  var mi = -1;\\n  var matching = true; // a = \"+1 \"\\n  // b = \"+12\"\\n\\n  while (matching && i < a.length) {\\n    if (a[i] == b[i]) {\\n      mi = i;\\n    } else {\\n      matching = false;\\n    }\\n\\n    i = i + 1;\\n  }\\n\\n  return mi;\\n};\\n\\nvar informedFormat = function informedFormat(value, frmtr) {\\n  // console.log(\\'Formatting\\', value);\\n  // Null check\\n  if (!value) {\\n    return {\\n      value: value,\\n      offset: 0\\n    };\\n  } // Generate formatter array\\n\\n\\n  var formatter = getFormatter(frmtr, value); // Start to fill in the array\\n  // Example: phone formatter\\n  // formatter =[\\'+\\', \\'1\\', \\' \\', /\\\\d/, /\\\\d/, /\\\\d/, \\'-\\', /\\\\d/, /\\\\d/, /\\\\d/, \\'-\\', /\\\\d/, /\\\\d/, /\\\\d/, /\\\\d/]\\n  // value examples:\\n  // \"1231231234 ----\\x3e +1 123-123-1234\\n  // \"+\" \\t\\t\\t\\t ----\\x3e +\\n  // \"+1\" \\t\\t\\t ----\\x3e +1\\n  // \"+2\"\\t\\t\\t\\t ----\\x3e +1 2\\n  // \"1\"\\t\\t\\t\\t ----\\x3e +1 1\\n  // \"1234\"\\t\\t\\t ----\\x3e +1 123-4\\n  // \"123a\"      ----\\x3e +1 123\\n  // Determine prefix length and suffix start\\n\\n  var prefixLength = formatter.findIndex(function (v) {\\n    return typeof v != \\'string\\';\\n  });\\n\\n  var suffixStart = formatter.length - _toConsumableArray(formatter).reverse().findIndex(function (v) {\\n    return typeof v != \\'string\\';\\n  }); // Formatted value\\n\\n\\n  var formatted = []; // The characters from the current value\\n\\n  var chars = value.split(\\'\\'); // To track the value index during itteration\\n\\n  var vIndex = 0;\\n  var start = 0; // If the value matches part of the prefix take it out\\n  // Example prefix = \"+1 \" value = [\"+1 123-123-1234\", \"+12\", \"+2\"]\\n\\n  var matchIndex = matchingIndex(formatter.slice(0, prefixLength), chars.slice(0, prefixLength)); // console.log(\\'Matching index\\', matchIndex);\\n\\n  if (matchIndex > -1) {\\n    //vIndex = prefixLength;\\n    vIndex = matchIndex + 1;\\n    formatted = formatted.concat(formatter.slice(0, matchIndex + 1));\\n    start = matchIndex + 1;\\n  } // Example prefix = \"+1 \" value=[\"1\", \"1234\"]\\n\\n\\n  if (matchIndex < 0) {\\n    // Start past the prefix\\n    formatted = formatted.concat(formatter.slice(0, prefixLength));\\n    start = prefixLength;\\n  } // console.log(\\'start\\', start, formatted);\\n\\n  for (var i = start; i < formatter.length; i++) {\\n    // Get current formatter location matcher\\n    var matcher = formatter[i]; // We get past the prefix if matcher is not a string\\n\\n\\n    if (vIndex != chars.length) {\\n      // Get the current value character\\n      var curChar = chars[vIndex]; // If type is string normal compare otherwise regex compare\\n\\n      var match = typeof matcher === \\'string\\' ? matcher === curChar : matcher.test(curChar); // If the current character of the value matches and matcher is a string\\n      // \"1\" === \"1\"\\n\\n      if (match && typeof matcher === \\'string\\') {\\n        formatted.push(matcher); //if( pastPrefix ){\\n\\n        vIndex = vIndex + 1; //}\\n      } // If the current character does not match and matcher is a stirng\\n      // \"1\" != \"+\"\\n      else if (!match && typeof matcher === \\'string\\') {\\n          // Special check for 123a ---\\x3e dont want \"+1 123-\"\\n          // Special check for 1234 ---\\x3e DO want \"+1 123-4\"\\n          if (vIndex != chars.length) formatted.push(matcher);\\n        } // If the current character matches and the matcher is not a string\\n        // /\\\\d/.test(\"2\")\\n        else if (match && typeof matcher != \\'string\\') {\\n            formatted.push(curChar);\\n            vIndex = vIndex + 1;\\n          } // If the current character does NOT match and the matecer is regex\\n          // /\\\\d/.test(\"a\")\\n          else if (!match && typeof matcher != \\'string\\') {\\n              // Throw out this value\\n              vIndex = vIndex + 1;\\n              i = i - 1;\\n            }\\n    } else {\\n      // If mattcher is a string and we are at suffix keep going\\n      if (typeof matcher === \\'string\\' && i >= suffixStart) {\\n        formatted.push(matcher);\\n      } else {\\n        // Otherwise we want to break out\\n        break;\\n      }\\n    }\\n  }\\n\\n  return {\\n    value: formatted.join(\\'\\'),\\n    offset: value ? formatted.length - value.length : 0\\n  };\\n};\\n\\n// To get around it, we can conditionally useEffect on the server (no-op) and\\n// useLayoutEffect in the browser.\\n// @see https://gist.github.com/gaearon/e7d97cdf38a2907924ea12e4ebdf3c85\\n\\nvar useIsomorphicLayoutEffect = typeof window !== \\'undefined\\' && typeof window.document !== \\'undefined\\' && typeof window.document.createElement !== \\'undefined\\' ? react__WEBPACK_IMPORTED_MODULE_0__[\"useLayoutEffect\"] : react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"];\\n\\nvar logger = debug(\\'informed:useField\\' + \\'\\\\t\\'); // localStorage.debug = \\'informed:.*\\' << HOW to enable debuging\\n\\nvar initializeValue = function initializeValue(value, mask, formatter, parser) {\\n  if (value != null) {\\n    // Call mask if it was passed\\n    if (mask) {\\n      return mask(value);\\n    }\\n\\n    if (formatter && !parser) {\\n      var res = informedFormat(value, formatter);\\n      return res.value;\\n    }\\n\\n    return value;\\n  } // Not needed but called out specifically\\n\\n\\n  return undefined;\\n};\\n\\nvar initializeMask = function initializeMask(value, format, parse, formatter) {\\n  // Call format and parse if they were passed\\n  if (format && parse) {\\n    return format(value);\\n  } // Call formatter\\n\\n\\n  if (formatter) {\\n    var res = informedFormat(value, formatter);\\n    return res.value;\\n  }\\n\\n  return value;\\n};\\n\\nvar generateValidationFunction = function generateValidationFunction(validationFunc, validationSchema, _ref) {\\n  var required = _ref.required;\\n\\n  // We dont want a validation function if there was nothing passed\\n  if (validationFunc || validationSchema) {\\n    return function (val, values) {\\n      if (validationSchema) {\\n        return validateYupField(validationSchema, val);\\n      }\\n\\n      if (validationFunc) {\\n        return validationFunc(val, values);\\n      }\\n    };\\n  }\\n\\n  if (required) {\\n    return function (val) {\\n      return validateRequired(val, required);\\n    };\\n  }\\n};\\n\\nvar generateOnChange = function generateOnChange(_ref2) {\\n  var fieldType = _ref2.fieldType,\\n      setValue = _ref2.setValue,\\n      onChange = _ref2.onChange,\\n      multiple = _ref2.multiple,\\n      ref = _ref2.ref;\\n\\n  var setter = function setter(val) {\\n    return setValue(val);\\n  };\\n\\n  if (fieldType === \\'text\\' || fieldType === \\'textArea\\' || fieldType === \\'number\\') {\\n    setter = function setter(e) {\\n      return setValue(e.target.value, e);\\n    };\\n  }\\n\\n  if (fieldType === \\'select\\') {\\n    setter = function setter() {\\n      var selected = Array.from(ref.current).filter(function (option) {\\n        return option.selected;\\n      }).map(function (option) {\\n        return option.value;\\n      });\\n      setValue(multiple ? selected : selected[0] || \\'\\');\\n    };\\n  }\\n\\n  if (fieldType === \\'checkbox\\') {\\n    setter = function setter(e) {\\n      setValue(e.target.checked);\\n\\n      if (onChange) {\\n        onChange(e);\\n      }\\n    };\\n  }\\n\\n  return function (val) {\\n    setter(val);\\n\\n    if (onChange) {\\n      onChange(val);\\n    }\\n  };\\n};\\n\\nvar generateOnBlur = function generateOnBlur(_ref3) {\\n  var setTouched = _ref3.setTouched,\\n      onBlur = _ref3.onBlur;\\n  return function (e) {\\n    setTouched(true);\\n\\n    if (onBlur) {\\n      onBlur(e);\\n    }\\n  };\\n};\\n\\nvar generateValue = function generateValue(_ref4) {\\n  var fieldType = _ref4.fieldType,\\n      maskedValue = _ref4.maskedValue,\\n      multiple = _ref4.multiple,\\n      value = _ref4.value;\\n\\n  switch (fieldType) {\\n    case \\'text\\':\\n    case \\'number\\':\\n      return !maskedValue && maskedValue !== 0 ? \\'\\' : maskedValue;\\n\\n    case \\'textArea\\':\\n      return !maskedValue ? \\'\\' : maskedValue;\\n\\n    case \\'select\\':\\n      return value || (multiple ? [] : \\'\\');\\n\\n    case \\'checkbox\\':\\n      return !!value;\\n\\n    default:\\n      return value;\\n  }\\n};\\n\\nvar generateFieldType = function generateFieldType(fieldType) {\\n  switch (fieldType) {\\n    case \\'text\\':\\n      return fieldType;\\n\\n    case \\'number\\':\\n      return fieldType;\\n\\n    case \\'checkbox\\':\\n      return fieldType;\\n\\n    default:\\n      return;\\n  }\\n};\\n\\nvar validateRequired = function validateRequired(value, required) {\\n  if (required && (value == null || value === \\'\\')) {\\n    return typeof required === \\'string\\' ? required : \\'This field is required\\';\\n  }\\n};\\n\\nfunction useField() {\\n  var fieldProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n  var userRef = arguments.length > 1 ? arguments[1] : undefined;\\n\\n  // Pull props off of field props\\n  var field = fieldProps.field,\\n      validationFunc = fieldProps.validate,\\n      asyncValidate = fieldProps.asyncValidate,\\n      validationSchema = fieldProps.validationSchema,\\n      mask = fieldProps.mask,\\n      maskWithCursorOffset = fieldProps.maskWithCursorOffset,\\n      format = fieldProps.format,\\n      parse = fieldProps.parse,\\n      formatter = fieldProps.formatter,\\n      parser = fieldProps.parser,\\n      initialValue = fieldProps.initialValue,\\n      validateOnChange = fieldProps.validateOnChange,\\n      validateOnBlur = fieldProps.validateOnBlur,\\n      validateOnMount = fieldProps.validateOnMount,\\n      asyncValidateOnBlur = fieldProps.asyncValidateOnBlur,\\n      maskOnBlur = fieldProps.maskOnBlur,\\n      allowEmptyString = fieldProps.allowEmptyString,\\n      onValueChange = fieldProps.onValueChange,\\n      notify = fieldProps.notify,\\n      keepState = fieldProps.keepState,\\n      maintainCursor = fieldProps.maintainCursor,\\n      debug = fieldProps.debug,\\n      shadow = fieldProps.shadow,\\n      step = fieldProps.step,\\n      fieldType = fieldProps.fieldType,\\n      multiple = fieldProps.multiple,\\n      onChange = fieldProps.onChange,\\n      onBlur = fieldProps.onBlur,\\n      formController = fieldProps.formController,\\n      userRelevant = fieldProps.relevant,\\n      required = fieldProps.required,\\n      keepStateIfRelevant = fieldProps.keepStateIfRelevant,\\n      userProps = _objectWithoutProperties(fieldProps, [\"field\", \"validate\", \"asyncValidate\", \"validationSchema\", \"mask\", \"maskWithCursorOffset\", \"format\", \"parse\", \"formatter\", \"parser\", \"initialValue\", \"validateOnChange\", \"validateOnBlur\", \"validateOnMount\", \"asyncValidateOnBlur\", \"maskOnBlur\", \"allowEmptyString\", \"onValueChange\", \"notify\", \"keepState\", \"maintainCursor\", \"debug\", \"shadow\", \"step\", \"fieldType\", \"multiple\", \"onChange\", \"onBlur\", \"formController\", \"relevant\", \"required\", \"keepStateIfRelevant\"]); // Create ref to a field id\\n\\n\\n  var _useState = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useState\"])(uuidv4()),\\n      _useState2 = _slicedToArray(_useState, 1),\\n      fieldId = _useState2[0]; // Grab the form register context\\n\\n\\n  var updater = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useContext\"])(FormRegisterContext); // Grab multistepContext\\n\\n  var multistepContext = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useContext\"])(MultistepStepContext);\\n  var inMultistep = multistepContext || keepStateIfRelevant; // Grab the form api\\n\\n  var formApi = useFormApi(); // Create ref to fieldApi\\n\\n  var fieldApiRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(); // Create initial render ref\\n\\n  var initialRenerRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(true); // Create ref to fieldObject\\n\\n  var fieldObjectRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(); // If the form Controller was passed in then use that instead\\n\\n  if (formController) {\\n    updater = formController.updater;\\n    formApi = formController.getFormApi();\\n  } // Generate validation function\\n\\n\\n  var validate = generateValidationFunction(validationFunc, validationSchema, {\\n    required: required\\n  }); // Grab possible initial value from form\\n\\n  var _useState3 = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useState\"])(function () {\\n    return updater.getInitialValue(field);\\n  }),\\n      _useState4 = _slicedToArray(_useState3, 1),\\n      formInitialValue = _useState4[0]; // We might have keep state so check for it!\\n\\n\\n  var savedState = formApi.getSavedValue(field); // Create Initial Values\\n\\n  var initVal;\\n  var initTouched; // We do these checks because initial value could be false or zero!!\\n\\n  if ((keepState || inMultistep) && savedState) {\\n    logger(\"Setting field \".concat(name, \"\\'s kept state\"), savedState);\\n    initVal = savedState.value;\\n    initTouched = savedState.touched; // Remove the saved state\\n\\n    formApi.removeSavedState(name);\\n  } else if (initialValue != undefined) {\\n    initVal = initialValue;\\n  } else {\\n    initVal = formInitialValue;\\n  } // Initialize state\\n\\n\\n  var _useStateWithGetter = useStateWithGetter(initializeValue(initVal, mask, formatter, parser)),\\n      _useStateWithGetter2 = _slicedToArray(_useStateWithGetter, 3),\\n      value = _useStateWithGetter2[0],\\n      setVal = _useStateWithGetter2[1],\\n      getTheVal = _useStateWithGetter2[2];\\n\\n  var _useStateWithGetter3 = useStateWithGetter(validateOnMount ? validate(value) : undefined),\\n      _useStateWithGetter4 = _slicedToArray(_useStateWithGetter3, 3),\\n      error = _useStateWithGetter4[0],\\n      setErr = _useStateWithGetter4[1],\\n      getErr = _useStateWithGetter4[2];\\n\\n  var _useStateWithGetter5 = useStateWithGetter(initTouched),\\n      _useStateWithGetter6 = _slicedToArray(_useStateWithGetter5, 3),\\n      touched = _useStateWithGetter6[0],\\n      setTouch = _useStateWithGetter6[1],\\n      getTouch = _useStateWithGetter6[2];\\n  /* eslint-disable no-unused-vars */\\n\\n\\n  var _useStateWithGetter7 = useStateWithGetter(0),\\n      _useStateWithGetter8 = _slicedToArray(_useStateWithGetter7, 3),\\n      cursor = _useStateWithGetter8[0],\\n      setCursor = _useStateWithGetter8[1],\\n      getCursor = _useStateWithGetter8[2];\\n\\n  var _useStateWithGetter9 = useStateWithGetter(0),\\n      _useStateWithGetter10 = _slicedToArray(_useStateWithGetter9, 3),\\n      cursorOffset = _useStateWithGetter10[0],\\n      setCursorOffset = _useStateWithGetter10[1],\\n      getCursorOffset = _useStateWithGetter10[2];\\n\\n  var _useState5 = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useState\"])(function () {\\n    return initializeMask(value, format, parse, formatter);\\n  }),\\n      _useState6 = _slicedToArray(_useState5, 2),\\n      maskedValue = _useState6[0],\\n      setMaskedValue = _useState6[1]; // Create then update refs to props\\n\\n\\n  var initialValueRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(initialValue);\\n  var fieldRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(field);\\n  var prevFieldRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])();\\n  initialValueRef.current = initialValue;\\n  fieldRef.current = field; // Default relevant function\\n\\n  var relevantFunc = function relevantFunc() {\\n    return true;\\n  };\\n\\n  var relevant = function relevant(params) {\\n    var rel = userRelevant || relevantFunc;\\n    var ff = formApi.getFullField(fieldRef.current) || fieldRef.current;\\n    var args = {\\n      path: ff,\\n      parentPath: ff.replace(/(.*)[.[].*/, \\'$1\\'),\\n      get: function get(values, path) {\\n        return ObjectMap.get(values, path);\\n      }\\n    };\\n\\n    if (multistepContext && multistepContext.relevant) {\\n      return rel(params, args) && multistepContext.relevant(params, args);\\n    }\\n\\n    return rel(params, args);\\n  };\\n\\n  var _useStateWithGetter11 = useStateWithGetter(relevant(formApi.getValues())),\\n      _useStateWithGetter12 = _slicedToArray(_useStateWithGetter11, 3),\\n      isRelevant = _useStateWithGetter12[0],\\n      setIsRelevant = _useStateWithGetter12[1],\\n      getIsRelevant = _useStateWithGetter12[2];\\n\\n  var multistepRelevant = function multistepRelevant(params) {\\n    if (multistepContext && multistepContext.relevant) {\\n      return multistepContext.relevant(params);\\n    }\\n\\n    return true;\\n  };\\n\\n  var checkRelevant = function checkRelevant() {\\n    var newRel = relevant(formApi.getValues());\\n    var curRel = getIsRelevant();\\n\\n    if (newRel != curRel) {\\n      setIsRelevant(newRel);\\n    }\\n\\n    return newRel;\\n  };\\n\\n  Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"])(function () {\\n    // Reset if we dont have keep state and relevance changed.\\n    if (!isRelevant && !keepState) {\\n      fieldApiRef.current.reset();\\n    }\\n  }, [isRelevant]); // Special getter to support shadow fields\\n\\n  var getVal = function getVal() {\\n    return shadow ? formApi.getDerrivedValue(field) : getTheVal();\\n  };\\n  /* ---------------------- Setters ---------------------- */\\n  // ---- Define set error ----\\n\\n\\n  var setError = function setError(val) {\\n    var _ref5 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\\n        preventUpdate = _ref5.preventUpdate;\\n\\n    // For multistep forms always set error to undefined when not at that step\\n    if (step && formApi.getStep() < step) {\\n      logger(\"Setting \".concat(field, \"\\'s error to undefined as we are not at that step\"));\\n      setErr(undefined);\\n      updater.setError(fieldId, undefined, !preventUpdate);\\n    } else {\\n      logger(\"Setting \".concat(field, \"\\'s error to \").concat(val));\\n      setErr(val);\\n      updater.setError(fieldId, val, !preventUpdate);\\n    }\\n  }; // ---- Define set value ----\\n\\n\\n  var setValue = function setValue(val, e) {\\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\\n    logger(\"Setting \".concat(field, \" to \").concat(val)); // Get the most up to date options\\n\\n    var formOptions = formApi.getOptions(); // Initialize maked value\\n\\n    var maskedVal = val;\\n\\n    if (val === \\'\\' && !allowEmptyString && !options.allowEmptyString && !formOptions.allowEmptyStrings) {\\n      val = undefined;\\n    } // Turn string into number for number fields\\n\\n\\n    if ((fieldProps.type === \\'number\\' || fieldType === \\'number\\') && val !== undefined) {\\n      val = +val;\\n    } // Remember Cursor position!\\n\\n\\n    if (e && e.target && e.target.selectionStart) {\\n      setCursor(e.target.selectionStart);\\n    } // Call mask if it was passed\\n\\n\\n    if (mask && !maskOnBlur) {\\n      maskedVal = mask(val, getCursor());\\n      val = mask(val, getCursor());\\n    } // Call maskWithCursorOffset if it was passed\\n\\n\\n    if (maskWithCursorOffset && !maskOnBlur) {\\n      var res = maskWithCursorOffset(val, getCursor());\\n      maskedVal = res.value;\\n      val = res.value;\\n      setCursorOffset(res.offset);\\n    } // Call format and parse if they were passed\\n\\n\\n    if (format && parse) {\\n      // Masked value only differs from value when format and parse are used\\n      val = parse(val);\\n      maskedVal = format(val);\\n    } // Call formatter and parser if passed\\n\\n\\n    if (formatter) {\\n      var _res = informedFormat(val, formatter);\\n\\n      setCursorOffset(_res.offset);\\n      maskedVal = _res.value;\\n      val = maskedVal;\\n    } // // Only parse if parser was passed\\n\\n\\n    if (parser) {\\n      val = val != null ? parser(val) : val;\\n    } // We only need to call validate if the user gave us one\\n    // and they want us to validate on change && its not the initial validation\\n\\n\\n    if (validate && validateOnChange && !options.initial) {\\n      logger(\"Validating after change \".concat(field, \" \").concat(val));\\n      setError(validate(val, formApi.getValues()));\\n    } // Now we update the value\\n\\n\\n    setVal(val);\\n    setMaskedValue(maskedVal); // If the user passed in onValueChange then call it!\\n\\n    if (onValueChange) {\\n      onValueChange(val);\\n    } // Call the updater\\n\\n\\n    updater.setValue(fieldId, val, !options.preventUpdate);\\n  }; // ---- Define set touched ----\\n\\n\\n  var setTouched = function setTouched(val, reset) {\\n    var _ref6 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\\n        preventUpdate = _ref6.preventUpdate;\\n\\n    logger(\"Field \".concat(field, \" has been touched\")); // We only need to call validate if the user gave us one\\n    // and they want us to validate on blur\\n\\n    if (validate && validateOnBlur && !reset && val) {\\n      logger(\"Validating after blur \".concat(field, \" \").concat(getVal()));\\n      setError(validate(getVal(), formApi.getValues()));\\n    } // Same for async\\n\\n\\n    if (asyncValidate && asyncValidateOnBlur && !reset && val) {\\n      logger(\"Validating async after blur \".concat(field, \" \").concat(getVal()));\\n      asyncValidate(getVal(), formApi.getValues());\\n    } // Call mask if it was passed\\n\\n\\n    if (mask && maskOnBlur) {\\n      // Generate the masked value from the current value\\n      var maskedVal = mask(getVal()); // Now we update the value\\n\\n      setVal(maskedVal);\\n      setMaskedValue(maskedVal); // If the user passed in onValueChange then call it!\\n\\n      if (onValueChange) {\\n        onValueChange(maskedVal);\\n      } // Call the updater\\n\\n\\n      updater.setValue(fieldId, maskedVal, !preventUpdate);\\n    } // Call maskWithCursorOffset if it was passed\\n\\n\\n    if (maskWithCursorOffset && maskOnBlur) {\\n      // Generate the mask and offset\\n      var res = maskWithCursorOffset(getVal()); // Set the offset\\n\\n      setCursorOffset(res.offset); // Now we update the value\\n\\n      setVal(res.value);\\n      setMaskedValue(res.value); // If the user passed in onValueChange then call it!\\n\\n      if (onValueChange) {\\n        onValueChange(res.value);\\n      } // Call the updater\\n\\n\\n      updater.setValue(fieldId, res.value, !preventUpdate);\\n    } // Finally we set touched and call the updater\\n\\n\\n    setTouch(val);\\n    updater.setTouched(fieldId, val, !preventUpdate);\\n  }; // ---- Define reset ----\\n\\n\\n  var reset = function reset() {\\n    var _ref7 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\\n        preventUpdate = _ref7.preventUpdate;\\n\\n    var initVal = initializeValue(initialValueRef.current || updater.getInitialValue(fieldRef.current), mask, formatter, parser); // TODO support numbers\\n\\n    setValue(initVal, null, {\\n      initial: true,\\n      preventUpdate: preventUpdate\\n    }); // Setting somthing to undefined will remove it\\n\\n    setError(validateOnMount ? validate(initVal) : undefined, {\\n      preventUpdate: preventUpdate\\n    });\\n    setTouched(undefined, true, {\\n      preventUpdate: preventUpdate\\n    });\\n  }; // ---- Define validate ----\\n  // Note: it takes values as an optimization for when\\n  // the form controller calls it ( dont need to generate all values )\\n  // over and over :)\\n\\n\\n  var fieldValidate = function fieldValidate(values) {\\n    if (validate) {\\n      logger(\"Field validating \".concat(field, \" \").concat(getVal()));\\n      setError(validate(getVal(), values || formApi.getValues()));\\n    }\\n  };\\n\\n  var fieldAsyncValidate = function fieldAsyncValidate(values) {\\n    if (asyncValidate) {\\n      logger(\"Field async validating \".concat(field, \" \").concat(getVal()));\\n      asyncValidate(getVal(), values || formApi.getValues());\\n    }\\n  };\\n  /* ----------------- Field Api && State ----------------- */\\n  // Build the field api\\n\\n\\n  var fieldApi = {\\n    setValue: setValue,\\n    setTouched: setTouched,\\n    setError: setError,\\n    reset: reset,\\n    validate: fieldValidate,\\n    asyncValidate: fieldAsyncValidate,\\n    getValue: getVal,\\n    getTouched: getTouch,\\n    getError: getErr,\\n    getIsRelevant: getIsRelevant,\\n    getFieldState: function getFieldState() {\\n      return {\\n        value: getVal(),\\n        touched: getTouch()\\n      };\\n    },\\n    relevant: relevant,\\n    multistepRelevant: multistepRelevant,\\n    checkRelevant: checkRelevant\\n  };\\n  fieldApiRef.current = fieldApi; // Build the field state\\n\\n  var fieldState = {\\n    value: value,\\n    error: error,\\n    touched: touched,\\n    maskedValue: maskedValue,\\n    isRelevant: isRelevant\\n  }; // Create shadow state if this is a shadow field\\n\\n  if (shadow) {\\n    fieldState = {\\n      error: error,\\n      touched: touched\\n    };\\n  }\\n\\n  logger(\\'Render\\', formApi.getFullField(field), fieldState);\\n  var internalRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(null);\\n  var ref = react__WEBPACK_IMPORTED_MODULE_0___default.a.useMemo(function () {\\n    return userRef || internalRef;\\n  }, []); // We want to register and deregister this field\\n\\n  useIsomorphicLayoutEffect(function () {\\n    var fullField = formApi.getFullField(fieldRef.current);\\n    logger(\\'Register\\', fieldId, fieldRef.current);\\n    fieldObjectRef.current = {\\n      field: fullField,\\n      fieldId: fieldId,\\n      fieldApi: fieldApi,\\n      fieldState: fieldState,\\n      notify: notify,\\n      keepState: keepState,\\n      inMultistep: inMultistep,\\n      shadow: shadow\\n    };\\n    updater.register(fieldId, fieldObjectRef.current);\\n    return function () {\\n      var fullField = formApi.getFullField(fieldRef.current);\\n      logger(\\'Deregister\\', fieldId, fullField);\\n      updater.deregister(fieldId);\\n    };\\n  }, []); // We want to let the controller know of changes on this field when specific props change\\n\\n  Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"])(function () {\\n    var fullField = formApi.getFullField(field);\\n\\n    if (initialRenerRef.current) {\\n      initialRenerRef.current = false;\\n    } else {\\n      logger(\\'Update\\', field, inMultistep);\\n      fieldObjectRef.current.field = fullField;\\n      updater.update(fieldId, fieldObjectRef.current, prevFieldRef.current);\\n    }\\n\\n    return function () {\\n      prevFieldRef.current = fullField;\\n    };\\n  }, [field]); // Maintain cursor position\\n\\n  useIsomorphicLayoutEffect(function () {\\n    if (maintainCursor && ref.current != null && getCursor()) ref.current.selectionEnd = getCursor() + getCursorOffset();\\n  }, [value]); // for debugging\\n\\n  useIsomorphicLayoutEffect(function () {\\n    if (debug && ref) {\\n      ref.current.style.border = \\'5px solid orange\\';\\n      setTimeout(function () {\\n        ref.current.style.borderWidth = \\'2px\\';\\n        ref.current.style.borderStyle = \\'inset\\';\\n        ref.current.style.borderColor = \\'initial\\';\\n        ref.current.style.borderImage = \\'initial\\';\\n      }, 500);\\n    }\\n  }); // This is an awesome optimization!!\\n\\n  var shouldUpdate = [].concat(_toConsumableArray(Object.values(fieldState)), _toConsumableArray(Object.values(fieldProps)), _toConsumableArray(Object.values(userProps)));\\n\\n  var render = function render(children) {\\n    return Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useMemo\"])(function () {\\n      return isRelevant ? children : null;\\n    }, _toConsumableArray(shouldUpdate));\\n  }; // Build some setub fields so users can easily intagrate without any hookup code\\n\\n\\n  var name = field;\\n  var changeHandler = generateOnChange({\\n    fieldType: fieldType,\\n    setValue: setValue,\\n    onChange: onChange,\\n    multiple: multiple,\\n    ref: ref\\n  });\\n  var blurHandler = generateOnBlur({\\n    setTouched: setTouched,\\n    onBlur: onBlur\\n  });\\n  var hookedValue = generateValue({\\n    fieldType: fieldType,\\n    maskedValue: maskedValue,\\n    multiple: multiple,\\n    value: value\\n  });\\n  var type = generateFieldType(fieldType);\\n  return {\\n    fieldState: fieldState,\\n    fieldApi: fieldApi,\\n    render: render,\\n    ref: ref,\\n    userProps: _objectSpread2(_objectSpread2({}, userProps), {}, {\\n      multiple: multiple,\\n      // WE NEED TO PUT THESE BACK!!\\n      onChange: onChange,\\n      // WE NEED TO PUT THESE BACK!!\\n      onBlur: onBlur,\\n      // WE NEED TO PUT THESE BACK!!\\n      // required // WE NEED TO PUT THESE BACK!!\\n      id: userProps.id || fieldId // If user did not pass id we pass fields id\\n\\n    }),\\n    informed: _objectSpread2({\\n      name: name,\\n      multiple: multiple,\\n      onChange: changeHandler,\\n      onBlur: blurHandler,\\n      value: hookedValue,\\n      ref: ref,\\n      type: type,\\n      id: userProps.id || fieldId\\n    }, userProps)\\n  };\\n}\\n\\nvar asField = function asField(Component) {\\n  var forwardRef = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.forwardRef(function (props, userRef) {\\n    var _useField = useField(props, userRef),\\n        fieldState = _useField.fieldState,\\n        fieldApi = _useField.fieldApi,\\n        render = _useField.render,\\n        ref = _useField.ref,\\n        userProps = _useField.userProps;\\n\\n    return render( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(Component, _extends({\\n      fieldApi: fieldApi,\\n      fieldState: fieldState,\\n      field: props.field,\\n      forwardedRef: ref,\\n      debug: props.debug,\\n      type: props.type\\n    }, userProps)));\\n  });\\n  forwardRef.displayName = \"asField(\".concat(getChildDisplayName(Component), \")\");\\n  return forwardRef;\\n};\\n\\nvar logger$1 = debug(\\'informed:Text\\' + \\'\\\\t\\');\\n\\nvar Text = function Text(_ref) {\\n  var fieldApi = _ref.fieldApi,\\n      fieldState = _ref.fieldState,\\n      props = _objectWithoutProperties(_ref, [\"fieldApi\", \"fieldState\"]);\\n\\n  var maskedValue = fieldState.maskedValue;\\n  var setValue = fieldApi.setValue,\\n      setTouched = fieldApi.setTouched;\\n\\n  var _onChange = props.onChange,\\n      _onBlur = props.onBlur,\\n      field = props.field,\\n      initialValue = props.initialValue,\\n      forwardedRef = props.forwardedRef,\\n      debug = props.debug,\\n      label = props.label,\\n      title = props.title,\\n      id = props.id,\\n      rest = _objectWithoutProperties(props, [\"onChange\", \"onBlur\", \"field\", \"initialValue\", \"forwardedRef\", \"debug\", \"label\", \"title\", \"id\"]);\\n\\n  logger$1(\\'Render\\', field); // for debugging\\n\\n  useIsomorphicLayoutEffect(function () {\\n    if (debug && forwardedRef) {\\n      forwardedRef.current.style.background = \\'red\\';\\n      setTimeout(function () {\\n        forwardedRef.current.style.background = \\'white\\';\\n      }, 500);\\n    }\\n  });\\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react__WEBPACK_IMPORTED_MODULE_0___default.a.Fragment, null, label ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"label\", {\\n    htmlFor: id\\n  }, \" \", label, \" \") : null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"input\", _extends({}, rest, {\\n    id: id,\\n    name: field,\\n    ref: forwardedRef,\\n    value: !maskedValue && maskedValue !== 0 ? \\'\\' : maskedValue,\\n    onChange: function onChange(e) {\\n      setValue(e.target.value, e);\\n\\n      if (_onChange) {\\n        _onChange(e);\\n      }\\n    },\\n    onBlur: function onBlur(e) {\\n      setTouched(true);\\n\\n      if (_onBlur) {\\n        _onBlur(e);\\n      }\\n    }\\n  })));\\n};\\nvar Text$1 = asField(Text);\\n\\nvar TextArea = function TextArea(_ref) {\\n  var fieldApi = _ref.fieldApi,\\n      fieldState = _ref.fieldState,\\n      props = _objectWithoutProperties(_ref, [\"fieldApi\", \"fieldState\"]);\\n\\n  var maskedValue = fieldState.maskedValue;\\n  var setValue = fieldApi.setValue,\\n      setTouched = fieldApi.setTouched;\\n\\n  var _onChange = props.onChange,\\n      _onBlur = props.onBlur,\\n      field = props.field,\\n      initialValue = props.initialValue,\\n      forwardedRef = props.forwardedRef,\\n      debug = props.debug,\\n      label = props.label,\\n      id = props.id,\\n      rest = _objectWithoutProperties(props, [\"onChange\", \"onBlur\", \"field\", \"initialValue\", \"forwardedRef\", \"debug\", \"label\", \"id\"]); // for debugging\\n\\n\\n  useIsomorphicLayoutEffect(function () {\\n    if (debug && forwardedRef) {\\n      forwardedRef.current.style.background = \\'red\\';\\n      setTimeout(function () {\\n        forwardedRef.current.style.background = \\'white\\';\\n      }, 500);\\n    }\\n  });\\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react__WEBPACK_IMPORTED_MODULE_0___default.a.Fragment, null, label ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"label\", {\\n    htmlFor: id\\n  }, \" \", label, \" \") : null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"textarea\", _extends({}, rest, {\\n    id: id,\\n    name: field,\\n    ref: forwardedRef,\\n    value: !maskedValue ? \\'\\' : maskedValue,\\n    onChange: function onChange(e) {\\n      setValue(e.target.value, e);\\n\\n      if (_onChange) {\\n        _onChange(e);\\n      }\\n    },\\n    onBlur: function onBlur(e) {\\n      setTouched(true);\\n\\n      if (_onBlur) {\\n        _onBlur(e);\\n      }\\n    }\\n  })));\\n};\\nvar TextArea$1 = asField(TextArea);\\n\\nvar logger$2 = debug(\\'informed:Select\\' + \\'\\\\t\\');\\n\\nvar Select = function Select(_ref) {\\n  var fieldApi = _ref.fieldApi,\\n      fieldState = _ref.fieldState,\\n      props = _objectWithoutProperties(_ref, [\"fieldApi\", \"fieldState\"]);\\n\\n  var value = fieldState.value;\\n  var setTouched = fieldApi.setTouched;\\n\\n  var onChange = props.onChange,\\n      _onBlur = props.onBlur,\\n      field = props.field,\\n      initialValue = props.initialValue,\\n      options = props.options,\\n      children = props.children,\\n      forwardedRef = props.forwardedRef,\\n      debug = props.debug,\\n      multiple = props.multiple,\\n      label = props.label,\\n      id = props.id,\\n      rest = _objectWithoutProperties(props, [\"onChange\", \"onBlur\", \"field\", \"initialValue\", \"options\", \"children\", \"forwardedRef\", \"debug\", \"multiple\", \"label\", \"id\"]);\\n\\n  var selectRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])();\\n\\n  var handleChange = function handleChange(e) {\\n    var selected = Array.from((forwardedRef || selectRef).current).filter(function (option) {\\n      return option.selected;\\n    }).map(function (option) {\\n      return option.value;\\n    });\\n    fieldApi.setValue(multiple ? selected : selected[0] || \\'\\');\\n\\n    if (onChange && e) {\\n      onChange(e);\\n    }\\n  }; // for debugging\\n\\n\\n  useIsomorphicLayoutEffect(function () {\\n    if (debug && forwardedRef) {\\n      forwardedRef.current.style.background = \\'red\\';\\n      setTimeout(function () {\\n        forwardedRef.current.style.background = \\'white\\';\\n      }, 500);\\n    }\\n  });\\n  logger$2(\\'Render\\', field, value);\\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react__WEBPACK_IMPORTED_MODULE_0___default.a.Fragment, null, label ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"label\", {\\n    htmlFor: id\\n  }, \" \", label, \" \") : null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"select\", _extends({}, rest, {\\n    id: id,\\n    multiple: multiple,\\n    name: field,\\n    ref: forwardedRef || selectRef,\\n    value: value || (multiple ? [] : \\'\\'),\\n    onChange: handleChange,\\n    onBlur: function onBlur(e) {\\n      setTouched(true);\\n\\n      if (_onBlur) {\\n        _onBlur(e);\\n      }\\n    }\\n  }), options ? options.map(function (option) {\\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"option\", {\\n      key: option.value,\\n      value: option.value,\\n      disabled: option.disabled\\n    }, option.label);\\n  }) : children));\\n};\\nvar Select$1 = asField(Select);\\n\\nvar Checkbox = function Checkbox(_ref) {\\n  var fieldApi = _ref.fieldApi,\\n      fieldState = _ref.fieldState,\\n      props = _objectWithoutProperties(_ref, [\"fieldApi\", \"fieldState\"]);\\n\\n  var value = fieldState.value;\\n  var setValue = fieldApi.setValue,\\n      setTouched = fieldApi.setTouched;\\n\\n  var _onChange = props.onChange,\\n      _onBlur = props.onBlur,\\n      field = props.field,\\n      initialValue = props.initialValue,\\n      debug = props.debug,\\n      forwardedRef = props.forwardedRef,\\n      id = props.id,\\n      label = props.label,\\n      rest = _objectWithoutProperties(props, [\"onChange\", \"onBlur\", \"field\", \"initialValue\", \"debug\", \"forwardedRef\", \"id\", \"label\"]);\\n\\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react__WEBPACK_IMPORTED_MODULE_0___default.a.Fragment, null, label ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"label\", {\\n    htmlFor: id\\n  }, \" \", label, \" \") : null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"input\", _extends({}, rest, {\\n    id: id,\\n    name: field,\\n    ref: forwardedRef,\\n    checked: !!value,\\n    onChange: function onChange(e) {\\n      setValue(e.target.checked);\\n\\n      if (_onChange) {\\n        _onChange(e);\\n      }\\n    },\\n    onBlur: function onBlur(e) {\\n      setTouched(true);\\n\\n      if (_onBlur) {\\n        _onBlur(e);\\n      }\\n    },\\n    type: \"checkbox\"\\n  })));\\n};\\nvar Checkbox$1 = asField(Checkbox);\\n\\nvar withRadioGroup = function withRadioGroup(Component) {\\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.forwardRef(function (props, ref) {\\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(GroupContext.Consumer, null, function (_ref) {\\n      var radioGroupApi = _ref.radioGroupApi,\\n          radioGroupState = _ref.radioGroupState;\\n      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(Component, _extends({\\n        radioGroupApi: radioGroupApi,\\n        radioGroupState: radioGroupState,\\n        ref: ref\\n      }, props));\\n    });\\n  });\\n};\\n\\nvar Radio = function Radio(_ref) {\\n  var radioGroupApi = _ref.radioGroupApi,\\n      radioGroupState = _ref.radioGroupState,\\n      props = _objectWithoutProperties(_ref, [\"radioGroupApi\", \"radioGroupState\"]);\\n\\n  var groupValue = radioGroupState.value;\\n  var setValue = radioGroupApi.setValue,\\n      setTouched = radioGroupApi.setTouched,\\n      groupOnChange = radioGroupApi.onChange,\\n      groupOnBlur = radioGroupApi.onBlur;\\n\\n  var value = props.value,\\n      _onChange = props.onChange,\\n      _onBlur = props.onBlur,\\n      field = props.field,\\n      initialValue = props.initialValue,\\n      forwardedRef = props.forwardedRef,\\n      rest = _objectWithoutProperties(props, [\"value\", \"onChange\", \"onBlur\", \"field\", \"initialValue\", \"forwardedRef\"]);\\n\\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"input\", _extends({}, rest, {\\n    name: field,\\n    ref: forwardedRef,\\n    value: value,\\n    checked: groupValue === value,\\n    onChange: function onChange(e) {\\n      if (!e.target.checked) {\\n        return;\\n      }\\n\\n      setValue(value);\\n\\n      if (_onChange) {\\n        _onChange(e);\\n      }\\n\\n      if (groupOnChange) {\\n        groupOnChange(e);\\n      }\\n    },\\n    onBlur: function onBlur(e) {\\n      setTouched(true);\\n\\n      if (_onBlur) {\\n        _onBlur(e);\\n      }\\n\\n      if (groupOnBlur) {\\n        groupOnBlur(e);\\n      }\\n    },\\n    type: \"radio\"\\n  }));\\n};\\nvar Radio$1 = withRadioGroup(Radio);\\n\\nvar RadioGroup = /*#__PURE__*/function (_Component) {\\n  _inherits(RadioGroup, _Component);\\n\\n  var _super = _createSuper(RadioGroup);\\n\\n  function RadioGroup() {\\n    _classCallCheck(this, RadioGroup);\\n\\n    return _super.apply(this, arguments);\\n  }\\n\\n  _createClass(RadioGroup, [{\\n    key: \"render\",\\n    value: function render() {\\n      var _this$props = this.props,\\n          options = _this$props.options,\\n          children = _this$props.children;\\n      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(GroupContext.Provider, {\\n        value: this.groupContext\\n      }, options ? options.map(function (option) {\\n        return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"label\", {\\n          key: option.value\\n        }, option.label, \" \", /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(Radio$1, {\\n          value: option.value\\n        }));\\n      }) : children);\\n    }\\n  }, {\\n    key: \"groupContext\",\\n    get: function get() {\\n      return {\\n        radioGroupApi: _objectSpread2(_objectSpread2({}, this.props.fieldApi), {}, {\\n          onChange: this.props.onChange,\\n          onBlur: this.props.onBlur\\n        }),\\n        radioGroupState: this.props.fieldState\\n      };\\n    }\\n  }]);\\n\\n  return RadioGroup;\\n}(react__WEBPACK_IMPORTED_MODULE_0__[\"Component\"]);\\nvar RadioGroup$1 = asField(RadioGroup);\\n\\nfunction useArrayFieldApi() {\\n  return Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useContext\"])(ArrayFieldApiContext);\\n}\\n\\nvar AddButton = function AddButton() {\\n  var _useArrayFieldApi = useArrayFieldApi(),\\n      add = _useArrayFieldApi.add;\\n\\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"button\", {\\n    onClick: function onClick() {\\n      add();\\n    },\\n    type: \"button\"\\n  }, \"Add\");\\n};\\n\\nfunction useArrayFieldItemApi() {\\n  return Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useContext\"])(ArrayFieldItemApiContext);\\n}\\n\\nvar AddButton$1 = function AddButton() {\\n  var _useArrayFieldItemApi = useArrayFieldItemApi(),\\n      remove = _useArrayFieldItemApi.remove;\\n\\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"button\", {\\n    onClick: function onClick() {\\n      remove();\\n    },\\n    type: \"button\"\\n  }, \"Remove\");\\n};\\n\\nvar logger$3 = debug(\\'informed:useArrayField\\' + \\'\\\\t\\');\\n\\nvar useArrayField = function useArrayField(_ref) {\\n  var field = _ref.field,\\n      initialValue = _ref.initialValue,\\n      validate = _ref.validate,\\n      arrayFieldApiRef = _ref.arrayFieldApiRef,\\n      props = _objectWithoutProperties(_ref, [\"field\", \"initialValue\", \"validate\", \"arrayFieldApiRef\"]);\\n\\n  // Reference to the form Api\\n  var formApi = useFormApi(); // Keep track of fields that belong to this array field\\n\\n  var _useState = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useState\"])(new Map()),\\n      _useState2 = _slicedToArray(_useState, 1),\\n      fieldsById = _useState2[0]; // Grab the form register context\\n\\n\\n  var updater = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useContext\"])(FormRegisterContext); // May be scoped so get full field name!!\\n\\n  var fullField = formApi.getFullField(field);\\n  var initialVals = updater.getInitialValue(field) || initialValue || []; // TODO throw error if initial value and its not array\\n  // If keep state was passed into the child inputs we need to maintain the length of\\n  // keys, in order to do so we grab the value from informeds api\\n\\n  var keptValues = formApi.getSavedValue(fullField) && formApi.getSavedValue(fullField).value;\\n\\n  var _useStateWithGetter = useStateWithGetter(keptValues || initialVals),\\n      _useStateWithGetter2 = _slicedToArray(_useStateWithGetter, 3),\\n      initialValues = _useStateWithGetter2[0],\\n      setInitialValues = _useStateWithGetter2[1],\\n      getInitialValues = _useStateWithGetter2[2];\\n\\n  var initialKeys = initialValues ? initialValues.map(function () {\\n    return uuidv4();\\n  }) : [];\\n\\n  var _useStateWithGetter3 = useStateWithGetter(initialKeys),\\n      _useStateWithGetter4 = _slicedToArray(_useStateWithGetter3, 3),\\n      keys = _useStateWithGetter4[0],\\n      setKeys = _useStateWithGetter4[1],\\n      getKeys = _useStateWithGetter4[2];\\n\\n  var validateWithLength = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useMemo\"])(function () {\\n    return function (value, values) {\\n      var length = getKeys() == null ? 0 : getKeys().length;\\n      return validate ? validate(value, length, values) : undefined;\\n    };\\n  }); // Register shadow field\\n\\n  var _useField = useField(_objectSpread2({\\n    field: field,\\n    validate: validate ? validateWithLength : undefined,\\n    shadow: true\\n  }, props)),\\n      fieldApi = _useField.fieldApi; // Register for events\\n\\n\\n  useIsomorphicLayoutEffect(function () {\\n    // Define event handler\\n    var onChangeHandler = function onChangeHandler(fieldName) {\\n      // Dont do anythign if we updated\\n      if (fieldName === fullField) {\\n        return;\\n      }\\n\\n      logger$3(\"\".concat(fullField, \" changed\")); // determine if one of our array children triggered this change\\n\\n      if (RegExp(\"\".concat(fullField, \"\\\\\\\\[[0-9]+\\\\\\\\]\")).test(fieldName)) {\\n        // If it was we need to call validate\\n        fieldApi.validate();\\n      }\\n    }; // Register for events\\n\\n\\n    formApi.emitter.on(\\'value\\', onChangeHandler); // Unregister events\\n\\n    return function () {\\n      formApi.emitter.removeListener(\\'value\\', onChangeHandler);\\n    };\\n  }, [field]);\\n\\n  var _remove = function remove(i) {\\n    // Notify form to expect removal on this field\\n    logger$3(\\'EXPECTING REMOVAL OF\\', \"\".concat(field, \"[\").concat(i, \"] and \").concat(field, \"[\").concat(keys.length - 1, \"]\"));\\n    updater.expectRemoval(\"\".concat(field, \"[\").concat(i, \"]\"));\\n    updater.expectRemoval(\"\".concat(field, \"[\").concat(keys.length - 1, \"]\")); // Remove the key\\n\\n    var newKeys = keys.slice(0, i).concat(keys.slice(i + 1, keys.length));\\n    setKeys(newKeys); // Remove the initial value ( user wanted to get rid of that input )\\n\\n    var initVals = getInitialValues();\\n    var newInitialValues = initVals.slice(0, i).concat(initVals.slice(i + 1, initVals.length));\\n    setInitialValues(newInitialValues); //formApi.setInitialValue(field, newInitialValues);\\n  };\\n\\n  var swap = function swap(a, b) {\\n    logger$3(\\'Swapping\\', \"\".concat(field, \"[\").concat(a, \"] and \").concat(field, \"[\").concat(b, \"]\")); // Swap the keys\\n\\n    var newKeys = _toConsumableArray(keys);\\n\\n    if (keys[a] && keys[b]) {\\n      newKeys[a] = keys[b];\\n      newKeys[b] = keys[a];\\n    } else {\\n      // eslint-disable-next-line no-console\\n      console.warn(\"Attempted to swap \".concat(a, \" with \").concat(b, \" but one of them does not exist :(\"));\\n    }\\n\\n    setKeys(newKeys);\\n  };\\n\\n  var add = function add() {\\n    keys.push(uuidv4());\\n    setKeys(_toConsumableArray(keys));\\n  };\\n\\n  var addWithInitialValue = function addWithInitialValue(initialValue) {\\n    keys.push(uuidv4());\\n    setKeys(_toConsumableArray(keys));\\n\\n    var newInitialValues = _toConsumableArray(getInitialValues());\\n\\n    newInitialValues[keys.length - 1] = initialValue;\\n    setInitialValues(newInitialValues);\\n  };\\n\\n  var reset = function reset() {\\n    // When resetting we reset to the users initial value not the one tracked by this hook\\n    var initVals = updater.getInitialValue(field) || initialValue || []; // Set our initial values back to what the user set at beginning\\n\\n    setInitialValues(initVals); // Build a new set of keys because everything is new !!!\\n\\n    var resetKeys = initVals ? initVals.map(function () {\\n      return uuidv4();\\n    }) : []; // Finally set that shit !\\n\\n    setKeys(resetKeys);\\n  };\\n\\n  var fields = keys.map(function (key, i) {\\n    var arrayFieldItemApi = {\\n      remove: function remove() {\\n        return _remove(i);\\n      }\\n    };\\n    var arrayFieldItemState = {\\n      initialValue: initialValues && initialValues[i],\\n      key: key,\\n      field: \"\".concat(field, \"[\").concat(i, \"]\"),\\n      index: i\\n    };\\n    return _objectSpread2(_objectSpread2({\\n      arrayFieldItemApi: arrayFieldItemApi,\\n      arrayFieldItemState: arrayFieldItemState\\n    }, arrayFieldItemApi), arrayFieldItemState);\\n  });\\n  var arrayFieldApi = {\\n    add: add,\\n    swap: swap,\\n    addWithInitialValue: addWithInitialValue,\\n    reset: reset\\n  };\\n\\n  if (arrayFieldApiRef) {\\n    arrayFieldApiRef.current = arrayFieldApi;\\n  }\\n\\n  var arrayFieldState = {\\n    fields: fields,\\n    field: field\\n  }; // Wrap the updater to update array fields references\\n\\n  var wrappedUpdator = _objectSpread2(_objectSpread2({}, updater), {}, {\\n    register: function register(id, fld) {\\n      fieldsById.set(id, fld);\\n\\n      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\\n        args[_key - 2] = arguments[_key];\\n      }\\n\\n      updater.register.apply(updater, [id, fld].concat(args));\\n    },\\n    deregister: function deregister(id) {\\n      fieldsById[\"delete\"](id);\\n\\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\\n        args[_key2 - 1] = arguments[_key2];\\n      }\\n\\n      updater.deregister.apply(updater, [id].concat(args));\\n    },\\n    getInitialValue: function getInitialValue(fieldName) {\\n      // If we are getting initial value and its for this field return that\\n      if (RegExp(\"\".concat(fullField, \"\\\\\\\\[[0-9]+\\\\\\\\]\")).test(fieldName)) {\\n        var path = fieldName.replace(field, \\'\\');\\n        var v = ObjectMap.get(getInitialValues(), path);\\n        logger$3(\"Resetting \".concat(path, \" to \").concat(v));\\n        return v;\\n      }\\n\\n      return updater.getInitialValue(fieldName);\\n    }\\n  });\\n\\n  var render = function render(children) {\\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(FormRegisterContext.Provider, {\\n      value: wrappedUpdator\\n    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(ArrayFieldApiContext.Provider, {\\n      value: arrayFieldApi\\n    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(ArrayFieldStateContext.Provider, {\\n      value: arrayFieldState\\n    }, children)));\\n  };\\n\\n  return {\\n    render: render,\\n    add: add,\\n    swap: swap,\\n    addWithInitialValue: addWithInitialValue,\\n    fields: fields,\\n    arrayFieldState: arrayFieldState,\\n    arrayFieldApi: arrayFieldApi,\\n    field: field\\n  };\\n};\\n\\nvar buildScopedFormApi = function buildScopedFormApi(scope, formApi) {\\n  return _objectSpread2(_objectSpread2({}, formApi), {}, {\\n    getValue: function getValue(field) {\\n      return formApi.getValue(\"\".concat(scope, \".\").concat(field));\\n    },\\n    getTouched: function getTouched(field) {\\n      return formApi.getTouched(\"\".concat(scope, \".\").concat(field));\\n    },\\n    getError: function getError(field) {\\n      return formApi.getError(\"\".concat(scope, \".\").concat(field));\\n    },\\n    setValue: function setValue(field, value) {\\n      return formApi.setValue(\"\".concat(scope, \".\").concat(field), value);\\n    },\\n    setTouched: function setTouched(field, value) {\\n      return formApi.setTouched(\"\".concat(scope, \".\").concat(field), value);\\n    },\\n    setError: function setError(field, value) {\\n      return formApi.setError(\"\".concat(scope, \".\").concat(field), value);\\n    },\\n    getInitialValue: function getInitialValue(field) {\\n      return formApi.getInitialValue(\"\".concat(scope, \".\").concat(field));\\n    },\\n    getFullField: function getFullField(field) {\\n      return \"\".concat(formApi.getFullField(scope), \".\").concat(field);\\n    }\\n  });\\n};\\n\\nfunction useScopedApi(scope) {\\n  var formApi = useFormApi(); // VERY important to memoize the builder!\\n\\n  var scopedFormApi = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useMemo\"])(function () {\\n    return buildScopedFormApi(scope, formApi);\\n  }, [scope]);\\n  return scopedFormApi;\\n}\\n\\nfunction useFormState() {\\n  var formState = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useContext\"])(FormStateContext);\\n  return formState;\\n}\\n\\nvar Relevant = function Relevant(_ref) {\\n  var when = _ref.when,\\n      children = _ref.children;\\n  var formState = useFormState();\\n  var isRelevant = when(formState);\\n\\n  if (isRelevant) {\\n    return children;\\n  }\\n\\n  return null;\\n};\\n\\nvar ArrayField = function ArrayField(_ref) {\\n  var relevant = _ref.relevant,\\n      field = _ref.field,\\n      props = _objectWithoutProperties(_ref, [\"relevant\", \"field\"]);\\n\\n  // Need to get formApi to have consistant interface for relevant function\\n  var formApi = useFormApi();\\n\\n  if (relevant) {\\n    var ff = formApi.getFullField(field);\\n    var args = {\\n      path: ff,\\n      parentPath: ff.replace(/(.*)[.[].*/, \\'$1\\'),\\n      get: function get(values, path) {\\n        return ObjectMap.get(values, path);\\n      }\\n    };\\n\\n    var when = function when(_ref2) {\\n      var values = _ref2.values;\\n      return relevant(values, args);\\n    };\\n\\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(Relevant, {\\n      when: when\\n    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(ArrayFieldWrapper, _extends({\\n      field: field\\n    }, props)));\\n  } else {\\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(ArrayFieldWrapper, _extends({\\n      field: field\\n    }, props));\\n  }\\n};\\n\\nvar ArrayFieldWrapper = function ArrayFieldWrapper(_ref3) {\\n  var children = _ref3.children,\\n      props = _objectWithoutProperties(_ref3, [\"children\"]);\\n\\n  var _useArrayField = useArrayField(props),\\n      render = _useArrayField.render,\\n      arrayFieldState = _useArrayField.arrayFieldState,\\n      arrayFieldApi = _useArrayField.arrayFieldApi,\\n      field = _useArrayField.field;\\n\\n  if (typeof children === \\'function\\') {\\n    return render(children(_objectSpread2(_objectSpread2({\\n      field: field,\\n      arrayFieldApi: arrayFieldApi,\\n      arrayFieldState: arrayFieldState\\n    }, arrayFieldApi), arrayFieldState)));\\n  }\\n\\n  return render(children);\\n};\\n\\nvar ArrayFieldItem = function ArrayFieldItem(_ref4) {\\n  var arrayFieldItemState = _ref4.arrayFieldItemState,\\n      arrayFieldItemApi = _ref4.arrayFieldItemApi,\\n      children = _ref4.children;\\n  // Grab the form register context\\n  var updater = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useContext\"])(FormRegisterContext); // Grab the form state\\n\\n  var formApi = useFormApi(); // A little trick I learned in nam to trigger rerender\\n\\n  var _useState = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useState\"])(0),\\n      _useState2 = _slicedToArray(_useState, 2),\\n      state = _useState2[0],\\n      setState = _useState2[1]; // Keep track of fields that belong to this array field\\n\\n\\n  var _useState3 = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useState\"])(new Map()),\\n      _useState4 = _slicedToArray(_useState3, 1),\\n      fieldsById = _useState4[0]; // Get this items field\\n\\n\\n  var field = arrayFieldItemState.field; // Create scoped api\\n\\n  var scopedApi = useScopedApi(field); // State generation function\\n\\n  var getState = function getState() {\\n    var _formApi$getState = formApi.getState(),\\n        values = _formApi$getState.values,\\n        errors = _formApi$getState.errors,\\n        touched = _formApi$getState.touched; // Get this fields state\\n\\n\\n    var itemState = {\\n      values: ObjectMap.get(values, field),\\n      errors: ObjectMap.get(errors, field),\\n      touched: ObjectMap.get(touched, field)\\n    };\\n    return itemState;\\n  }; // Register for events for rerenders!\\n\\n\\n  Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"])(function () {\\n    // Define event handler\\n    var onChangeHandler = function onChangeHandler(fieldName) {\\n      // Example foo.bar.baz[3].baz >>>> foo.bar.baz[3]\\n      var magicValue = fieldName.slice(0, fieldName.lastIndexOf(\\'[\\') != -1 ? fieldName.lastIndexOf(\\']\\') + 1 : fieldName.length); // This field updated so trigger rerender\\n\\n      if (magicValue === field) {\\n        setState(Math.random());\\n      }\\n    }; // Register for events\\n\\n\\n    formApi.emitter.on(\\'value\\', onChangeHandler); // Unregister events\\n\\n    return function () {\\n      formApi.emitter.removeListener(\\'value\\', onChangeHandler);\\n    };\\n  }, [field]); // Resets all fields in this item\\n\\n  var reset = function reset() {\\n    fieldsById.forEach(function (fld) {\\n      fld.fieldApi.reset();\\n    });\\n  }; // Generate the item state\\n\\n\\n  var itemState = getState(); // Wrap the updater to update array fields references\\n\\n  var wrappedUpdator = _objectSpread2(_objectSpread2({}, updater), {}, {\\n    register: function register(id, fld, initialRender) {\\n      fieldsById.set(id, fld);\\n      updater.register(id, fld, initialRender);\\n    },\\n    deregister: function deregister(id) {\\n      fieldsById[\"delete\"](id);\\n\\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\\n        args[_key - 1] = arguments[_key];\\n      }\\n\\n      updater.deregister.apply(updater, [id].concat(args));\\n    }\\n  });\\n\\n  var arrayFieldItemApiValue = _objectSpread2(_objectSpread2(_objectSpread2({}, arrayFieldItemApi), scopedApi), {}, {\\n    reset: reset\\n  });\\n\\n  var arrayFieldItemStateValue = _objectSpread2(_objectSpread2({}, arrayFieldItemState), itemState);\\n\\n  if (typeof children === \\'function\\') {\\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(FormRegisterContext.Provider, {\\n      value: wrappedUpdator\\n    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(ArrayFieldItemApiContext.Provider, {\\n      value: arrayFieldItemApiValue\\n    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(ArrayFieldItemStateContext.Provider, {\\n      value: arrayFieldItemStateValue\\n    }, children(_objectSpread2(_objectSpread2({\\n      arrayFieldItemApi: arrayFieldItemApiValue,\\n      arrayFieldItemState: arrayFieldItemStateValue\\n    }, arrayFieldItemApiValue), arrayFieldItemStateValue)))));\\n  }\\n\\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(FormRegisterContext.Provider, {\\n    value: wrappedUpdator\\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(ArrayFieldItemApiContext.Provider, {\\n    value: arrayFieldItemApiValue\\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(ArrayFieldItemStateContext.Provider, {\\n    value: arrayFieldItemStateValue\\n  }, children)));\\n};\\n\\nArrayField.Items = function (_ref5) {\\n  var children = _ref5.children;\\n\\n  var _useContext = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useContext\"])(ArrayFieldStateContext),\\n      fields = _useContext.fields;\\n\\n  return fields.map(function (_ref6) {\\n    var arrayFieldItemState = _ref6.arrayFieldItemState,\\n        arrayFieldItemApi = _ref6.arrayFieldItemApi;\\n    var key = arrayFieldItemState.key;\\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(ArrayFieldItem, {\\n      key: key,\\n      arrayFieldItemApi: arrayFieldItemApi,\\n      arrayFieldItemState: arrayFieldItemState\\n    }, children);\\n  });\\n};\\n\\nvar FormComponents = function FormComponents(_ref) {\\n  var components = _ref.components;\\n\\n  // Get the field map off the forms context\\n  var _useContext = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useContext\"])(FormRegisterContext),\\n      fieldMap = _useContext.fieldMap;\\n\\n  if (!components) return null;\\n  return components.map(function (comp, i) {\\n    var componentType = comp[\\'ui:control\\'];\\n    var Component = fieldMap[componentType];\\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(Component, {\\n      key: \"ui-comp-\".concat(i)\\n    });\\n  });\\n};\\n\\nvar logger$4 = debug(\\'informed:FormFields\\' + \\'\\\\t\\');\\n\\nvar FormFields = function FormFields(_ref) {\\n  var schema = _ref.schema,\\n      prefix = _ref.prefix,\\n      onlyValidateSchema = _ref.onlyValidateSchema;\\n\\n  // Get the field map off the forms context\\n  var _useContext = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useContext\"])(FormRegisterContext),\\n      fieldMap = _useContext.fieldMap; // Get fields from scheama\\n\\n\\n  var fields = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useMemo\"])(function () {\\n    var schemaFields = computeFieldsFromSchema(schema, onlyValidateSchema, prefix);\\n    var mapedFields = schemaFields.map(function (schemaField, i) {\\n      var field = schemaField.field,\\n          props = schemaField.props,\\n          type = schemaField.type,\\n          properties = schemaField.properties,\\n          items = schemaField.items,\\n          componentType = schemaField.componentType,\\n          uiBefore = schemaField.uiBefore,\\n          uiAfter = schemaField.uiAfter,\\n          allOf = schemaField.allOf;\\n      var Component = fieldMap[componentType]; // console.log(\\'WTF\\', schemaField);\\n\\n      logger$4(\\'Rendering Field\\', field, schemaField); // Scope for nested\\n\\n      if (!Component && type === \\'object\\' && properties) {\\n        return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(FormFields, {\\n          schema: schemaField,\\n          prefix: field,\\n          key: \"ScheamField-\".concat(i)\\n        });\\n      } // Array field for array ( if none was provided use our default )\\n\\n\\n      if (!Component && type === \\'array\\' && items) {\\n        return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(ArrayField$1, _extends({\\n          key: \"ScheamField-\".concat(i),\\n          field: field,\\n          items: items,\\n          uiBefore: uiBefore,\\n          uiAfter: uiAfter\\n        }, props));\\n      } // User created custom array field\\n\\n\\n      if (Component && componentType === \\'array\\' && items && type === \\'array\\') {\\n        return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(Component, _extends({\\n          key: \"ScheamField-\".concat(i),\\n          field: field,\\n          items: items,\\n          uiBefore: uiBefore,\\n          uiAfter: uiAfter\\n        }, props));\\n      } // For conditionals\\n\\n\\n      if (componentType === \\'conditionals\\') {\\n        return allOf.map(function (conditional) {\\n          // Example then ( its a subschema )\\n          // then: {\\n          //   properties: {\\n          //     spouse: {\\n          //       type: \\'string\\',\\n          //       title: \\'Spouse name\\',\\n          //       \\'ui:control\\': \\'input\\'\\n          //     }\\n          //   }\\n          // }\\n          var subSchema = conditional.then; // Turn the if into a when function for informed\\n          // Example if condition\\n          // if: {\\n          //   properties: {\\n          //     married: { const: \\'yes\\' }\\n          //   },\\n          //   required: [\\'married\\']\\n          // },\\n\\n          var conditions = conditional[\"if\"].properties;\\n\\n          var when = function when(_ref2) {\\n            var values = _ref2.values;\\n            // Example key \"married, Example condition: \"{ const: \\'yes\\' }\"\\n            return Object.keys(conditions).every(function (key) {\\n              var condition = conditions[key]; // values.married === \\'yes\\'\\n\\n              return values[key] === condition[\"const\"];\\n            });\\n          };\\n\\n          return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(Relevant, {\\n            key: \"ScheamField-\".concat(i),\\n            when: when\\n          }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(FormFields, {\\n            schema: subSchema\\n          }));\\n        });\\n      } // If no com ret null ( dont render )\\n\\n\\n      if (!Component) {\\n        return null;\\n      }\\n\\n      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(Component, _extends({\\n        key: \"ScheamField-\".concat(i),\\n        field: field\\n      }, props));\\n    });\\n    return mapedFields;\\n  }, [schema, prefix]);\\n  return fields;\\n};\\n\\nvar ArrayField$1 = function ArrayField$1(_ref) {\\n  var field = _ref.field,\\n      items = _ref.items,\\n      uiBefore = _ref.uiBefore,\\n      uiAfter = _ref.uiAfter,\\n      props = _objectWithoutProperties(_ref, [\"field\", \"items\", \"uiBefore\", \"uiAfter\"]);\\n\\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(ArrayField, _extends({\\n    field: field\\n  }, props), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(FormComponents, {\\n    components: uiBefore\\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(ArrayField.Items, null, function (_ref2) {\\n    var field = _ref2.field;\\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react__WEBPACK_IMPORTED_MODULE_0___default.a.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(FormComponents, {\\n      components: items[\\'ui:before\\']\\n    }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(FormFields, {\\n      schema: items,\\n      prefix: field\\n    }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(FormComponents, {\\n      components: items[\\'ui:after\\']\\n    }));\\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(FormComponents, {\\n    components: uiAfter\\n  }));\\n};\\n\\nvar defaultFieldMap = {\\n  select: Select$1,\\n  input: Text$1,\\n  textarea: TextArea$1,\\n  checkbox: Checkbox$1,\\n  radio: RadioGroup$1,\\n  add: AddButton,\\n  remove: AddButton$1,\\n  array: ArrayField$1\\n};\\n\\nvar debug$2 = debug(\\'informed:Controller\\' + \\'\\\\t\\');\\n\\nvar isExpected = function isExpected(path, expectedRemovals) {\\n  var includedKey = Object.keys(expectedRemovals).find(function (key) {\\n    return path.includes(key);\\n  });\\n  if (!includedKey) return;\\n  var start = path.slice(0, includedKey.length);\\n  return start === includedKey;\\n};\\n\\nvar noop = function noop() {};\\n\\nvar FormController = /*#__PURE__*/function (_EventEmitter) {\\n  _inherits(FormController, _EventEmitter);\\n\\n  var _super = _createSuper(FormController);\\n\\n  function FormController() {\\n    var _this;\\n\\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n\\n    _classCallCheck(this, FormController);\\n\\n    // Dont forget to call super! :)\\n    _this = _super.call(this);\\n    _this.options = options;\\n    var ajv = options.ajv,\\n        schema = options.schema,\\n        fieldMap = options.fieldMap; // Debounced change\\n    // const change = () => {\\n    //   this.rebuildState();\\n    //   this.emit(\\'change\\');\\n    // };\\n    // this.change = debounce(change, 250);\\n    // Create new ajv instance if passed\\n\\n    _this.ajv = ajv ? new ajv({\\n      allErrors: true\\n    }) : null;\\n    _this.ajvValidate = ajv ? _this.ajv.compile(schema) : null; // Add field map ( defaults to our field map )\\n\\n    _this.fieldMap = fieldMap || defaultFieldMap; // Map will store all fields by id\\n    // Key => uuid\\n    // Val => fieldObj\\n    // Why? so the form can control the fields!\\n\\n    _this.fieldsById = new Map(); // Map will store all fields by name\\n    // Key => fieldName - example: \"foo.bar[3].baz\"\\n    // Val => fieldObj\\n    // Why? so the form can control the fields!\\n\\n    _this.fieldsByName = {\\n      get: function get(name) {\\n        var fieldByName; // TODO speed this up maybe\\n\\n        _this.fieldsById.forEach(function (value) {\\n          if (value && value.field === name) {\\n            fieldByName = value;\\n          }\\n        });\\n\\n        return fieldByName;\\n      }\\n    }; // Map to store whos on the screen\\n\\n    _this.onScreen = {}; // Map to store fields being removed\\n\\n    _this.expectedRemovals = {};\\n    _this.pulledOut = {}; // Map of saved values\\n\\n    _this.savedValues = {}; // Initialize the controller state\\n\\n    _this.state = {\\n      pristine: true,\\n      dirty: false,\\n      invalid: false,\\n      submits: 0,\\n      step: 0,\\n      validating: 0,\\n      submitting: false,\\n      values: {},\\n      errors: {},\\n      touched: {}\\n    }; // Initialize a dummy field ( see getField for example use )\\n\\n    _this.dummyField = {\\n      fieldApi: {\\n        setValue: noop,\\n        setTouched: noop,\\n        setError: noop,\\n        reset: noop,\\n        validate: noop,\\n        getValue: noop,\\n        getTouched: noop,\\n        getError: noop,\\n        getFieldState: noop,\\n        checkRelevant: noop\\n      }\\n    }; // Bind functions that will be called externally\\n\\n    _this.deregister = _this.deregister.bind(_assertThisInitialized(_this));\\n    _this.register = _this.register.bind(_assertThisInitialized(_this));\\n    _this.getValue = _this.getValue.bind(_assertThisInitialized(_this));\\n    _this.getTouched = _this.getTouched.bind(_assertThisInitialized(_this));\\n    _this.getError = _this.getError.bind(_assertThisInitialized(_this));\\n    _this.getErrors = _this.getErrors.bind(_assertThisInitialized(_this));\\n    _this.setValue = _this.setValue.bind(_assertThisInitialized(_this));\\n    _this.getValues = _this.getValues.bind(_assertThisInitialized(_this));\\n    _this.getStep = _this.getStep.bind(_assertThisInitialized(_this));\\n    _this.setStep = _this.setStep.bind(_assertThisInitialized(_this));\\n    _this.back = _this.back.bind(_assertThisInitialized(_this));\\n    _this.next = _this.next.bind(_assertThisInitialized(_this));\\n    _this.setCurrent = _this.setCurrent.bind(_assertThisInitialized(_this));\\n    _this.setTouched = _this.setTouched.bind(_assertThisInitialized(_this));\\n    _this.setError = _this.setError.bind(_assertThisInitialized(_this));\\n    _this.setFormError = _this.setFormError.bind(_assertThisInitialized(_this));\\n    _this.submitForm = _this.submitForm.bind(_assertThisInitialized(_this));\\n    _this.reset = _this.reset.bind(_assertThisInitialized(_this));\\n    _this.update = _this.update.bind(_assertThisInitialized(_this));\\n    _this.validate = _this.validate.bind(_assertThisInitialized(_this));\\n    _this.screenValid = _this.screenValid.bind(_assertThisInitialized(_this));\\n    _this.keyDown = _this.keyDown.bind(_assertThisInitialized(_this));\\n    _this.getField = _this.getField.bind(_assertThisInitialized(_this));\\n    _this.getInitialValue = _this.getInitialValue.bind(_assertThisInitialized(_this));\\n    _this.setInitialValue = _this.setInitialValue.bind(_assertThisInitialized(_this));\\n    _this.getOptions = _this.getOptions.bind(_assertThisInitialized(_this));\\n    _this.getFormState = _this.getFormState.bind(_assertThisInitialized(_this));\\n    _this.expectRemoval = _this.expectRemoval.bind(_assertThisInitialized(_this));\\n    _this.getSavedValue = _this.getSavedValue.bind(_assertThisInitialized(_this));\\n    _this.removeSavedState = _this.removeSavedState.bind(_assertThisInitialized(_this));\\n    _this.getDerrivedValue = _this.getDerrivedValue.bind(_assertThisInitialized(_this));\\n    _this.setValues = _this.setValues.bind(_assertThisInitialized(_this));\\n    _this.resetField = _this.resetField.bind(_assertThisInitialized(_this));\\n    _this.fieldExists = _this.fieldExists.bind(_assertThisInitialized(_this));\\n    _this.validateField = _this.validateField.bind(_assertThisInitialized(_this));\\n    _this.notify = _this.notify.bind(_assertThisInitialized(_this));\\n    _this.validating = _this.validating.bind(_assertThisInitialized(_this));\\n    _this.validated = _this.validated.bind(_assertThisInitialized(_this)); // this.change = this.change.bind(this);\\n    // this.clear = this.clear.bind(this);\\n    // Updater will be used by fields to update and register\\n\\n    _this.updater = {\\n      register: _this.register,\\n      deregister: _this.deregister,\\n      getField: _this.getField,\\n      update: _this.update,\\n      // clear: this.clear,\\n      fieldMap: _this.fieldMap,\\n      setValue: function setValue(fieldId, value) {\\n        var emit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\\n\\n        var field = _this.fieldsById.get(fieldId);\\n\\n        if (!field.shadow) {\\n          ObjectMap.set(_this.state.values, field.field, field.fieldApi.getValue());\\n        }\\n\\n        if (!field.fieldApi.relevant(_this.state.values)) {\\n          ObjectMap[\"delete\"](_this.state.values, field.field);\\n        } // Cleanup phase to get rid of irrelevant fields\\n        // Also evaluate relevance on all fields\\n\\n\\n        _this.fieldsById.forEach(function (f) {\\n          // If a fields within an irrelivant step then remove it\\n          // Otherwise, check to see if its relevant and only remove if keep state is false\\n          var newRel = f.fieldApi.checkRelevant();\\n\\n          if (!f.fieldApi.multistepRelevant(_this.state.values) || !newRel && !f.keepState) {\\n            ObjectMap[\"delete\"](_this.state.values, f.field);\\n            ObjectMap[\"delete\"](_this.state.touched, f.field);\\n            ObjectMap[\"delete\"](_this.state.errors, f.field);\\n          }\\n        });\\n\\n        if (emit) {\\n          _this.emit(\\'change\\');\\n\\n          _this.emit(\\'value\\', field.field, value);\\n        }\\n      },\\n      setTouched: function setTouched(fieldId, touch) {\\n        var emit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\\n\\n        var field = _this.fieldsById.get(fieldId);\\n\\n        if (!field.shadow && field.fieldApi.getIsRelevant()) {\\n          ObjectMap.set(_this.state.touched, field.field, field.fieldApi.getTouched());\\n        } // Shadow values override unless undefined\\n\\n\\n        if (field.shadow && field.fieldApi.getError() != undefined && field.fieldApi.relevant(_this.state.values)) {\\n          ObjectMap.set(_this.state.touched, field.field, field.fieldApi.getTouched());\\n        }\\n\\n        if (emit) {\\n          _this.emit(\\'change\\'); //this.emit(\\'touch\\', field.field, touch);\\n\\n        }\\n      },\\n      setError: function setError(fieldId, error) {\\n        var emit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\\n\\n        var field = _this.fieldsById.get(fieldId);\\n\\n        if (!field.shadow && field.fieldApi.getIsRelevant()) {\\n          ObjectMap.set(_this.state.errors, field.field, field.fieldApi.getError());\\n        } // Shadow values override unless undefined\\n\\n\\n        var currentError = ObjectMap.get(_this.state.errors, field.field);\\n\\n        if (field.shadow && field.fieldApi.getError() != undefined && field.fieldApi.relevant(_this.state.values)) {\\n          ObjectMap.set(_this.state.errors, field.field, field.fieldApi.getError());\\n        } // Special case for attempting to set shadow to undefiend\\n        else if (field.shadow && field.fieldApi.getError() === undefined && field.fieldApi.relevant(_this.state.values) && // TODO maybe check if object or array\\n          typeof currentError === \\'string\\') {\\n            ObjectMap.set(_this.state.errors, field.field, field.fieldApi.getError());\\n          }\\n\\n        if (emit) {\\n          _this.emit(\\'change\\'); //this.emit(\\'error\\', field.field, error);\\n\\n        }\\n      },\\n      expectRemoval: _this.expectRemoval,\\n      getInitialValue: _this.getInitialValue\\n    }; // Define the formApi\\n\\n    _this.formApi = {\\n      setValue: _this.setValue,\\n      setTouched: _this.setTouched,\\n      setError: _this.setError,\\n      setFormError: _this.setFormError,\\n      setValues: _this.setValues,\\n      setInitialValue: _this.setInitialValue,\\n      getValue: _this.getValue,\\n      getTouched: _this.getTouched,\\n      getError: _this.getError,\\n      reset: _this.reset,\\n      submitForm: _this.submitForm,\\n      getState: _this.getFormState,\\n      getValues: _this.getValues,\\n      getFullField: _this.getFullField,\\n      fieldExists: _this.fieldExists,\\n      getInitialValue: _this.getInitialValue,\\n      validate: _this.validate,\\n      validateField: _this.validateField,\\n      screenValid: _this.screenValid,\\n      resetField: _this.resetField,\\n      getOptions: _this.getOptions,\\n      emitter: _assertThisInitialized(_this),\\n      getSavedValue: _this.getSavedValue,\\n      removeSavedState: _this.removeSavedState,\\n      getDerrivedValue: _this.getDerrivedValue,\\n      getStep: _this.getStep,\\n      setStep: _this.setStep,\\n      next: _this.next,\\n      back: _this.back,\\n      setCurrent: _this.setCurrent,\\n      validated: _this.validated,\\n      validating: _this.validating\\n    };\\n\\n    _this.on(\\'value\\', function (field) {\\n      // The forms values have changed so we want to clear form level error\\n      delete _this.state.error;\\n\\n      _this.notify(field);\\n    });\\n\\n    return _this;\\n  }\\n  /* ---------------------------------- Setters ---------------------------------- */\\n\\n\\n  _createClass(FormController, [{\\n    key: \"setOptions\",\\n    value: function setOptions(options) {\\n      this.options = options;\\n    }\\n  }, {\\n    key: \"setValue\",\\n    value: function setValue(name, value, options) {\\n      this.getField(name).fieldApi.setValue(value, null, _objectSpread2({\\n        allowEmptyString: this.options.allowEmptyStrings\\n      }, options));\\n    }\\n  }, {\\n    key: \"setTouched\",\\n    value: function setTouched(name, value) {\\n      this.getField(name).fieldApi.setTouched(value);\\n    }\\n  }, {\\n    key: \"setError\",\\n    value: function setError(name, value) {\\n      this.getField(name).fieldApi.setError(value);\\n    }\\n  }, {\\n    key: \"setFormError\",\\n    value: function setFormError(value) {\\n      this.state.error = value;\\n      this.emit(\\'change\\');\\n    }\\n  }, {\\n    key: \"validating\",\\n    value: function validating() {\\n      this.state.validating = this.state.validating + 1;\\n      this.emit(\\'change\\');\\n    }\\n  }, {\\n    key: \"validated\",\\n    value: function validated(name, error) {\\n      // Decrement the validating\\n      this.state.validating = this.state.validating - 1; // Set the error if there is not already one ( sync error first )\\n\\n      if (!this.getError(name)) {\\n        this.setError(name, error);\\n      } // If we are not still validating, and we were submitting, then submit form\\n      // If we are async validating then dont submit yet\\n\\n\\n      if (this.state.validating > 0) {\\n        this.emit(\\'change\\');\\n        return;\\n      } // If we were submitting\\n\\n\\n      if (this.state.submitting) {\\n        // Check validity and perform submission if valid\\n        if (this.valid()) {\\n          debug$2(\\'Submit\\', this.state);\\n          this.emit(\\'submit\\');\\n        } else {\\n          debug$2(\\'Submit\\', this.state);\\n          this.emit(\\'failure\\');\\n        }\\n\\n        this.state.submitting = false;\\n      }\\n\\n      this.emit(\\'change\\');\\n    }\\n  }, {\\n    key: \"setStep\",\\n    value: function setStep(value) {\\n      this.state.step = value;\\n      this.emit(\\'change\\');\\n    }\\n  }, {\\n    key: \"setCurrent\",\\n    value: function setCurrent(component) {\\n      this.state.Current = component;\\n      this.emit(\\'change\\');\\n    }\\n  }, {\\n    key: \"back\",\\n    value: function back(prevComponent) {\\n      this.state.step = this.state.step - 1;\\n      this.state.Current = prevComponent;\\n      this.emit(\\'change\\');\\n    }\\n  }, {\\n    key: \"next\",\\n    value: function next(nextComponent) {\\n      // Validate the entire form\\n      this.validate(); // If fields on the screen ( currently rendered ) are valid move on\\n\\n      if (this.screenValid()) {\\n        this.state.step = this.state.step + 1;\\n        this.state.Current = nextComponent;\\n      } // State will have changed\\n\\n\\n      this.emit(\\'change\\');\\n    }\\n  }, {\\n    key: \"setInitialValue\",\\n    value: function setInitialValue(field, value) {\\n      ObjectMap.set(this.options.initialValues, field, value);\\n    }\\n    /* ---------------------------------- Getters ---------------------------------- */\\n\\n    /**\\n     * Generate the external form state that will be exposed to the users\\n     *\\n     * @returns Form State\\n     */\\n\\n  }, {\\n    key: \"getFormState\",\\n    value: function getFormState() {\\n      debug$2(\\'Returning form state\\');\\n      return _objectSpread2(_objectSpread2({}, this.state), {}, {\\n        pristine: this.pristine(),\\n        dirty: this.dirty(),\\n        invalid: this.invalid()\\n      });\\n    } // rebuildState() {\\n    //   debug(\\'Generating form state\\');\\n    //   // Rebuild values, errors, and touched\\n    //   const values = {};\\n    //   const errors = {};\\n    //   const touched = {};\\n    //   this.fieldsById.forEach(field => {\\n    //     if (!field.shadow) {\\n    //       // Get the values from the field\\n    //       const value = field.fieldApi.getValue();\\n    //       const error = field.fieldApi.getError();\\n    //       const t = field.fieldApi.getTouched();\\n    //       // Set the value\\n    //       ObjectMap.set(values, field.field, value);\\n    //       ObjectMap.set(errors, field.field, error);\\n    //       ObjectMap.set(touched, field.field, t);\\n    //       // console.log(\\'SETTING\\', field.field);\\n    //     }\\n    //   });\\n    //   this.state = {\\n    //     ...this.state,\\n    //     values,\\n    //     errors,\\n    //     touched,\\n    //     pristine: this.pristine(),\\n    //     dirty: this.dirty(),\\n    //     invalid: this.invalid()\\n    //   };\\n    // }\\n\\n  }, {\\n    key: \"getFormApi\",\\n    value: function getFormApi() {\\n      return this.formApi;\\n    }\\n  }, {\\n    key: \"getDerrivedValue\",\\n    value: function getDerrivedValue(name) {\\n      var values = this.getValues();\\n      return ObjectMap.get(values, name);\\n    }\\n  }, {\\n    key: \"getValue\",\\n    value: function getValue(name) {\\n      var value = this.getField(name).fieldApi.getValue();\\n      debug$2(\\'Getting value for\\', name, value);\\n      return value;\\n    }\\n  }, {\\n    key: \"getTouched\",\\n    value: function getTouched(field) {\\n      var touched = this.getField(field).fieldApi.getTouched();\\n      debug$2(\\'Getting touched for\\', field, touched);\\n      return touched;\\n    }\\n  }, {\\n    key: \"getError\",\\n    value: function getError(field) {\\n      var error = this.getField(field).fieldApi.getError();\\n      debug$2(\\'Getting error for\\', field, error);\\n      return error;\\n    }\\n  }, {\\n    key: \"getValues\",\\n    value: function getValues() {\\n      debug$2(\\'Gettings values\\');\\n      return this.state.values;\\n    }\\n  }, {\\n    key: \"getAllTouched\",\\n    value: function getAllTouched() {\\n      debug$2(\\'Gettings touched\\');\\n      return this.state.touched;\\n    }\\n  }, {\\n    key: \"getErrors\",\\n    value: function getErrors() {\\n      debug$2(\\'Gettings errors\\');\\n      return this.state.errors;\\n    }\\n  }, {\\n    key: \"getOptions\",\\n    value: function getOptions() {\\n      return this.options;\\n    }\\n  }, {\\n    key: \"getStep\",\\n    value: function getStep() {\\n      return this.state.step;\\n    }\\n  }, {\\n    key: \"getSavedValue\",\\n    value: function getSavedValue(name) {\\n      var field = this.fieldsByName.get(name);\\n\\n      if (field && field.shadow) {\\n        return ObjectMap.get(this.savedValues, \"shadow-\".concat(name));\\n      }\\n\\n      return ObjectMap.get(this.savedValues, name);\\n    }\\n  }, {\\n    key: \"removeSavedState\",\\n    value: function removeSavedState(name) {\\n      var field = this.fieldsByName.get(name);\\n\\n      if (field && field.shadow) {\\n        return ObjectMap[\"delete\"](this.savedValues, \"shadow-\".concat(name));\\n      }\\n\\n      return ObjectMap[\"delete\"](this.savedValues, name);\\n    }\\n  }, {\\n    key: \"getFullField\",\\n    value: function getFullField(field) {\\n      return field;\\n    }\\n  }, {\\n    key: \"getInitialValue\",\\n    value: function getInitialValue(field) {\\n      return ObjectMap.get(this.options.initialValues, field);\\n    }\\n  }, {\\n    key: \"getField\",\\n    value: function getField(name) {\\n      debug$2(\\'Getting Field\\', name);\\n      var field = this.fieldsByName.get(name);\\n\\n      if (!field) {\\n        // eslint-disable-next-line no-console\\n        console.warn(\"Attempting to get field \".concat(name, \" but it does not exist\")); // Prevent app from crashing\\n\\n        return this.dummyField;\\n      }\\n\\n      return field;\\n    } // Notify other fields\\n\\n  }, {\\n    key: \"notify\",\\n    value: function notify(field) {\\n      var _this2 = this;\\n\\n      // Example field - siblings[0].married\\n      // Get the notifier\\n      var notifier = this.getField(field); // If we have a list we must notify each one\\n\\n      if (notifier && notifier.notify) {\\n        // Example: [\\'spouse\\']\\n        notifier.notify.forEach(function (fieldName) {\\n          // Get the field toNotify\\n          var JSPAN = \".\".concat(field);\\n          var path = \"\".concat(JSPAN.replace(/(.*)[.[].*/, \\'$1\\'), \".\").concat(fieldName).slice(1); // console.log(\\'PATH\\', path);\\n          // Example path - siblings[0].spouse\\n\\n          var toNotify = _this2.getField(path);\\n\\n          if (toNotify) {\\n            debug$2(\\'Notifying\\', toNotify.field);\\n            toNotify.fieldApi.validate();\\n            toNotify.fieldApi.checkRelevant();\\n          }\\n        });\\n      }\\n    }\\n  }, {\\n    key: \"validateField\",\\n    value: function validateField(field) {\\n      this.getField(field).fieldApi.validate();\\n    }\\n  }, {\\n    key: \"resetField\",\\n    value: function resetField(field) {\\n      this.getField(field).fieldApi.reset();\\n    }\\n  }, {\\n    key: \"fieldExists\",\\n    value: function fieldExists(field) {\\n      return this.fieldsByName.get(field) != null;\\n    }\\n  }, {\\n    key: \"valid\",\\n    value: function valid() {\\n      var errors = this.getErrors();\\n      return !!(ObjectMap.empty(errors) && !this.state.error);\\n    }\\n  }, {\\n    key: \"screenValid\",\\n    value: function screenValid() {\\n      // Return false if any of the fields on the screen are invalid\\n      var error = Object.entries(this.onScreen).some(function (_ref) {\\n        var _ref2 = _slicedToArray(_ref, 2),\\n            field = _ref2[1];\\n\\n        return field.fieldApi.getError();\\n      });\\n      return !error;\\n    }\\n  }, {\\n    key: \"invalid\",\\n    value: function invalid() {\\n      var errors = this.getErrors();\\n      return !!(!ObjectMap.empty(errors) || this.state.error);\\n    }\\n  }, {\\n    key: \"pristine\",\\n    value: function pristine() {\\n      var touched = this.getAllTouched();\\n      var values = this.getValues();\\n      return ObjectMap.empty(touched) && ObjectMap.empty(values);\\n    }\\n  }, {\\n    key: \"dirty\",\\n    value: function dirty() {\\n      return !this.pristine();\\n    }\\n  }, {\\n    key: \"reset\",\\n    value: function reset() {\\n      debug$2(\\'Resetting\\'); // So because all fields controll themselves and, \"inform\", this controller\\n      // of their changes, we need to literally itterate through all registered fields\\n      // and reset them. Not a big deal but very important to remember that you cant simply\\n      // reset this controllers state!\\n\\n      this.fieldsById.forEach(function (field) {\\n        field.fieldApi.reset({\\n          preventUpdate: true\\n        });\\n      });\\n      this.emit(\\'reset\\');\\n      this.emit(\\'change\\');\\n    }\\n  }, {\\n    key: \"setValues\",\\n    value: function setValues(values) {\\n      debug$2(\\'Setting values\\'); // So we because all fields controll themselves and, \"inform\", this controller\\n      // of their changes, we need to literally itterate through all registered fields\\n      // and set them. Not a big deal but very important to remember that you cant simply\\n      // set this controllers state!\\n\\n      this.fieldsById.forEach(function (field) {\\n        // Initialize the values if it needs to be\\n        var value = ObjectMap.get(values, field.field);\\n\\n        if (value !== undefined) {\\n          field.fieldApi.setValue(value, null, {\\n            preventUpdate: true\\n          });\\n        }\\n      });\\n      this.emit(\\'change\\');\\n    }\\n  }, {\\n    key: \"validate\",\\n    value: function validate() {\\n      var _this3 = this;\\n\\n      debug$2(\\'Validating all fields\\');\\n      var values = this.getValues(); // Validate schema if needed\\n\\n      if (this.options.validationSchema) {\\n        var errors = validateYupSchema(this.options.validationSchema, values); // So we because all fields controll themselves and, \"inform\", this controller\\n        // of their changes, we need to literally itterate through all registered fields\\n        // and set them. Not a big deal but very important to remember that you cant simply\\n        // set this controllers state!\\n\\n        this.fieldsById.forEach(function (field) {\\n          // Check to see if there is an error to set\\n          // Note: we use has becuause value may be there but undefined\\n          if (ObjectMap.has(errors, field.field)) {\\n            var error = ObjectMap.get(errors, field.field); // If there is an error then set it\\n\\n            _this3.setError(field.field, error);\\n          } else {\\n            // If we are doing schema validation then we need to clear out any old errors\\n            _this3.setError(field.field, undefined);\\n          }\\n        });\\n      } // Validate AJV schema if needed\\n\\n\\n      if (this.options.schema && this.options.ajv) {\\n        var _errors = validateAjvSchema(this.ajvValidate, values); // So we because all fields controll themselves and, \"inform\", this controller\\n        // of their changes, we need to literally itterate through all registered fields\\n        // and set them. Not a big deal but very important to remember that you cant simply\\n        // set this controllers state!\\n\\n\\n        this.fieldsById.forEach(function (field) {\\n          // Check to see if there is an error to set\\n          // Note: we use has becuause value may be there but undefined\\n          if (ObjectMap.has(_errors, field.field)) {\\n            var error = ObjectMap.get(_errors, field.field); // If there is an error then set it\\n\\n            _this3.setError(field.field, error);\\n          } else {\\n            // If we are doing schema validation then we need to clear out any old errors\\n            _this3.setError(field.field, undefined);\\n          }\\n        });\\n      } // Itterate through and call validate on every field\\n\\n\\n      this.fieldsById.forEach(function (field) {\\n        field.fieldApi.validate(values); // Second param to prevent validation\\n\\n        field.fieldApi.setTouched(true, true);\\n      }); // Call the form level validation if its present\\n\\n      if (this.options.validate) {\\n        var res = this.options.validate(values);\\n        this.setFormError(res);\\n      } // Call the forms field level validation\\n\\n\\n      if (this.options.validateFields) {\\n        var _errors2 = this.options.validateFields(values); // So we because all fields controll themselves and, \"inform\", this controller\\n        // of their changes, we need to literally itterate through all registered fields\\n        // and set them. Not a big deal but very important to remember that you cant simply\\n        // set this controllers state!\\n\\n\\n        this.fieldsById.forEach(function (field) {\\n          // Check to see if there is an error to set\\n          // Note: we use has becuause value may be there but undefined\\n          if (ObjectMap.has(_errors2, field.field)) {\\n            var error = ObjectMap.get(_errors2, field.field); // If there is an error then set it\\n\\n            _this3.setError(field.field, error);\\n          }\\n        });\\n      }\\n    }\\n  }, {\\n    key: \"asyncValidate\",\\n    value: function asyncValidate() {\\n      debug$2(\\'Async Validating all fields\\');\\n      var values = this.getValues(); // Itterate through and call validate on every field\\n\\n      this.fieldsById.forEach(function (field) {\\n        field.fieldApi.asyncValidate(values);\\n      });\\n    }\\n  }, {\\n    key: \"keyDown\",\\n    value: function keyDown(e) {\\n      // If preventEnter then return\\n      if (e.keyCode == 13 && this.options.preventEnter) {\\n        e.preventDefault(e);\\n        return false;\\n      }\\n    }\\n  }, {\\n    key: \"submitForm\",\\n    value: function submitForm(e) {\\n      // Incriment number of submit attempts\\n      this.state.submits = this.state.submits + 1;\\n      this.state.submitting = true;\\n\\n      if (!this.options.dontPreventDefault && e) {\\n        // Prevent default browser form submission\\n        e.preventDefault(e);\\n      } // Validate the form\\n\\n\\n      this.validate(); // Emit a change\\n\\n      this.emit(\\'change\\'); // Trigger all async validations\\n\\n      this.asyncValidate(); // If we are async validating then dont submit yet\\n\\n      if (this.state.validating > 0) {\\n        return;\\n      } // Check validity and perform submission if valid\\n\\n\\n      if (this.valid()) {\\n        debug$2(\\'Submit\\', this.state);\\n        this.emit(\\'submit\\');\\n      } else {\\n        debug$2(\\'Submit\\', this.state);\\n        this.emit(\\'failure\\');\\n      }\\n\\n      this.state.submitting = false;\\n      this.emit(\\'change\\');\\n    }\\n    /* ---------------- Updater Functions (used by fields) ---------------- */\\n    // ADDED initialRender parameter because of react 16.13.0 warning that does not like\\n    // setting initial value during first render\\n\\n  }, {\\n    key: \"register\",\\n    value: function register(id, field, initialRender) {\\n      var name = field.field,\\n          state = field.state;\\n      debug$2(\\'Register ID:\\', id, \\'Name:\\', name, state, \\'Initial\\', initialRender); // Example foo.bar.baz[3].baz >>>> foo.bar.baz[3]\\n\\n      var magicValue = name.slice(0, name.lastIndexOf(\\'[\\') != -1 ? name.lastIndexOf(\\']\\') + 1 : name.length); // Field might be coming back after render remove old field\\n\\n      var alreadyRegistered;\\n      this.fieldsById.forEach(function (value, key) {\\n        if (value && value.field === name) {\\n          alreadyRegistered = key;\\n        }\\n      });\\n\\n      if ( //!this.expectedRemovals[magicValue] &&\\n      alreadyRegistered && (field.keepState || field.inMultistep)) {\\n        debug$2(\\'Already Registered\\', name);\\n        this.fieldsById[\"delete\"](alreadyRegistered);\\n      } else if ( //!this.expectedRemovals[magicValue] &&\\n      alreadyRegistered && (!field.keepState || !field.inMultistep)) {\\n        // eslint-disable-next-line no-console\\n        console.warn(\\'Check to make sure you have not registered two fields with the fieldName\\', name);\\n      }\\n\\n      debug$2(\\'Fields Registered\\', this.fieldsById.size); // The field is on the screen\\n\\n      this.onScreen[id] = field; // Always register the field\\n\\n      this.fieldsById.set(id, field); // Always clear out expected removals when a reregistering array field comes in\\n\\n      debug$2(\\'clearing expected removal\\', magicValue);\\n      delete this.expectedRemovals[magicValue];\\n      delete this.pulledOut[magicValue]; // The field is a shadow field ooo spooky so dont set anything\\n\\n      if (field.shadow) {\\n        return;\\n      } // Update the forms state right away\\n\\n\\n      this.updater.setValue(id, field.fieldApi.getValue(), false);\\n      this.updater.setError(id, field.fieldApi.getError(), false);\\n      this.updater.setTouched(id, field.fieldApi.getTouched(), false); // We register field right away but dont want it to triger a rerender\\n\\n      if (!initialRender) {\\n        this.emit(\\'change\\');\\n      }\\n    }\\n  }, {\\n    key: \"deregister\",\\n    value: function deregister(id) {\\n      var field = this.fieldsById.get(id);\\n      var name = field.field;\\n      debug$2(\\'Deregister\\', id, name); // The field is off the screen\\n\\n      delete this.onScreen[id]; // Example foo.bar.baz[3] --\\x3e foo.bar.baz[3].baz && foo.bar.baz[3].taz.raz[4].naz\\n\\n      var expectedRemoval = isExpected(name, this.expectedRemovals); // Example foo.bar.baz[3].baz >>>> foo.bar.baz[3]\\n\\n      var magicValue = name.slice(0, name.lastIndexOf(\\'[\\') != -1 ? name.lastIndexOf(\\']\\') + 1 : name.length); // If the fields state is to be kept then save the value\\n\\n      if ( // We are in a multistep or want to keep the state\\n      (field.keepState || field.inMultistep) && // We are NOT expected to be removed\\n      !expectedRemoval) {\\n        // TODO ?? Exception where the field is irrelivant AND keep state was not passed ??\\n        debug$2(\"Saving field \".concat(name, \"\\'s value\"), field.fieldApi.getFieldState());\\n\\n        if (!field.shadow) {\\n          ObjectMap.set(this.savedValues, name, field.fieldApi.getFieldState());\\n        } else {\\n          // We are shadow field and will store this value in the shadows\\n          ObjectMap.set(this.savedValues, \"shadow-\".concat(name), field.fieldApi.getFieldState());\\n        }\\n      } // Remove if its an expected removal OR we dont have keep state\\n\\n\\n      if ( // This field was expected to be removed\\n      expectedRemoval || // This field does not have keepstate and is NOT within a multistep\\n      !field.keepState && !field.inMultistep || // If field is in multistep then we would always keep due to field.inMultistep\\n      // BUT.. we need to also check if the field is irrelivant\\n      // because if it gets unmounted, even if its part of a multistep, we want to remove\\n      // the field completley, unless keep state was passed.\\n      !field.fieldApi.getIsRelevant() && !field.keepState) {\\n        // Remove the field completley\\n        debug$2(\\'Removing field\\', name);\\n        this.fieldsById[\"delete\"](id); // Clean up state only if its not expected removal, otherwise we will just pull it out\\n\\n        if (!expectedRemoval) {\\n          ObjectMap[\"delete\"](this.state.values, name);\\n          ObjectMap[\"delete\"](this.state.touched, name);\\n          ObjectMap[\"delete\"](this.state.errors, name);\\n\\n          if (!field.shadow) {\\n            ObjectMap[\"delete\"](this.savedValues, name);\\n          } else {\\n            ObjectMap[\"delete\"](this.savedValues, \"shadow-\".concat(name));\\n          }\\n        } // If we expected this removal then pullOut\\n\\n\\n        if (expectedRemoval && this.pulledOut[magicValue]) {\\n          debug$2(\\'Pulling out\\', name, \\'with magic value\\', magicValue);\\n          ObjectMap.pullOut(this.state.values, magicValue);\\n          ObjectMap.pullOut(this.state.touched, magicValue);\\n          ObjectMap.pullOut(this.state.errors, magicValue);\\n          ObjectMap.pullOut(this.savedValues, magicValue); // console.log(\\'Pull1\\', this.state.values);\\n          // console.log(\\'Pull2\\', this.savedValues);\\n\\n          delete this.pulledOut[magicValue];\\n        }\\n      }\\n\\n      this.emit(\\'change\\');\\n    }\\n  }, {\\n    key: \"expectRemoval\",\\n    value: function expectRemoval(name) {\\n      debug$2(\\'Expecting removal of\\', name);\\n      this.expectedRemovals[name] = true;\\n      this.pulledOut[name] = true;\\n    }\\n  }, {\\n    key: \"update\",\\n    value: function update(id, field, oldName) {\\n      debug$2(\\'Update\\', id, field.field, oldName, field.fieldState.value); // this.change();\\n      // Update the error touched and values of this field\\n\\n      var value = field.fieldApi.getValue();\\n      var error = field.fieldApi.getError();\\n      var t = field.fieldApi.getTouched(); // Clear the old value out\\n\\n      var oldField = this.fieldsByName.get(oldName); // Only clear if we had an old name ( our name changed )\\n      // %% the oldField is gone!\\n\\n      if (oldName && !oldField) {\\n        // Setting nothing sets to undefined and does NOT pull out\\n        ObjectMap.set(this.state.values, oldName);\\n        ObjectMap.set(this.state.errors, oldName);\\n        ObjectMap.set(this.state.touched, oldName);\\n      } // Set the value\\n\\n\\n      ObjectMap.set(this.state.values, field.field, value);\\n      ObjectMap.set(this.state.errors, field.field, error);\\n      ObjectMap.set(this.state.touched, field.field, t);\\n      this.emit(\\'change\\');\\n    }\\n  }]);\\n\\n  return FormController;\\n}(events__WEBPACK_IMPORTED_MODULE_1__[\"EventEmitter\"]);\\n\\nvar logger$5 = debug(\\'informed:FormProvider\\' + \\'\\\\t\\\\t\\');\\n\\nvar FormProvider = function FormProvider(_ref) {\\n  var children = _ref.children,\\n      formApi = _ref.formApi,\\n      formController = _ref.formController,\\n      formState = _ref.formState,\\n      rest = _objectWithoutProperties(_ref, [\"children\", \"formApi\", \"formController\", \"formState\"]);\\n\\n  logger$5(\\'Render FormProvider\\');\\n\\n  if (formApi) {\\n    logger$5(\\'Render FormProvider with given values\\');\\n    /* --- Create Provider with given values and render Content --- */\\n\\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(FormRegisterContext.Provider, {\\n      value: formController.updater\\n    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(FormApiContext.Provider, {\\n      value: formApi\\n    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(FormStateContext.Provider, {\\n      value: formState\\n    }, children)));\\n  }\\n\\n  logger$5(\\'Render FormProvider with generated values\\');\\n  /* --- User did not pass values so create them --- */\\n\\n  var value = useForm(rest);\\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(FormRegisterContext.Provider, {\\n    value: value.formController.updater\\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(FormApiContext.Provider, {\\n    value: value.formApi\\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(FormStateContext.Provider, {\\n    value: value.formState\\n  }, children)));\\n};\\n\\nvar logger$6 = debug(\\'informed:useForm\\' + \\'\\\\t\\\\t\\');\\n\\nvar useForm = function useForm(_ref) {\\n  var dontPreventDefault = _ref.dontPreventDefault,\\n      initialValues = _ref.initialValues,\\n      validate = _ref.validate,\\n      validateFields = _ref.validateFields,\\n      allowEmptyStrings = _ref.allowEmptyStrings,\\n      preventEnter = _ref.preventEnter,\\n      getApi = _ref.getApi,\\n      apiRef = _ref.apiRef,\\n      onChange = _ref.onChange,\\n      onReset = _ref.onReset,\\n      onSubmit = _ref.onSubmit,\\n      onValueChange = _ref.onValueChange,\\n      onSubmitFailure = _ref.onSubmitFailure,\\n      validationSchema = _ref.validationSchema,\\n      schema = _ref.schema,\\n      ajv = _ref.ajv,\\n      fieldMap = _ref.fieldMap,\\n      onlyValidateSchema = _ref.onlyValidateSchema,\\n      userProps = _objectWithoutProperties(_ref, [\"dontPreventDefault\", \"initialValues\", \"validate\", \"validateFields\", \"allowEmptyStrings\", \"preventEnter\", \"getApi\", \"apiRef\", \"onChange\", \"onReset\", \"onSubmit\", \"onValueChange\", \"onSubmitFailure\", \"validationSchema\", \"schema\", \"ajv\", \"fieldMap\", \"onlyValidateSchema\"]);\\n\\n  logger$6(\\'Render useForm\\'); // Generate form controller options\\n\\n  var formControllerOptions = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useMemo\"])(function () {\\n    return {\\n      dontPreventDefault: dontPreventDefault,\\n      initialValues: initialValues,\\n      validate: validate,\\n      validateFields: validateFields,\\n      allowEmptyStrings: allowEmptyStrings,\\n      preventEnter: preventEnter,\\n      validationSchema: validationSchema,\\n      schema: schema,\\n      ajv: ajv,\\n      fieldMap: fieldMap\\n    };\\n  }, [dontPreventDefault, initialValues, validate, validateFields, allowEmptyStrings, preventEnter, validationSchema, schema, ajv, fieldMap]); // Create form controller\\n\\n  var _useState = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useState\"])(function () {\\n    return new FormController(formControllerOptions);\\n  }),\\n      _useState2 = _slicedToArray(_useState, 1),\\n      formController = _useState2[0]; // Update the options when they change\\n\\n\\n  Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"])(function () {\\n    formController.setOptions(formControllerOptions);\\n  }, [formControllerOptions]); // Form state will be used to trigger rerenders\\n\\n  var _useState3 = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useState\"])(function () {\\n    return formController.getFormState();\\n  }),\\n      _useState4 = _slicedToArray(_useState3, 2),\\n      formState = _useState4[0],\\n      setFormState = _useState4[1]; // Register for events\\n\\n\\n  useIsomorphicLayoutEffect(function () {\\n    var onChangeHandler = function onChangeHandler() {\\n      return onChange && onChange(formController.getFormState());\\n    };\\n\\n    var onResetHandler = function onResetHandler() {\\n      return onReset && onReset();\\n    };\\n\\n    var onSubmitHandler = function onSubmitHandler() {\\n      return onSubmit && onSubmit(formController.getFormState().values);\\n    };\\n\\n    var onValueHandler = function onValueHandler() {\\n      return onValueChange && onValueChange(formController.getFormState().values);\\n    };\\n\\n    var onFailureHandler = function onFailureHandler() {\\n      return onSubmitFailure && onSubmitFailure(formController.getFormState().errors);\\n    }; // Register for events\\n\\n\\n    formController.on(\\'change\\', onChangeHandler);\\n    formController.on(\\'reset\\', onResetHandler);\\n    formController.on(\\'submit\\', onSubmitHandler);\\n    formController.on(\\'value\\', onValueHandler);\\n    formController.on(\\'failure\\', onFailureHandler); // Unregister events\\n\\n    return function () {\\n      formController.removeListener(\\'change\\', onChangeHandler);\\n      formController.removeListener(\\'reset\\', onResetHandler);\\n      formController.removeListener(\\'submit\\', onSubmitHandler);\\n      formController.removeListener(\\'value\\', onValueHandler);\\n      formController.removeListener(\\'failure\\', onFailureHandler);\\n    };\\n  }, [onChange, onReset, onSubmit, onValueChange, onSubmitFailure]); // Initialize code like constructor but not muhahah\\n\\n  Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useState\"])(function () {\\n    // Update the form state to trigger rerender!\\n    var onChangeHandlerRerender = function onChangeHandlerRerender() {\\n      logger$6(\\'Setting form state\\');\\n      setFormState(formController.getFormState());\\n    }; // const debounced = debounce(onChangeHandlerRerender, 250);\\n\\n\\n    formController.on(\\'change\\', onChangeHandlerRerender); // Give access to api outside\\n\\n    if (getApi) {\\n      getApi(formController.getFormApi());\\n    }\\n\\n    if (apiRef) {\\n      apiRef.current = formController.getFormApi();\\n    }\\n  }); // We dont want this to happen on every render so thats why useState is used here\\n\\n  var _useState5 = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useState\"])(function () {\\n    return formController.getFormApi();\\n  }),\\n      _useState6 = _slicedToArray(_useState5, 1),\\n      formApi = _useState6[0]; // TODO technically speaking this can be unsafe as there is circular dependency\\n  // between form provider and useForm.. Its ok because anyone that in theory\\n  // Uses a form provider and a use form hook themselves will never call the render\\n  // function created here... that being said I will look into fixing that warning\\n  // at some point :)\\n\\n\\n  var render = function render(children) {\\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(FormProvider, {\\n      formApi: formApi,\\n      formState: formState,\\n      formController: formController\\n    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react__WEBPACK_IMPORTED_MODULE_0___default.a.Fragment, null, !children ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(FormFields, {\\n      schema: schema,\\n      onlyValidateSchema: onlyValidateSchema\\n    }) : children));\\n  };\\n\\n  return {\\n    formApi: formApi,\\n    formState: formState,\\n    formController: formController,\\n    render: render,\\n    userProps: userProps\\n  };\\n};\\n\\nvar debug$3 = debug(\\'informed:Form\\' + \\'\\\\t\\\\t\\');\\n\\nvar Form = function Form(_ref) {\\n  var children = _ref.children,\\n      renderProp = _ref.render,\\n      component = _ref.component,\\n      rest = _objectWithoutProperties(_ref, [\"children\", \"render\", \"component\"]);\\n\\n  debug$3(\\'Render FORM\\');\\n\\n  var _useForm = useForm(rest),\\n      formApi = _useForm.formApi,\\n      formController = _useForm.formController,\\n      formState = _useForm.formState,\\n      render = _useForm.render,\\n      userProps = _useForm.userProps;\\n\\n  var getContent = function getContent() {\\n    var props = {\\n      formState: formState,\\n      formApi: formApi\\n    };\\n\\n    if (component) {\\n      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(component, props, children);\\n    }\\n\\n    if (renderProp) {\\n      return renderProp(props);\\n    }\\n\\n    if (typeof children === \\'function\\') {\\n      return children(props);\\n    }\\n\\n    return children;\\n  };\\n  /* --- Render Content --- */\\n\\n\\n  return render( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"form\", _extends({}, userProps, {\\n    onReset: formController.reset,\\n    onSubmit: formController.submitForm,\\n    onKeyDown: formController.keyDown\\n  }), getContent()));\\n};\\n\\nvar buildScopedFormApi$1 = function buildScopedFormApi(scope, formApi) {\\n  return _objectSpread2(_objectSpread2({}, formApi), {}, {\\n    getValue: function getValue(field) {\\n      return formApi.getValue(\"\".concat(scope, \".\").concat(field));\\n    },\\n    getTouched: function getTouched(field) {\\n      return formApi.getTouched(\"\".concat(scope, \".\").concat(field));\\n    },\\n    getError: function getError(field) {\\n      return formApi.getError(\"\".concat(scope, \".\").concat(field));\\n    },\\n    setValue: function setValue(field, value) {\\n      return formApi.setValue(\"\".concat(scope, \".\").concat(field), value);\\n    },\\n    setTouched: function setTouched(field, value) {\\n      return formApi.setTouched(\"\".concat(scope, \".\").concat(field), value);\\n    },\\n    setError: function setError(field, value) {\\n      return formApi.setError(\"\".concat(scope, \".\").concat(field), value);\\n    },\\n    getInitialValue: function getInitialValue(field) {\\n      return formApi.getInitialValue(\"\".concat(scope, \".\").concat(field));\\n    },\\n    getFullField: function getFullField(field) {\\n      return \"\".concat(formApi.getFullField(scope), \".\").concat(field);\\n    }\\n  });\\n};\\n\\nvar buildScopedRegister = function buildScopedRegister(scope, formRegister) {\\n  var _register = formRegister.register,\\n      _deregister = formRegister.deregister,\\n      _setValue = formRegister.setValue,\\n      _setTouched = formRegister.setTouched,\\n      _setError = formRegister.setError,\\n      _update = formRegister.update,\\n      _getField = formRegister.getField,\\n      _expectRemoval = formRegister.expectRemoval,\\n      _getInitialValue = formRegister.getInitialValue,\\n      fieldMap = formRegister.fieldMap;\\n  return {\\n    register: function register(field) {\\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\\n        args[_key - 1] = arguments[_key];\\n      }\\n\\n      return _register.apply(void 0, [\"\".concat(scope, \".\").concat(field)].concat(args));\\n    },\\n    deregister: function deregister(field) {\\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\\n        args[_key2 - 1] = arguments[_key2];\\n      }\\n\\n      return _deregister.apply(void 0, [\"\".concat(scope, \".\").concat(field)].concat(args));\\n    },\\n    update: function update(field) {\\n      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\\n        args[_key3 - 1] = arguments[_key3];\\n      }\\n\\n      return _update.apply(void 0, [\"\".concat(scope, \".\").concat(field)].concat(args));\\n    },\\n    setValue: function setValue(field) {\\n      for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\\n        args[_key4 - 1] = arguments[_key4];\\n      }\\n\\n      return _setValue.apply(void 0, [\"\".concat(scope, \".\").concat(field)].concat(args));\\n    },\\n    setTouched: function setTouched(field) {\\n      for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\\n        args[_key5 - 1] = arguments[_key5];\\n      }\\n\\n      return _setTouched.apply(void 0, [\"\".concat(scope, \".\").concat(field)].concat(args));\\n    },\\n    setError: function setError(field) {\\n      for (var _len6 = arguments.length, args = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {\\n        args[_key6 - 1] = arguments[_key6];\\n      }\\n\\n      return _setError.apply(void 0, [\"\".concat(scope, \".\").concat(field)].concat(args));\\n    },\\n    getField: function getField(field) {\\n      for (var _len7 = arguments.length, args = new Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {\\n        args[_key7 - 1] = arguments[_key7];\\n      }\\n\\n      return _getField.apply(void 0, [\"\".concat(scope, \".\").concat(field)].concat(args));\\n    },\\n    expectRemoval: function expectRemoval(field) {\\n      for (var _len8 = arguments.length, args = new Array(_len8 > 1 ? _len8 - 1 : 0), _key8 = 1; _key8 < _len8; _key8++) {\\n        args[_key8 - 1] = arguments[_key8];\\n      }\\n\\n      return _expectRemoval.apply(void 0, [\"\".concat(scope, \".\").concat(field)].concat(args));\\n    },\\n    getInitialValue: function getInitialValue(field) {\\n      return _getInitialValue(\"\".concat(scope, \".\").concat(field));\\n    },\\n    fieldMap: fieldMap\\n  };\\n};\\n\\nvar Scope = function Scope(_ref) {\\n  var scope = _ref.scope,\\n      children = _ref.children;\\n  var formRegister = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useContext\"])(FormRegisterContext);\\n  var formApi = useFormApi();\\n  var formState = useFormState(); // VERY important to memoize the builders!\\n\\n  var scopedFormApi = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useMemo\"])(function () {\\n    return buildScopedFormApi$1(scope, formApi);\\n  }, [scope]);\\n  var scopedRegister = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useMemo\"])(function () {\\n    return buildScopedRegister(scope, formRegister);\\n  }, [scope]);\\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(FormRegisterContext.Provider, {\\n    value: scopedRegister\\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(FormApiContext.Provider, {\\n    value: scopedFormApi\\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(FormStateContext.Provider, {\\n    value: formState\\n  }, children)));\\n};\\n\\nvar FormState = function FormState(props) {\\n  var formState = useFormState();\\n  var displayState = {};\\n\\n  if (Object.keys(props).length > 0) {\\n    Object.keys(props).forEach(function (key) {\\n      displayState[key] = formState[key];\\n    });\\n  } else {\\n    displayState = formState;\\n  }\\n\\n  var _displayState = displayState,\\n      pristine = _displayState.pristine,\\n      dirty = _displayState.dirty,\\n      invalid = _displayState.invalid,\\n      values = _displayState.values,\\n      errors = _displayState.errors,\\n      touched = _displayState.touched,\\n      validating = _displayState.validating,\\n      submitting = _displayState.submitting;\\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"pre\", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"code\", null, JSON.stringify({\\n    pristine: pristine,\\n    dirty: dirty,\\n    invalid: invalid,\\n    values: values,\\n    errors: errors,\\n    touched: touched,\\n    validating: validating,\\n    submitting: submitting\\n  }, null, 2)));\\n};\\n\\nvar useMultistep = function useMultistep(_ref) {\\n  var initialStep = _ref.initialStep,\\n      multistepApiRef = _ref.multistepApiRef;\\n\\n  // Get the formApi\\n  var _useFormApi = useFormApi(),\\n      getValues = _useFormApi.getValues,\\n      validate = _useFormApi.validate,\\n      screenValid = _useFormApi.screenValid; // Track our steps by name\\n\\n\\n  var _useState = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useState\"])(new Map()),\\n      _useState2 = _slicedToArray(_useState, 1),\\n      stepsByName = _useState2[0]; // Define our state\\n\\n\\n  var _useStateWithGetter = useStateWithGetter({\\n    current: initialStep,\\n    steps: []\\n  }),\\n      _useStateWithGetter2 = _slicedToArray(_useStateWithGetter, 3),\\n      multistepState = _useStateWithGetter2[0],\\n      setMultistepState = _useStateWithGetter2[1],\\n      getMultistepState = _useStateWithGetter2[2]; // Define our api\\n\\n\\n  var _useState3 = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useState\"])(function () {\\n    var getCurrentStep = function getCurrentStep() {\\n      // Get the current state\\n      var _getMultistepState = getMultistepState(),\\n          current = _getMultistepState.current; // Get the current step\\n\\n\\n      var currentStep = stepsByName.get(current); // Return it\\n\\n      return currentStep;\\n    };\\n\\n    var api = {\\n      // Gets the whole state\\n      getState: function getState() {\\n        return getMultistepState();\\n      },\\n      // Gets just the current\\n      getCurrentStep: getCurrentStep,\\n      // Gets that step\\n      getStep: function getStep(name) {\\n        return stepsByName.get(name);\\n      },\\n      // Goes to next step\\n      next: function next() {\\n        // Validate the entire form\\n        validate(); // If fields on the screen ( currently rendered ) are valid move on\\n\\n        if (screenValid()) {\\n          // Get the current step\\n          var _getCurrentStep = getCurrentStep(),\\n              getNext = _getCurrentStep.getNext;\\n\\n          var next = getNext(); // Determine what the next step should be\\n\\n          var nextStep = typeof next === \\'function\\' ? next(getValues()) : next; // Determine if it has a next\\n\\n          if (nextStep) {\\n            setMultistepState(function (prev) {\\n              return _objectSpread2(_objectSpread2({}, prev), {}, {\\n                current: nextStep\\n              });\\n            });\\n          }\\n        }\\n      },\\n      // Goes to previous step\\n      back: function back() {\\n        // Get the current step\\n        var _getCurrentStep2 = getCurrentStep(),\\n            getPrevious = _getCurrentStep2.getPrevious;\\n\\n        var previous = getPrevious(); // Determine what the previous step should be\\n\\n        var previousStep = typeof previous === \\'function\\' ? previous(getValues()) : previous; // Determine if it has a previous\\n\\n        if (previousStep) {\\n          setMultistepState(function (prev) {\\n            return _objectSpread2(_objectSpread2({}, prev), {}, {\\n              current: previousStep\\n            });\\n          });\\n        }\\n      },\\n      // Goes to specified step\\n      setCurrent: function setCurrent(next) {\\n        // Determine if it has a next\\n        if (next) {\\n          setMultistepState(function (prev) {\\n            return _objectSpread2(_objectSpread2({}, prev), {}, {\\n              current: next\\n            });\\n          });\\n        }\\n      },\\n      // Registers the step\\n      register: function register(name, step, initial) {\\n        stepsByName.set(name, step);\\n\\n        if (!initial) {\\n          setMultistepState(function (prev) {\\n            return _objectSpread2(_objectSpread2({}, prev), {}, {\\n              steps: Array.from(stepsByName.keys())\\n            });\\n          });\\n        }\\n      },\\n      // Deregisters the step\\n      deregister: function deregister(name) {\\n        stepsByName[\"delete\"](name);\\n        setMultistepState(function (prev) {\\n          return _objectSpread2(_objectSpread2({}, prev), {}, {\\n            steps: Array.from(stepsByName.keys())\\n          });\\n        });\\n      }\\n    };\\n\\n    if (multistepApiRef) {\\n      multistepApiRef.current = api;\\n    }\\n\\n    return api;\\n  }),\\n      _useState4 = _slicedToArray(_useState3, 1),\\n      multistepApi = _useState4[0]; // Render funtion that will provide state and api\\n\\n\\n  var render = function render(children) {\\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(MultistepApiContext.Provider, {\\n      value: multistepApi\\n    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(MultistepStateContext.Provider, {\\n      value: multistepState\\n    }, children));\\n  };\\n\\n  return _objectSpread2(_objectSpread2(_objectSpread2({}, multistepApi), multistepState), {}, {\\n    render: render\\n  });\\n};\\n\\nfunction useMultistepState() {\\n  return Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useContext\"])(MultistepStateContext);\\n}\\n\\nfunction useMultistepApi() {\\n  return Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useContext\"])(MultistepApiContext);\\n}\\n\\nvar useMultistepStep = function useMultistepStep(_ref) {\\n  var step = _ref.step,\\n      next = _ref.next,\\n      previous = _ref.previous,\\n      relevant = _ref.relevant;\\n\\n  var _useFormState = useFormState(),\\n      values = _useFormState.values;\\n\\n  var _useMultistepState = useMultistepState(),\\n      current = _useMultistepState.current;\\n\\n  var _useMultistepApi = useMultistepApi(),\\n      register = _useMultistepApi.register,\\n      deregister = _useMultistepApi.deregister;\\n\\n  var isCurrent = step === current;\\n  var isRelevant = relevant ? relevant(values) : true;\\n  var nextRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(next);\\n  var prevRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(previous);\\n  var relevantRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])();\\n  nextRef.current = next;\\n  prevRef.current = previous;\\n  relevantRef.current = relevant;\\n  Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useState\"])(function () {\\n    register(step, {\\n      name: step,\\n      getNext: function getNext() {\\n        return nextRef.current;\\n      },\\n      getPrevious: function getPrevious() {\\n        return prevRef.current;\\n      }\\n    }, true);\\n  });\\n  Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"])(function () {\\n    register(step, {\\n      name: step,\\n      getNext: function getNext() {\\n        return nextRef.current;\\n      },\\n      getPrevious: function getPrevious() {\\n        return prevRef.current;\\n      }\\n    });\\n    return function () {\\n      deregister(step);\\n    };\\n  }, [step]);\\n\\n  var render = function render(children) {\\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(MultistepStepContext.Provider, {\\n      value: {\\n        relevant: function relevant(params) {\\n          return relevantRef.current ? relevantRef.current(params) : true;\\n        },\\n        multistep: true\\n      }\\n    }, isCurrent && isRelevant ? children : null);\\n  };\\n\\n  return {\\n    isCurrent: isCurrent,\\n    isRelevant: isRelevant,\\n    step: step,\\n    render: render\\n  };\\n};\\n\\nfunction Multistep(_ref) {\\n  var children = _ref.children,\\n      props = _objectWithoutProperties(_ref, [\"children\"]);\\n\\n  var _useMultistep = useMultistep(props),\\n      render = _useMultistep.render,\\n      context = _objectWithoutProperties(_useMultistep, [\"render\"]);\\n\\n  if (typeof children === \\'function\\') {\\n    return render(children(context));\\n  }\\n\\n  return render(children);\\n}\\n\\nMultistep.Step = function MultistepStep(_ref2) {\\n  var children = _ref2.children,\\n      props = _objectWithoutProperties(_ref2, [\"children\"]);\\n\\n  var _useMultistepStep = useMultistepStep(props),\\n      render = _useMultistepStep.render;\\n\\n  return render(children);\\n};\\n\\nvar FormField = function FormField(_ref) {\\n  var field = _ref.field;\\n\\n  // Get the field map off the forms context\\n  var _useContext = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useContext\"])(FormRegisterContext),\\n      fieldMap = _useContext.fieldMap; // Grab the form api ( we need it to get the actual field name because might be in scope )\\n\\n\\n  var _useFormApi = useFormApi(),\\n      getFullField = _useFormApi.getFullField,\\n      getOptions = _useFormApi.getOptions; // Grab the full field\\n\\n\\n  var fullField = getFullField(field); // Grap the schema\\n\\n  var _getOptions = getOptions(),\\n      schema = _getOptions.schema; // First find property from the schema via the path to that field\\n  // Examples\\n  // field = \"name\" ---\\x3e properties.name\\n  // field = \"brother.name\" ---\\x3e properties.brother.properties.name\\n  // field = \"brother.siblings[1].friend.name\" ---\\x3e properties.brother.properties.siblings.items[1].properties.friend.properties.name\\n\\n\\n  var path = getSchemaPathFromJsonPath(fullField);\\n  var property = ObjectMap.get(schema, path); // If property was not found return null\\n\\n  if (!property) {\\n    return null;\\n  } // Next compute the field from property\\n\\n\\n  var schemaField = computeFieldFromProperty(field, property);\\n  var props = schemaField.props,\\n      componentType = schemaField.componentType;\\n  var Component = fieldMap[componentType];\\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(Component, _extends({\\n    field: field\\n  }, props));\\n};\\n\\nvar SchemaFields = function SchemaFields() {\\n  var _useFormApi = useFormApi(),\\n      getOptions = _useFormApi.getOptions; // Grap the schema\\n\\n\\n  var _getOptions = getOptions(),\\n      schema = _getOptions.schema;\\n\\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(FormFields, {\\n    schema: schema\\n  });\\n};\\n\\nvar withFormApi = function withFormApi(Component) {\\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.forwardRef(function (props, ref) {\\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(FormApiContext.Consumer, null, function (formApi) {\\n      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(Component, _extends({\\n        formApi: formApi,\\n        ref: ref\\n      }, props));\\n    });\\n  });\\n};\\n\\nvar withFormState = function withFormState(Component) {\\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.forwardRef(function (props, ref) {\\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(FormStateContext.Consumer, null, function (formState) {\\n      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(Component, _extends({\\n        formState: formState,\\n        ref: ref\\n      }, props));\\n    });\\n  });\\n};\\n\\nvar buildFieldApi = function buildFieldApi(formApi, field) {\\n  return {\\n    // TODO refactor to use field api from updater.. need to make sure this \\n    // will be stable\\n    getValue: function getValue() {\\n      return formApi.getValue(field);\\n    },\\n    setValue: function setValue(value) {\\n      return formApi.setValue(field, value);\\n    },\\n    getTouched: function getTouched() {\\n      return formApi.getTouched(field);\\n    },\\n    setTouched: function setTouched(value) {\\n      return formApi.setTouched(field, value);\\n    },\\n    getError: function getError() {\\n      return formApi.getError(field);\\n    },\\n    setError: function setError(value) {\\n      return formApi.setError(field, value);\\n    },\\n    reset: function reset() {\\n      return formApi.resetField(field);\\n    },\\n    validate: function validate() {\\n      return formApi.validateField(field);\\n    },\\n    exists: function exists() {\\n      return formApi.fieldExists(field);\\n    }\\n  };\\n};\\n\\nfunction useFieldApi(field) {\\n  var formApi = useFormApi();\\n  var fieldApi = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useMemo\"])(function () {\\n    return buildFieldApi(formApi, field);\\n  }, [field]);\\n  return fieldApi;\\n}\\n\\nvar buildFieldState = function buildFieldState(fieldApi) {\\n  return {\\n    value: fieldApi.getValue(),\\n    touched: fieldApi.getTouched(),\\n    error: fieldApi.getError()\\n  };\\n};\\n\\nfunction useFieldState(field) {\\n  var fieldApi = useFieldApi(field); // TODO find better way to get this to rerender\\n\\n  var formState = useFormState(); // The above is a temp hack\\n\\n  var fieldState = buildFieldState(fieldApi);\\n  return fieldState;\\n}\\n\\nvar withFieldState = function withFieldState(field) {\\n  return function (Component) {\\n    return function (props) {\\n      var fieldState = useFieldState(field);\\n      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(Component, _extends({\\n        fieldState: fieldState\\n      }, props));\\n    };\\n  };\\n};\\n\\nvar withFieldApi = function withFieldApi(field) {\\n  return function (Component) {\\n    return function (props) {\\n      var fieldApi = useFieldApi(field);\\n      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(Component, _extends({\\n        fieldApi: fieldApi\\n      }, props));\\n    };\\n  };\\n};\\n\\nvar Option = function Option(_ref) {\\n  var value = _ref.value,\\n      forwardedRef = _ref.forwardedRef,\\n      children = _ref.children,\\n      rest = _objectWithoutProperties(_ref, [\"value\", \"forwardedRef\", \"children\"]);\\n\\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"option\", _extends({\\n    ref: forwardedRef,\\n    value: value,\\n    key: value\\n  }, rest), children);\\n};\\n\\nvar Input = Text$1;\\n\\n\\n\\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../process/browser.js */ \"./node_modules/process/browser.js\")))//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW5mb3JtZWQvZGlzdC9lc20vaW5kZXguanM/ZjE0OCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQTRHO0FBQ3RFOztBQUV0QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkVBQTJFO0FBQzNFO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsdUJBQXVCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGVBQWUsNkJBQTZCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkNBQTZDLCtCQUErQjtBQUM1RTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsd0NBQXdDLFNBQVM7O0FBRWpEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixZQUFZLEVBQUU7QUFDaEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLHNCQUFzQjtBQUN2QztBQUNBLGNBQWM7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0NBQStDLEVBQUU7QUFDakQsMENBQTBDO0FBQzFDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUM7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRyxnQkFBZ0I7QUFDbkI7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxhQUFhO0FBQ3BGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLLEVBQUU7O0FBRVA7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsS0FBcUM7QUFDN0M7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCOztBQUVBLGdEQUFnRDs7QUFFaEQ7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FB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MUU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOzs7QUFHVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0I7O0FBRS9CO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFNBQVM7OztBQUdUOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0I7O0FBRS9CO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7O0FBRXhEO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLE9BQU87OztBQUdQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxpQkFBaUI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNB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O0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixxREFBTztBQUN4QjtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DOztBQUVwQyxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw0Q0FBSztBQUMvQjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsNENBQUs7QUFDL0I7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLDRDQUFLO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFa3FCIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2luZm9ybWVkL2Rpc3QvZXNtL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZUNvbnRleHQsIHVzZVJlZiwgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlTGF5b3V0RWZmZWN0LCB1c2VNZW1vLCBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdldmVudHMnO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuXG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgfSk7XG4gICAga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICB9XG5cbiAgcmV0dXJuIGtleXM7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQyKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuXG4gICAgaWYgKGkgJSAyKSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH07XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcblxuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG5cbiAgdHJ5IHtcbiAgICBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIga2V5LCBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcblxuICB2YXIgdGFyZ2V0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7XG5cbiAgdmFyIGtleSwgaTtcblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07XG4gICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICBpZiAoY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICByZXR1cm4gY2FsbDtcbiAgfVxuXG4gIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTtcblxuICByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7XG4gICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLFxuICAgICAgICByZXN1bHQ7XG5cbiAgICBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkge1xuICAgICAgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjtcblxuICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7XG4gIHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7XG59XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkoYXJyKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyO1xufVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgIShTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpKSByZXR1cm47XG4gIHZhciBfYXJyID0gW107XG4gIHZhciBfbiA9IHRydWU7XG4gIHZhciBfZCA9IGZhbHNlO1xuICB2YXIgX2UgPSB1bmRlZmluZWQ7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7XG4gICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xuXG4gICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfZCA9IHRydWU7XG4gICAgX2UgPSBlcnI7XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gX2Fycjtcbn1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG5cbiAgcmV0dXJuIGFycjI7XG59XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7XG4gIHZhciBpdDtcblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCBvW1N5bWJvbC5pdGVyYXRvcl0gPT0gbnVsbCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGlmIChpdCkgbyA9IGl0O1xuICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICB2YXIgRiA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzOiBGLFxuICAgICAgICBuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7XG4gICAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZTogb1tpKytdXG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9LFxuICAgICAgICBmOiBGXG4gICAgICB9O1xuICAgIH1cblxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbiAgfVxuXG4gIHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSxcbiAgICAgIGRpZEVyciA9IGZhbHNlLFxuICAgICAgZXJyO1xuICByZXR1cm4ge1xuICAgIHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGl0ID0gb1tTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgfSxcbiAgICBuOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc3RlcCA9IGl0Lm5leHQoKTtcbiAgICAgIG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7XG4gICAgICByZXR1cm4gc3RlcDtcbiAgICB9LFxuICAgIGU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICBkaWRFcnIgPSB0cnVlO1xuICAgICAgZXJyID0gZTtcbiAgICB9LFxuICAgIGY6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdC5yZXR1cm4gIT0gbnVsbCkgaXQucmV0dXJuKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21tb25qc01vZHVsZShmbiwgbW9kdWxlKSB7XG5cdHJldHVybiBtb2R1bGUgPSB7IGV4cG9ydHM6IHt9IH0sIGZuKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMpLCBtb2R1bGUuZXhwb3J0cztcbn1cblxudmFyIGRlYnVnID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuLyoqXG4gKiBcbiAqIEkgc3RvbGUgbW9zdCBvZiB0aGlzIGNvZGUgZnJvbSB0aGUgZGVidWcgbGliXG4gKiBodHRwczovL2dpdGh1Yi5jb20vdmlzaW9ubWVkaWEvZGVidWdcbiAqIFxuICogSnVzdCB3YW50ZWQgaXQgdG8gYmUgZWFzeSB0byBkZWJ1ZyB3aXRob3V0IHJlbHlpbmcgb24gdGhlIGRlcGVuZGVuY3khXG4gKi9cblxuLyoqXG5cdCogU2VsZWN0cyBhIGNvbG9yIGZvciBhIGRlYnVnIG5hbWVzcGFjZVxuICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2UgVGhlIG5hbWVzcGFjZSBzdHJpbmcgZm9yIHRoZSBmb3IgdGhlIGRlYnVnIGluc3RhbmNlIHRvIGJlIGNvbG9yZWRcbiAgKiBAcGFyYW0ge1N0cmluZ30gY29sb3JzIGNvbG9yIHBhbGxldHRlIHRvIGNob29zZSBmcm9tXG5cdCogQHJldHVybiB7TnVtYmVyfFN0cmluZ30gQW4gQU5TSSBjb2xvciBjb2RlIGZvciB0aGUgZ2l2ZW4gbmFtZXNwYWNlXG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5mdW5jdGlvbiBzZWxlY3RDb2xvcihuYW1lc3BhY2UsIGNvbG9ycykge1xuICB2YXIgaGFzaCA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lc3BhY2UubGVuZ3RoOyBpKyspIHtcbiAgICBoYXNoID0gKGhhc2ggPDwgNSkgLSBoYXNoICsgbmFtZXNwYWNlLmNoYXJDb2RlQXQoaSk7XG4gICAgaGFzaCB8PSAwOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcbiAgfVxuXG4gIHJldHVybiBjb2xvcnNbTWF0aC5hYnMoaGFzaCkgJSBjb2xvcnMubGVuZ3RoXTtcbn1cbi8qKlxuICogQWRkcyBBTlNJIGNvbG9yIGVzY2FwZSBjb2RlcyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuXG5mdW5jdGlvbiBmb3JtYXROb2RlQXJncyhhcmdzLCBjb25maWcpIHtcbiAgdmFyIG5hbWUgPSBjb25maWcubmFtZXNwYWNlO1xuXG4gIGlmIChjb25maWcudXNlQ29sb3JzKSB7XG4gICAgdmFyIGMgPSBjb25maWcuY29sb3I7XG4gICAgdmFyIGNvbG9yQ29kZSA9IFwiXFx4MUJbM1wiICsgKGMgPCA4ID8gYyA6ICc4OzU7JyArIGMpO1xuICAgIHZhciBwcmVmaXggPSBcIiAgXCIuY29uY2F0KGNvbG9yQ29kZSwgXCI7MW1cIikuY29uY2F0KG5hbWUsIFwiIFxceDFCWzBtXCIpO1xuICAgIGFyZ3NbMF0gPSBwcmVmaXggKyBhcmdzWzBdLnNwbGl0KCdcXG4nKS5qb2luKCdcXG4nICsgcHJlZml4KTtcbiAgfSBlbHNlIHtcbiAgICBhcmdzWzBdID0gbmFtZSArICcgJyArIGFyZ3NbMF07XG4gIH1cbn1cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqL1xuXG5cbmZ1bmN0aW9uIGZvcm1hdEJyb3dzZXJBcmdzKGFyZ3MsIGNvbmZpZykge1xuICBhcmdzWzBdID0gKGNvbmZpZy51c2VDb2xvcnMgPyAnJWMnIDogJycpICsgY29uZmlnLm5hbWVzcGFjZTtcblxuICBpZiAoIWNvbmZpZy51c2VDb2xvcnMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgYyA9ICdjb2xvcjogJyArIGNvbmZpZy5jb2xvcjsgLy8gVGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcbiAgLy8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuICAvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cblxuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGFzdEMgPSAwO1xuICBhcmdzWzBdLnJlcGxhY2UoLyVbYS16QS1aJV0vZywgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgaWYgKG1hdGNoID09PSAnJSUnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaW5kZXgrKztcblxuICAgIGlmIChtYXRjaCA9PT0gJyVjJykge1xuICAgICAgLy8gV2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG4gICAgICAvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuICAgICAgbGFzdEMgPSBpbmRleDtcbiAgICB9XG4gIH0pO1xuICBhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG59XG5cbnZhciBicm93c2VyQ29sb3JzID0gWycjMDAwMENDJywgJyMwMDAwRkYnLCAnIzAwMzNDQycsICcjMDAzM0ZGJywgJyMwMDY2Q0MnLCAnIzAwNjZGRicsICcjMDA5OUNDJywgJyMwMDk5RkYnLCAnIzAwQ0MwMCcsICcjMDBDQzMzJywgJyMwMENDNjYnLCAnIzAwQ0M5OScsICcjMDBDQ0NDJywgJyMwMENDRkYnLCAnIzMzMDBDQycsICcjMzMwMEZGJywgJyMzMzMzQ0MnLCAnIzMzMzNGRicsICcjMzM2NkNDJywgJyMzMzY2RkYnLCAnIzMzOTlDQycsICcjMzM5OUZGJywgJyMzM0NDMDAnLCAnIzMzQ0MzMycsICcjMzNDQzY2JywgJyMzM0NDOTknLCAnIzMzQ0NDQycsICcjMzNDQ0ZGJywgJyM2NjAwQ0MnLCAnIzY2MDBGRicsICcjNjYzM0NDJywgJyM2NjMzRkYnLCAnIzY2Q0MwMCcsICcjNjZDQzMzJywgJyM5OTAwQ0MnLCAnIzk5MDBGRicsICcjOTkzM0NDJywgJyM5OTMzRkYnLCAnIzk5Q0MwMCcsICcjOTlDQzMzJywgJyNDQzAwMDAnLCAnI0NDMDAzMycsICcjQ0MwMDY2JywgJyNDQzAwOTknLCAnI0NDMDBDQycsICcjQ0MwMEZGJywgJyNDQzMzMDAnLCAnI0NDMzMzMycsICcjQ0MzMzY2JywgJyNDQzMzOTknLCAnI0NDMzNDQycsICcjQ0MzM0ZGJywgJyNDQzY2MDAnLCAnI0NDNjYzMycsICcjQ0M5OTAwJywgJyNDQzk5MzMnLCAnI0NDQ0MwMCcsICcjQ0NDQzMzJywgJyNGRjAwMDAnLCAnI0ZGMDAzMycsICcjRkYwMDY2JywgJyNGRjAwOTknLCAnI0ZGMDBDQycsICcjRkYwMEZGJywgJyNGRjMzMDAnLCAnI0ZGMzMzMycsICcjRkYzMzY2JywgJyNGRjMzOTknLCAnI0ZGMzNDQycsICcjRkYzM0ZGJywgJyNGRjY2MDAnLCAnI0ZGNjYzMycsICcjRkY5OTAwJywgJyNGRjk5MzMnLCAnI0ZGQ0MwMCcsICcjRkZDQzMzJ107XG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvYWRCcm93c2VyKCkge1xuICB2YXIgbmFtZXNwYWNlcztcblxuICB0cnkge1xuICAgIG5hbWVzcGFjZXMgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnZGVidWcnKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsvLyBTd2FsbG93XG4gICAgLy8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG4gIH0gLy8gSWYgZGVidWcgaXNuJ3Qgc2V0IGluIExTLCBhbmQgd2UncmUgaW4gRWxlY3Ryb24sIHRyeSB0byBsb2FkICRERUJVR1xuXG5cbiAgaWYgKCFuYW1lc3BhY2VzICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZW52JyBpbiBwcm9jZXNzKSB7XG4gICAgbmFtZXNwYWNlcyA9IHByb2Nlc3MuZW52LkRFQlVHO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lc3BhY2VzOiBuYW1lc3BhY2VzIHx8ICcnLFxuICAgIGNvbG9yczogYnJvd3NlckNvbG9ycyxcbiAgICB1c2VDb2xvcnM6IHRydWUsXG4gICAgZm9ybWF0QXJnczogZm9ybWF0QnJvd3NlckFyZ3NcbiAgfTtcbn1cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBsb2FkTm9kZSgpIHtcbiAgcmV0dXJuIHtcbiAgICBuYW1lc3BhY2VzOiBwcm9jZXNzLmVudi5ERUJVRyB8fCAnJyxcbiAgICBjb2xvcnM6IFs2LCAyLCAzLCA0LCA1LCAxXSxcbiAgICB1c2VDb2xvcnM6IHRydWUsXG4gICAgZm9ybWF0QXJnczogZm9ybWF0Tm9kZUFyZ3NcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTG9nZ2VyKCkge1xuICB2YXIgcHJlZml4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBudWxsO1xuICB2YXIgY29uZmlnID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIGlmIChwcmVmaXgpIHtcbiAgICAgIGFyZ3MudW5zaGlmdChwcmVmaXgpO1xuICAgIH0gLy8gQ3JlYXRlIGEgbmFtZXNwYWNlIHJlZ2V4IGZvciBlYWNoIG5hbWVzcGFjZVxuXG5cbiAgICB2YXIgbWF0Y2hlcyA9IGNvbmZpZy5uYW1lc3BhY2VzLnNwbGl0KCcsJykubWFwKGZ1bmN0aW9uIChuYW1lc3BhY2UpIHtcbiAgICAgIC8vIFJlbW92ZSB3aWxkY2FyZCBhbmQgYWRkIHRvIHJlZ2V4IGlmIHdpbGRjYXJkXG4gICAgICBpZiAobmFtZXNwYWNlW25hbWVzcGFjZS5sZW5ndGggLSAxXSA9PT0gJyonKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZS5zbGljZSgwLCBuYW1lc3BhY2UubGVuZ3RoIC0gMSkgKyAnLionICsgJyQnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlICsgJyQnKTtcbiAgICB9KTsgLy8gRG9lcyB0aGUgcHJlZml4IG1hdGNoIGEgbmFtZXNwYWNlXG5cbiAgICB2YXIgbWF0Y2ggPSBtYXRjaGVzLnNvbWUoZnVuY3Rpb24gKHJlZ2V4KSB7XG4gICAgICByZXR1cm4gcmVnZXgudGVzdChwcmVmaXgpO1xuICAgIH0pO1xuICAgIHZhciBjb25mID0ge1xuICAgICAgY29sb3I6IHNlbGVjdENvbG9yKHByZWZpeCwgY29uZmlnLmNvbG9ycyksXG4gICAgICBuYW1lc3BhY2U6IHByZWZpeCxcbiAgICAgIHVzZUNvbG9yczogY29uZmlnLnVzZUNvbG9yc1xuICAgIH07XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBtYXRjaCkge1xuICAgICAgdmFyIF9jb25zb2xlO1xuXG4gICAgICBjb25maWcuZm9ybWF0QXJncyhhcmdzLCBjb25mKTtcblxuICAgICAgKF9jb25zb2xlID0gY29uc29sZSkubG9nLmFwcGx5KF9jb25zb2xlLCBhcmdzKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIG5vZGVMb2dnZXIocHJlZml4KSB7XG4gIHJldHVybiBjcmVhdGVMb2dnZXIocHJlZml4LCBsb2FkTm9kZSgpKTtcbn1cblxuZnVuY3Rpb24gYnJvd3NlckxvZ2dlcihwcmVmaXgpIHtcbiAgcmV0dXJuIGNyZWF0ZUxvZ2dlcihwcmVmaXgsIGxvYWRCcm93c2VyKCkpO1xufVxuLyoqXG4gKiBEZXRlY3QgRWxlY3Ryb24gcmVuZGVyZXIgLyBud2pzIHByb2Nlc3MsIHdoaWNoIGlzIG5vZGUsIGJ1dCB3ZSBzaG91bGRcbiAqIHRyZWF0IGFzIGEgYnJvd3Nlci5cbiAqL1xuXG5cbmlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInIHx8IHByb2Nlc3MuYnJvd3NlciA9PT0gdHJ1ZSB8fCBwcm9jZXNzLl9fbndqcykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGJyb3dzZXJMb2dnZXI7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IG5vZGVMb2dnZXI7XG59XG59KTtcblxudmFyIGRlYnVnJDEgPSBkZWJ1ZygnaW5mb3JtZWQ6T2JqTWFwJyArICdcXHQnKTtcbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tIHRvUGF0aCAtLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG52YXIgbGR0b1BhdGggPSBmdW5jdGlvbiBsZHRvUGF0aCgpIHtcbiAgdmFyIHBhdGggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICcnO1xuICByZXR1cm4gU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlLmNhbGwocGF0aCwgL1xcWycoLis/KSdcXF0vZywgJy4kMScpLnNwbGl0KC9bLFtcXF0uXSs/LykuZmlsdGVyKEJvb2xlYW4pO1xufTtcbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLSBnZXQgLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblxudmFyIGxkZ2V0ID0gZnVuY3Rpb24gbGRnZXQob2JqKSB7XG4gIHZhciBwYXRoID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnJztcbiAgdmFyIGRlZmF1bHRWYWx1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICB2YXIgcmVzdWx0ID0gU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlLmNhbGwocGF0aCwgL1xcWycoLis/KSdcXF0vZywgJy4kMScpLnNwbGl0KC9bLFtcXF0uXSs/LykuZmlsdGVyKEJvb2xlYW4pLnJlZHVjZShmdW5jdGlvbiAocmVzLCBrZXkpIHtcbiAgICByZXR1cm4gcmVzICE9PSBudWxsICYmIHJlcyAhPT0gdW5kZWZpbmVkID8gcmVzW2tleV0gOiByZXM7XG4gIH0sIG9iaik7XG4gIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCB8fCByZXN1bHQgPT09IG9iaiA/IGRlZmF1bHRWYWx1ZSA6IHJlc3VsdDtcbn07XG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0gaGFzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuLy8gZm9vIC0tPlxuLy8gZm9vLmJhciAtLT4gZm9vXG4vLyBmb28uYmFyWzNdIC0tPiBmb28uYmFyXG4vLyBmb28uYmFyLmJhelsyXS5yYXoudGF6WzVdLmxheiAtLT4gZm9vLmJhci5iYXpbMl0ucmF6LnRhels1XVxuXG5cbnZhciBwYXJlbnRQYXRoID0gZnVuY3Rpb24gcGFyZW50UGF0aChwYXRoKSB7XG4gIHJldHVybiBcIi5cIi5jb25jYXQocGF0aCkucmVwbGFjZSgvKC4qKVsuW10uKi8sICckMScpLnJlcGxhY2UoL1xcLi8sICcnKTtcbn07IC8vIGZvbyAtLT4gZm9vXG4vLyBmb28uYmFyIC0tPiBiYXJcbi8vIGZvby5iYXJbM10gLS0+IFszXVxuLy8gZm9vLmJhci5iYXpbMl0ucmF6LnRhels1XS5sYXogLS0+IGxhelxuXG5cbnZhciBwYXRoS2V5ID0gZnVuY3Rpb24gcGF0aEtleShwYXRoKSB7XG4gIHJldHVybiBwYXRoLnJlcGxhY2UocGFyZW50UGF0aChwYXRoKSwgJycpLnJlcGxhY2UoL1xcLi8sICcnKTtcbn07XG5cbnZhciBsZGhhcyA9IGZ1bmN0aW9uIGxkaGFzKG9iaiwgcGF0aCkge1xuICB2YXIgcFBhdGggPSBwYXJlbnRQYXRoKHBhdGgpO1xuICB2YXIga2V5ID0gcGF0aEtleShwYXRoKTsgLy8gSWYgd2UgaGF2ZSBwYXJlbnQgcGF0aCB0aGVuIGdldCB0aGUgb2JqZWN0IGF0IHRoYXQgbG9jYXRpb25cbiAgLy8gLi4gb3RoZXJ3aXNlIGl0cyB0aGUgcm9vdCBvYmplY3RcblxuICB2YXIgcGFyZW50T2JqID0gcFBhdGggPyBnZXQob2JqLCBwUGF0aCkgOiBvYmo7IC8vIElmIGl0cyBbM10gdHVybiBrZXkgaW50byAzXG5cbiAgcmV0dXJuICEhKHBhcmVudE9iaiAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChwYXJlbnRPYmosIGtleS5yZXBsYWNlKC9cXFsoLiopXFxdLywgJyQxJykpKTtcbn07XG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0gc2V0IC0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cbnZhciBsZHNldCA9IGZ1bmN0aW9uIGxkc2V0KG9iaikge1xuICB2YXIgcGF0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJyc7XG4gIHZhciB2YWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlLmNhbGwocGF0aCwgL1xcWycoLis/KSdcXF0vZywgJy4kMScpLnNwbGl0KC9bLFtcXF0uXSs/LykuZmlsdGVyKEJvb2xlYW4pLnJlZHVjZShmdW5jdGlvbiAocmVzLCBrZXksIGksIGFycikge1xuICAgIC8vY29uc29sZS5sb2coJ1JFUycsIHJlcywgJ0tleScsIGtleSwgJ0knLCBpLCAnQXJyJywgYXJyLCAnT0JKJywgb2JqKTtcbiAgICAvLyBBdCB0aGUgbGVhZiBzZXQgdGhlIHZhbHVlXG4gICAgaWYgKGkgPT09IGFyci5sZW5ndGggLSAxKSB7XG4gICAgICByZXNba2V5XSA9IHZhbDtcbiAgICAgIHJldHVybiByZXNba2V5XTtcbiAgICB9IC8vIEluaXRpYWxpemUgdG8gbmV3IGFycmF5IG9yIG9iamVjdCBpZiBuZWVkZWRcblxuXG4gICAgaWYgKHJlc1trZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKCthcnJbaSArIDFdKSkge1xuICAgICAgICByZXNba2V5XSA9IFtdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzW2tleV0gPSB7fTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc1trZXldO1xuICAgIH0gLy8gRXhjZXB0aW9uIGZvciBpZiB0aGUgdmFsdWUgaXMgY2hhbmdlaW5nIHRvIGFuIGFycmF5XG5cblxuICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKCthcnJbaSArIDFdKSAmJiAhQXJyYXkuaXNBcnJheShyZXNba2V5XSkpIHtcbiAgICAgIHJlc1trZXldID0gW107XG4gICAgfSAvL1RPRE8gZXhjZXB0aW9uIGZvciBpZiBvYmplY3QgPz9cbiAgICAvLyBPdGhlcndpc2Uga2VlcCB3aGF0cyB0aGVyZVxuXG5cbiAgICByZXR1cm4gcmVzW2tleV07XG4gIH0sIG9iaik7XG59O1xuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tIHVuc2V0IC0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cbnZhciBsZHVuc2V0ID0gZnVuY3Rpb24gbGR1bnNldChvYmopIHtcbiAgdmFyIHBhdGggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICcnO1xuICB2YXIgZm91bmQgPSBmYWxzZTtcbiAgU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlLmNhbGwocGF0aCwgL1xcWycoLis/KSdcXF0vZywgJy4kMScpLnNwbGl0KC9bLFtcXF0uXSs/LykuZmlsdGVyKEJvb2xlYW4pLnJlZHVjZShmdW5jdGlvbiAocmVzLCBrZXksIGksIGFycikge1xuICAgIC8vIEJhc2UgY2FzZSByZXMgaXMgdW5kZWZpbmVkXG4gICAgaWYgKHJlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0gLy8gQXQgdGhlIGxlYWYgZGVsZXRlIHRoZSB2YWx1ZVxuXG5cbiAgICBpZiAoaSA9PT0gYXJyLmxlbmd0aCAtIDEpIHtcbiAgICAgIGRlbGV0ZSByZXNba2V5XTtcbiAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgIHJldHVybiByZXNba2V5XTtcbiAgICB9IC8vIE90aGVyd2lzZSBrZWVwIGdvaW5nXG5cblxuICAgIHJldHVybiByZXNba2V5XTtcbiAgfSwgb2JqKTtcbiAgcmV0dXJuIGZvdW5kO1xufTtcbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLSBwdWxsQXQgLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblxudmFyIGxkcHVsbEF0ID0gZnVuY3Rpb24gbGRwdWxsQXQob2JqKSB7XG4gIHZhciBwYXRoID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnJztcbiAgdmFyIHB1bGxlZDtcbiAgU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlLmNhbGwocGF0aCwgL1xcWycoLis/KSdcXF0vZywgJy4kMScpLnNwbGl0KC9bLFtcXF0uXSs/LykuZmlsdGVyKEJvb2xlYW4pLnJlZHVjZShmdW5jdGlvbiAocmVzLCBrZXksIGksIGFycikge1xuICAgIC8vIEJhc2UgY2FzZSByZXMgaXMgdW5kZWZpbmVkXG4gICAgaWYgKHJlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0gLy8gQXQgdGhlIGxlYWYgZGVsZXRlIHRoZSB2YWx1ZVxuXG5cbiAgICBpZiAoaSA9PT0gYXJyLmxlbmd0aCAtIDEgJiYgQXJyYXkuaXNBcnJheShyZXMpKSB7XG4gICAgICAvLyBQdWxsIG91dCBvbmUgdmFsdWUgYXQgaW5kZXggKCBrZXkgKVxuICAgICAgcHVsbGVkID0gcmVzLnNwbGljZShrZXksIDEpO1xuICAgICAgcmV0dXJuIHJlc1trZXldO1xuICAgIH0gLy8gT3RoZXJ3aXNlIGtlZXAgZ29pbmdcblxuXG4gICAgcmV0dXJuIHJlc1trZXldO1xuICB9LCBvYmopO1xuICByZXR1cm4gcHVsbGVkO1xufTtcbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLSB2YWx1ZXMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblxudmFyIGxkdmFsdWVzID0gZnVuY3Rpb24gbGR2YWx1ZXMoKSB7XG4gIHZhciBvYmogPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICB2YXIgcHJvcHMgPSBPYmplY3Qua2V5cyhvYmopO1xuICByZXR1cm4gcHJvcHMubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gb2JqW2tleV07XG4gIH0pO1xufTtcblxudmFyIHBhdGhUb0FycmF5RWxlbSA9IGZ1bmN0aW9uIHBhdGhUb0FycmF5RWxlbShwYXRoKSB7XG4gIHZhciBwYXRoQXJyYXkgPSBsZHRvUGF0aChwYXRoKTtcbiAgcmV0dXJuIE51bWJlci5pc0ludGVnZXIoK3BhdGhBcnJheVtwYXRoQXJyYXkubGVuZ3RoIC0gMV0pO1xufTtcblxudmFyIE9iamVjdE1hcCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE9iamVjdE1hcCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgT2JqZWN0TWFwKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhPYmplY3RNYXAsIG51bGwsIFt7XG4gICAga2V5OiBcImVtcHR5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVtcHR5KG9iamVjdCkge1xuICAgICAgcmV0dXJuIGxkdmFsdWVzKG9iamVjdCkubGVuZ3RoID09PSAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0KG9iamVjdCwgcGF0aCkge1xuICAgICAgdmFyIHZhbCA9IGxkZ2V0KG9iamVjdCwgcGF0aCk7IC8vZGVidWcoJ0dPVCcsIHBhdGgsIHZhbCk7XG5cbiAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXMob2JqZWN0LCBwYXRoKSB7XG4gICAgICByZXR1cm4gbGRoYXMob2JqZWN0LCBwYXRoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldChvYmplY3QsIHBhdGgsIHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkZWJ1ZyQxKCdTRVRUSU5HJywgcGF0aCwgdmFsdWUpO1xuICAgICAgICBsZHNldChvYmplY3QsIHBhdGgsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFNldHRpbmcgdGhpbmdzIHRvIHVuZGVmaW5lZCBpbiBpbmZvcm1lZCBpcyBzcGVjaWFsIVxuICAgICAgICAvLyBzbyBpbiB0aGlzIGVsc2Ugc3RhdGVtZW50IHdlIGRlYWwgd2l0aCB0aGF0XG4gICAgICAgIC8vIElmIHRoZSBwYXRoIGlzIHRvIGFuIGFycmF5IGxlYWYgdGhlbiB3ZSB3YW50IHRvIHNldCB0byB1bmRlZmluZWRcbiAgICAgICAgLy8gRXhhbXBsZTpcbiAgICAgICAgLy8gcGF0aCA9ICdmb28uYmFyWzJdJ1xuICAgICAgICAvLyBmb28uYmFyID0gWyAnYmF6JywgJ3JheicsICd0YXonIF1cbiAgICAgICAgLy8gc2V0dGluZyB0YXogdG8gdW5kZWZpbmVkICAgXl5eXG4gICAgICAgIGlmIChwYXRoVG9BcnJheUVsZW0ocGF0aCkgJiYgT2JqZWN0TWFwLmdldChvYmplY3QsIHBhdGgpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBkZWJ1ZyQxKCdTcGVjaWFsIGNhc2UgU0VUVElORycsIHBhdGgsICd0byB1bmRlZmluZWQnKTtcbiAgICAgICAgICBsZHNldChvYmplY3QsIHBhdGgsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgdmFyIHBhdGhBcnJheSA9IGxkdG9QYXRoKHBhdGgpO1xuICAgICAgICAgIHBhdGhBcnJheSA9IHBhdGhBcnJheS5zbGljZSgwLCBwYXRoQXJyYXkubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgY2xlYW51cChvYmplY3QsIHBhdGhBcnJheSk7XG4gICAgICAgIH0gLy8gT25seSBkZWxldGUgdGhlIGZpZWxkIGlmIGl0IG5lZWRzIHRvIGJlIGRlbGV0ZWQgYW5kIGl0cyBub3QgYSBwYXRoIHRvIGFuIGFycmF5ICggYXJyYXkgbGVhZiApXG4gICAgICAgIC8vIEV4YW1wbGU6XG4gICAgICAgIC8vIHBhdGggPSAnZm9vLmJhcidcbiAgICAgICAgLy8gZm9vLmJhciA9ICdiYXonXG4gICAgICAgIC8vIHJlbW92aW5nIGZvby5iYXIgZnJvbSB0aGUgb2JqZWN0IGNvbXBsZXRsZXlcbiAgICAgICAgZWxzZSBpZiAoIXBhdGhUb0FycmF5RWxlbShwYXRoKSAmJiBPYmplY3RNYXAuZ2V0KG9iamVjdCwgcGF0aCkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGVidWckMSgnU3BlY2lhbCBjYXNlIFJFTU9WSU5HJywgcGF0aCwgJ2Zyb20gb2JqZWN0IGNvbXBsZXRsZXknKTtcbiAgICAgICAgICAgIE9iamVjdE1hcFtcImRlbGV0ZVwiXShvYmplY3QsIHBhdGgpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVsZXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZWxldGUob2JqZWN0LCBwYXRoKSB7XG4gICAgICBkZWJ1ZyQxKCdERUxFVEUnLCBwYXRoKTsgLy8gU3BlY2lhbCBjYXNlIGZvciBhcnJheXNcblxuICAgICAgaWYgKHBhdGhUb0FycmF5RWxlbShwYXRoKSkge1xuICAgICAgICBkZWJ1ZyQxKCdBUlJBWScsIHBhdGgpOyAvL2xkdW5zZXQob2JqZWN0LCBwYXRoKTtcblxuICAgICAgICB0aGlzLnB1bGxPdXQob2JqZWN0LCBwYXRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxkdW5zZXQob2JqZWN0LCBwYXRoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHBhdGhBcnJheSA9IGxkdG9QYXRoKHBhdGgpO1xuICAgICAgcGF0aEFycmF5ID0gcGF0aEFycmF5LnNsaWNlKDAsIHBhdGhBcnJheS5sZW5ndGggLSAxKTtcbiAgICAgIGNsZWFudXAob2JqZWN0LCBwYXRoQXJyYXkpO1xuICAgIH0gLy8gVmVyeSBpbXBvcnRhbnQgOylcblxuICB9LCB7XG4gICAga2V5OiBcInB1bGxPdXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHVsbE91dChvYmplY3QsIHBhdGgpIHtcbiAgICAgIC8vIEdldCB0aGUgcGF0aCB0byB0aGUgYXJyYXlcbiAgICAgIHZhciBwYXRoQXJyYXkgPSBsZHRvUGF0aChwYXRoKTsgLy8gZGVidWcoJ1BhdGhBcnJheTEnLCBwYXRoQXJyYXkpO1xuXG4gICAgICB2YXIgaW5kZXggPSBwYXRoQXJyYXlbcGF0aEFycmF5Lmxlbmd0aCAtIDFdO1xuICAgICAgcGF0aEFycmF5ID0gcGF0aEFycmF5LnNsaWNlKDAsIHBhdGhBcnJheS5sZW5ndGggLSAxKTtcbiAgICAgIGRlYnVnJDEoJ1B1bGxpbmcgb3V0OicsIHBhdGhBcnJheSwgJ2luZGV4JywgaW5kZXgpOyAvLyBHZXQgdGhlIGFycmF5XG5cbiAgICAgIHZhciBhcnIgPSBsZGdldChvYmplY3QsIHBhdGhBcnJheSk7XG4gICAgICBkZWJ1ZyQxKCdBcnJheScsIGFycik7IC8vIFB1bGwgb3V0IG9mIGFycmF5XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICAgICAgbGRwdWxsQXQoYXJyLCBpbmRleCk7XG4gICAgICB9XG5cbiAgICAgIGNsZWFudXAob2JqZWN0LCBwYXRoQXJyYXkpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBPYmplY3RNYXA7XG59KCk7XG5cbmZ1bmN0aW9uIGNsZWFudXAob2JqLCBwYXRoKSB7XG5cbiAgLy8gQmFzZSBjYXNlIG5vIHBhdGggbGVmdFxuICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgb2JqZWN0ID0gbGRnZXQob2JqLCBwYXRoKTsgLy8gQ2xlYW4gdXAgdW5kZWZpbmVkIGZyb20gYXJyYXlcbiAgLy8gaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSAmJiBwdWxsKSB7XG4gIC8vICAgbGRwdWxsKG9iamVjdCwgdW5kZWZpbmVkKTtcbiAgLy8gfVxuICAvLyBEZWxldGUgb2JqZWN0IGlmIGl0cyBlbXB0eVxuXG4gIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkgPyBvYmplY3QuZXZlcnkoZnVuY3Rpb24gKGUpIHtcbiAgICByZXR1cm4gZSA9PSBudWxsO1xuICB9KSA6IEpTT04uc3RyaW5naWZ5KG9iamVjdCkgPT09ICd7fScpIHtcbiAgICBsZHVuc2V0KG9iaiwgcGF0aCk7XG4gIH0gLy8gUmVjdXJcblxuXG4gIGNsZWFudXAob2JqLCBwYXRoLnNsaWNlKDAsIHBhdGgubGVuZ3RoIC0gMSkpO1xufVxuXG52YXIgRm9ybVJlZ2lzdGVyQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KHtcbiAgcmVnaXN0ZXI6IGZ1bmN0aW9uIHJlZ2lzdGVyKCkge30sXG4gIGRlcmVnaXN0ZXI6IGZ1bmN0aW9uIGRlcmVnaXN0ZXIoKSB7fSxcbiAgc2V0VmFsdWU6IGZ1bmN0aW9uIHNldFZhbHVlKCkge30sXG4gIHNldFRvdWNoZWQ6IGZ1bmN0aW9uIHNldFRvdWNoZWQoKSB7fSxcbiAgc2V0RXJyb3I6IGZ1bmN0aW9uIHNldEVycm9yKCkge30sXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKCkge30sXG4gIGdldEZpZWxkOiBmdW5jdGlvbiBnZXRGaWVsZCgpIHt9LFxuICBleHBlY3RSZW1vdmFsOiBmdW5jdGlvbiBleHBlY3RSZW1vdmFsKCkge30sXG4gIGdldEluaXRpYWxWYWx1ZTogZnVuY3Rpb24gZ2V0SW5pdGlhbFZhbHVlKCkge31cbn0pO1xudmFyIEZvcm1TdGF0ZUNvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dCh7fSk7XG52YXIgRm9ybUFwaUNvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dCh7XG4gIGdldEZ1bGxGaWVsZDogZnVuY3Rpb24gZ2V0RnVsbEZpZWxkKCkge30sXG4gIGdldFZhbHVlczogZnVuY3Rpb24gZ2V0VmFsdWVzKCkge30sXG4gIGdldE9wdGlvbnM6IGZ1bmN0aW9uIGdldE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9LFxuICBzZXRJbml0aWFsVmFsdWU6IGZ1bmN0aW9uIHNldEluaXRpYWxWYWx1ZSgpIHt9LFxuICBnZXRJbml0aWFsVmFsdWU6IGZ1bmN0aW9uIGdldEluaXRpYWxWYWx1ZSgpIHt9LFxuICBnZXREZXJyaXZlZFZhbHVlOiBmdW5jdGlvbiBnZXREZXJyaXZlZFZhbHVlKCkge30sXG4gIGdldFNhdmVkVmFsdWU6IGZ1bmN0aW9uIGdldFNhdmVkVmFsdWUoKSB7fSxcbiAgcmVtb3ZlU2F2ZWRTdGF0ZTogZnVuY3Rpb24gcmVtb3ZlU2F2ZWRTdGF0ZSgpIHt9XG59KTtcbnZhciBHcm91cENvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dCgpO1xudmFyIEFycmF5RmllbGRTdGF0ZUNvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dCgpO1xudmFyIEFycmF5RmllbGRBcGlDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQoKTtcbnZhciBBcnJheUZpZWxkSXRlbUFwaUNvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dCgpO1xudmFyIEFycmF5RmllbGRJdGVtU3RhdGVDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQoKTtcbnZhciBNdWx0aXN0ZXBTdGF0ZUNvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dCgpO1xudmFyIE11bHRpc3RlcEFwaUNvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dCgpO1xudmFyIE11bHRpc3RlcFN0ZXBDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQoKTtcblxuZnVuY3Rpb24gdXNlRm9ybUFwaSgpIHtcbiAgdmFyIGZvcm1BcGkgPSB1c2VDb250ZXh0KEZvcm1BcGlDb250ZXh0KTtcbiAgcmV0dXJuIGZvcm1BcGk7XG59XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTQ1NDNcblxuZnVuY3Rpb24gdXNlU3RhdGVXaXRoR2V0dGVyKGluaXRpYWwpIHtcbiAgdmFyIHJlZiA9IHVzZVJlZigpO1xuICB2YXIgbW91bnRlZCA9IHVzZVJlZih0cnVlKTtcblxuICB2YXIgX3VzZVN0YXRlID0gdXNlU3RhdGUoaW5pdGlhbCksXG4gICAgICBfdXNlU3RhdGUyID0gX3NsaWNlZFRvQXJyYXkoX3VzZVN0YXRlLCAyKSxcbiAgICAgIHN0YXRlID0gX3VzZVN0YXRlMlswXSxcbiAgICAgIHNldFN0YXRlID0gX3VzZVN0YXRlMlsxXTtcblxuICByZWYuY3VycmVudCA9IHN0YXRlO1xuXG4gIHZhciBzZXQgPSBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICByZWYuY3VycmVudCA9IHZhbHVlO1xuICAgIGlmIChtb3VudGVkLmN1cnJlbnQpIHNldFN0YXRlKHZhbHVlKTtcbiAgfTtcblxuICB2YXIgZ2V0ID0gZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiByZWYuY3VycmVudDtcbiAgfTtcblxuICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBtb3VudGVkLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9O1xuICB9LCBbXSk7XG4gIHJldHVybiBbc3RhdGUsIHNldCwgZ2V0XTtcbn1cblxudmFyIGdldENoaWxkRGlzcGxheU5hbWUgPSBmdW5jdGlvbiBnZXRDaGlsZERpc3BsYXlOYW1lKFdyYXBwZWRDb21wb25lbnQpIHtcbiAgLy8gZml4IGZvciBcIm1lbW9cIiBjb21wb25lbnRzXG4gIGlmIChXcmFwcGVkQ29tcG9uZW50LnR5cGUgJiYgV3JhcHBlZENvbXBvbmVudC50eXBlLm5hbWUpIHtcbiAgICByZXR1cm4gV3JhcHBlZENvbXBvbmVudC50eXBlLm5hbWU7XG4gIH1cblxuICByZXR1cm4gV3JhcHBlZENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBXcmFwcGVkQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCc7XG59O1xudmFyIHl1cFRvRm9ybUVycm9ycyA9IGZ1bmN0aW9uIHl1cFRvRm9ybUVycm9ycyh5dXBFcnJvcikge1xuICB2YXIgZXJyb3JzID0ge307XG5cbiAgaWYgKHl1cEVycm9yLmlubmVyKSB7XG4gICAgaWYgKHl1cEVycm9yLmlubmVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gY29uc29sZS5sb2coeXVwRXJyb3IucGF0aCk7XG4gICAgICBPYmplY3RNYXAuc2V0KGVycm9ycywgeXVwRXJyb3IucGF0aCwgeXVwRXJyb3IubWVzc2FnZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHl1cEVycm9yLmlubmVyKSxcbiAgICAgICAgX3N0ZXA7XG5cbiAgICB0cnkge1xuICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIGVyciA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICAgIGlmICghT2JqZWN0TWFwLmdldChlcnJvcnMsIGVyci5wYXRoKSkge1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGVycm9ycywgZXJyLnBhdGgsIGVyci5tZXNzYWdlKTtcbiAgICAgICAgICBPYmplY3RNYXAuc2V0KGVycm9ycywgZXJyLnBhdGgsIGVyci5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZXJyb3JzO1xufTtcbnZhciB2YWxpZGF0ZVl1cFNjaGVtYSA9IGZ1bmN0aW9uIHZhbGlkYXRlWXVwU2NoZW1hKHNjaGVtYSwgdmFsdWVzKSB7XG4gIHRyeSB7XG4gICAgc2NoZW1hLnZhbGlkYXRlU3luYyh2YWx1ZXMsIHtcbiAgICAgIGFib3J0RWFybHk6IGZhbHNlXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB2YXIgZm9ybUVycm9ycyA9IHl1cFRvRm9ybUVycm9ycyhlKTtcbiAgICByZXR1cm4gZm9ybUVycm9ycztcbiAgfVxufTtcbnZhciB5dXBUb0Zvcm1FcnJvciA9IGZ1bmN0aW9uIHl1cFRvRm9ybUVycm9yKHl1cEVycm9yKSB7XG4gIGlmICh5dXBFcnJvci5pbm5lcikge1xuICAgIGlmICh5dXBFcnJvci5pbm5lci5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZXJyID0geXVwRXJyb3IuaW5uZXJbMF07XG4gICAgcmV0dXJuIGVyci5tZXNzYWdlO1xuICB9XG59O1xudmFyIHZhbGlkYXRlWXVwRmllbGQgPSBmdW5jdGlvbiB2YWxpZGF0ZVl1cEZpZWxkKHNjaGVtYSwgdmFsdWUpIHtcbiAgdHJ5IHtcbiAgICBzY2hlbWEudmFsaWRhdGVTeW5jKHZhbHVlLCB7XG4gICAgICBhYm9ydEVhcmx5OiBmYWxzZVxuICAgIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHl1cFRvRm9ybUVycm9yKGUpO1xuICB9XG59O1xudmFyIHZhbGlkYXRlQWp2U2NoZW1hID0gZnVuY3Rpb24gdmFsaWRhdGVBanZTY2hlbWEodmFsaWRhdGUsIGRhdGEpIHtcbiAgdmFsaWRhdGUoZGF0YSk7XG4gIHZhciBlcnJvcnMgPSB7fTtcblxuICBpZiAodmFsaWRhdGUuZXJyb3JzKSB7XG4gICAgdmFsaWRhdGUuZXJyb3JzLmZvckVhY2goZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgIHZhciBtZXNzYWdlID0gX3JlZi5tZXNzYWdlLFxuICAgICAgICAgIGRhdGFQYXRoID0gX3JlZi5kYXRhUGF0aCxcbiAgICAgICAgICBrZXl3b3JkID0gX3JlZi5rZXl3b3JkLFxuICAgICAgICAgIHBhcmFtcyA9IF9yZWYucGFyYW1zO1xuICAgICAgdmFyIHBhdGggPSBkYXRhUGF0aDsgLy8gU3BlY2lhbCBjYXNlIGZvciByZXF1aXJlZFxuXG4gICAgICBpZiAoa2V5d29yZCA9PT0gJ3JlcXVpcmVkJykge1xuICAgICAgICBwYXRoID0gXCJcIi5jb25jYXQocGF0aCwgXCIuXCIpLmNvbmNhdChwYXJhbXMubWlzc2luZ1Byb3BlcnR5KTtcbiAgICAgIH0gLy8gR2V0IHJpZCBvZiBsZWFkaW5nIGRvdFxuXG5cbiAgICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoJy4nLCAnJyk7IC8vIGNvbnNvbGUubG9nKCdQQVRIJywgcGF0aCwgbWVzc2FnZSk7XG4gICAgICAvLyBUT0RPIGdldCBtZXNzYWdlIGZyb20gaW5mb3JtZWQgaWYgcHJlc2VudFxuXG4gICAgICBPYmplY3RNYXAuc2V0KGVycm9ycywgcGF0aCwgbWVzc2FnZSk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gZXJyb3JzO1xufTsgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTA1MDM0L2NyZWF0ZS1ndWlkLXV1aWQtaW4tamF2YXNjcmlwdFxuXG52YXIgdXVpZHY0ID0gZnVuY3Rpb24gdXVpZHY0KCkge1xuICByZXR1cm4gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbiAoYykge1xuICAgIHZhciByID0gTWF0aC5yYW5kb20oKSAqIDE2IHwgMCxcbiAgICAgICAgdiA9IGMgPT0gJ3gnID8gciA6IHIgJiAweDMgfCAweDg7XG4gICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xuICB9KTtcbn07XG52YXIgY29tcHV0ZUZpZWxkRnJvbVByb3BlcnR5ID0gZnVuY3Rpb24gY29tcHV0ZUZpZWxkRnJvbVByb3BlcnR5KHByb3BlcnR5TmFtZSwgcHJvcGVydHksIHByZWZpeCkge1xuICB2YXIgdWlDb250cm9sID0gcHJvcGVydHlbJ3VpOmNvbnRyb2wnXSxcbiAgICAgIGluZm9ybWVkUHJvcHMgPSBwcm9wZXJ0eVsnaW5mb3JtZWQ6cHJvcHMnXSxcbiAgICAgIGlucHV0UHJvcHMgPSBwcm9wZXJ0eVsnaW5wdXQ6cHJvcHMnXSxcbiAgICAgIHVpQmVmb3JlID0gcHJvcGVydHlbJ3VpOmJlZm9yZSddLFxuICAgICAgdWlBZnRlciA9IHByb3BlcnR5Wyd1aTphZnRlciddLFxuICAgICAgb25lT2YgPSBwcm9wZXJ0eS5vbmVPZixcbiAgICAgIGl0ZW1zID0gcHJvcGVydHkuaXRlbXMsXG4gICAgICBzY2hlbWFFbnVtID0gcHJvcGVydHlbXCJlbnVtXCJdLFxuICAgICAgbGFiZWwgPSBwcm9wZXJ0eS50aXRsZSxcbiAgICAgIG1pbiA9IHByb3BlcnR5Lm1pbmltdW0sXG4gICAgICBtYXggPSBwcm9wZXJ0eS5tYXhpbXVtLFxuICAgICAgbWluTGVuZ3RoID0gcHJvcGVydHkubWluTGVuZ3RoLFxuICAgICAgbWF4TGVuZ3RoID0gcHJvcGVydHkubWF4TGVuZ3RoLFxuICAgICAgcGF0dGVybiA9IHByb3BlcnR5LnBhdHRlcm4sXG4gICAgICB0eXBlID0gcHJvcGVydHkudHlwZSxcbiAgICAgIHN1YlByb3BlcnRpZXMgPSBwcm9wZXJ0eS5wcm9wZXJ0aWVzOyAvLyBTZXQgSWQgaWYgbm90IHBhc3NlZFxuXG4gIHZhciBpZCA9IHV1aWR2NCgpO1xuXG4gIGlmIChpbnB1dFByb3BzICYmIGlucHV0UHJvcHMuaWQpIHtcbiAgICBpZCA9IGlucHV0UHJvcHMuaWQ7XG4gIH1cblxuICB2YXIgZmllbGQgPSB7XG4gICAgY29tcG9uZW50VHlwZTogdWlDb250cm9sLFxuICAgIGZpZWxkOiBwcmVmaXggPyBcIlwiLmNvbmNhdChwcmVmaXgsIFwiLlwiKS5jb25jYXQocHJvcGVydHlOYW1lKSA6IHByb3BlcnR5TmFtZSxcbiAgICB0eXBlOiB0eXBlLFxuICAgIHVpQmVmb3JlOiB1aUJlZm9yZSxcbiAgICB1aUFmdGVyOiB1aUFmdGVyLFxuICAgIHByb3BlcnRpZXM6IHR5cGUgPT09ICdvYmplY3QnID8gc3ViUHJvcGVydGllcyA6IHVuZGVmaW5lZCxcbiAgICBpdGVtczogdHlwZSA9PT0gJ2FycmF5JyA/IGl0ZW1zIDogdW5kZWZpbmVkLFxuICAgIHByb3BzOiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7XG4gICAgICBsYWJlbDogbGFiZWwsXG4gICAgICBpZDogaWQsXG4gICAgICBtaW46IG1pbixcbiAgICAgIG1heDogbWF4LFxuICAgICAgbWluTGVuZ3RoOiBtaW5MZW5ndGgsXG4gICAgICBtYXhMZW5ndGg6IG1heExlbmd0aCxcbiAgICAgIHBhdHRlcm46IHBhdHRlcm5cbiAgICB9LCBpbmZvcm1lZFByb3BzKSwgaW5wdXRQcm9wcylcbiAgfTtcblxuICBpZiAob25lT2YpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHByb3BlcnR5Lm9uZU9mLm1hcChmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgICB2YXIgX29wdGlvbiRpbnB1dFByb3BzID0gb3B0aW9uWydpbnB1dDpwcm9wcyddLFxuICAgICAgICAgIGlucHV0UHJvcHMgPSBfb3B0aW9uJGlucHV0UHJvcHMgPT09IHZvaWQgMCA/IHt9IDogX29wdGlvbiRpbnB1dFByb3BzO1xuICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQyKHtcbiAgICAgICAgdmFsdWU6IG9wdGlvbltcImNvbnN0XCJdLFxuICAgICAgICBsYWJlbDogb3B0aW9uLnRpdGxlXG4gICAgICB9LCBpbnB1dFByb3BzKTtcbiAgICB9KTtcbiAgICBmaWVsZC5wcm9wcy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuXG4gIGlmIChzY2hlbWFFbnVtKSB7XG4gICAgdmFyIF9vcHRpb25zID0gcHJvcGVydHlbXCJlbnVtXCJdLm1hcChmdW5jdGlvbiAodmFsKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdmFsLFxuICAgICAgICBsYWJlbDogdmFsXG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgZmllbGQucHJvcHMub3B0aW9ucyA9IF9vcHRpb25zO1xuICB9XG5cbiAgaWYgKGl0ZW1zICYmIGl0ZW1zLm9uZU9mKSB7XG4gICAgdmFyIF9vcHRpb25zMiA9IGl0ZW1zLm9uZU9mLm1hcChmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgICB2YXIgX29wdGlvbiRpbnB1dFByb3BzMiA9IG9wdGlvblsnaW5wdXQ6cHJvcHMnXSxcbiAgICAgICAgICBpbnB1dFByb3BzID0gX29wdGlvbiRpbnB1dFByb3BzMiA9PT0gdm9pZCAwID8ge30gOiBfb3B0aW9uJGlucHV0UHJvcHMyO1xuICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQyKHtcbiAgICAgICAgdmFsdWU6IG9wdGlvbltcImNvbnN0XCJdLFxuICAgICAgICBsYWJlbDogb3B0aW9uLnRpdGxlXG4gICAgICB9LCBpbnB1dFByb3BzKTtcbiAgICB9KTtcblxuICAgIGZpZWxkLnByb3BzLm9wdGlvbnMgPSBfb3B0aW9uczI7XG4gIH1cblxuICByZXR1cm4gZmllbGQ7XG59O1xudmFyIGNvbXB1dGVGaWVsZHNGcm9tU2NoZW1hID0gZnVuY3Rpb24gY29tcHV0ZUZpZWxkc0Zyb21TY2hlbWEoc2NoZW1hLCBvbmx5VmFsaWRhdGVTY2hlbWEsIHByZWZpeCkge1xuICBpZiAoIXNjaGVtYSB8fCBvbmx5VmFsaWRhdGVTY2hlbWEpIHtcbiAgICByZXR1cm4gW107XG4gIH0gLy8gR3JhYiBwcm9wZXJ0aWVzIGFuZCBpdGVtcyBvZmYgb2Ygc2NoZW1hXG5cblxuICB2YXIgX3NjaGVtYSRwcm9wZXJ0aWVzID0gc2NoZW1hLnByb3BlcnRpZXMsXG4gICAgICBwcm9wZXJ0aWVzID0gX3NjaGVtYSRwcm9wZXJ0aWVzID09PSB2b2lkIDAgPyB7fSA6IF9zY2hlbWEkcHJvcGVydGllcyxcbiAgICAgIGFsbE9mID0gc2NoZW1hLmFsbE9mLFxuICAgICAgX3NjaGVtYSRwcm9wZXJ0eU9yZGVyID0gc2NoZW1hLnByb3BlcnR5T3JkZXIsXG4gICAgICBwcm9wZXJ0eU9yZGVyID0gX3NjaGVtYSRwcm9wZXJ0eU9yZGVyID09PSB2b2lkIDAgPyBbXSA6IF9zY2hlbWEkcHJvcGVydHlPcmRlcjtcblxuICBpZiAoT2JqZWN0LmtleXMocHJvcGVydGllcykubGVuZ3RoID4gMCkge1xuICAgIC8vIEF0dGVtcHQgdG8gZ2VuZXJhdGUgZmllbGRzIGZyb20gcHJvcGVydGllc1xuICAgIHZhciBmaWVsZHMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICB2YXIgYUluZGV4ID0gcHJvcGVydHlPcmRlci5pbmRleE9mKGEpO1xuICAgICAgdmFyIGJJbmRleCA9IHByb3BlcnR5T3JkZXIuaW5kZXhPZihiKTtcbiAgICAgIHJldHVybiAoYUluZGV4ID4gLTEgPyBhSW5kZXggOiBwcm9wZXJ0eU9yZGVyLmxlbmd0aCArIDEpIC0gKGJJbmRleCA+IC0xID8gYkluZGV4IDogcHJvcGVydHlPcmRlci5sZW5ndGggKyAxKTtcbiAgICB9KS5tYXAoZnVuY3Rpb24gKHByb3BlcnR5TmFtZSkge1xuICAgICAgdmFyIHByb3BlcnR5ID0gcHJvcGVydGllc1twcm9wZXJ0eU5hbWVdO1xuICAgICAgdmFyIGZpZWxkID0gY29tcHV0ZUZpZWxkRnJvbVByb3BlcnR5KHByb3BlcnR5TmFtZSwgcHJvcGVydHksIHByZWZpeCk7XG4gICAgICByZXR1cm4gZmllbGQ7XG4gICAgfSk7IC8vIENoZWNrIGZvciBhbGwgb2YgKCB3ZSBoYXZlIGNvbmRpdGlvbmFscyApXG5cbiAgICBpZiAoYWxsT2YpIHtcbiAgICAgIGZpZWxkcy5wdXNoKHtcbiAgICAgICAgY29tcG9uZW50VHlwZTogJ2NvbmRpdGlvbmFscycsXG4gICAgICAgIC8vIEVhY2ggZWxlbWVudCBvZiB0aGUgXCJhbGxPZlwiIGFycmF5IGlzIGEgY29uZGl0aW9uYWxcbiAgICAgICAgYWxsT2Y6IGFsbE9mXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmllbGRzO1xuICB9XG5cbiAgcmV0dXJuIFtdO1xufTsgLy8gRXhhbXBsZXNcbi8vIGZpZWxkID0gXCJuYW1lXCIgLS0tPiBwcm9wZXJ0aWVzLm5hbWVcbi8vIGZpZWxkID0gXCJicm90aGVyLm5hbWVcIiAtLS0+IHByb3BlcnRpZXMuYnJvdGhlci5wcm9wZXJ0aWVzLm5hbWVcbi8vIGZpZWxkID0gXCJicm90aGVyLnNpYmxpbmdzWzFdLmZyaWVuZC5uYW1lXCIgLS0tPiBwcm9wZXJ0aWVzLmJyb3RoZXIucHJvcGVydGllcy5zaWJsaW5ncy5pdGVtc1sxXS5wcm9wZXJ0aWVzLmZyaWVuZC5wcm9wZXJ0aWVzLm5hbWVcblxudmFyIGdldFNjaGVtYVBhdGhGcm9tSnNvblBhdGggPSBmdW5jdGlvbiBnZXRTY2hlbWFQYXRoRnJvbUpzb25QYXRoKGpzb25QYXRoKSB7XG4gIC8vIENvbnZlcnRcbiAgdmFyIHNjaGVtYVBhdGggPSBqc29uUGF0aC5yZXBsYWNlKC9cXC4vZywgJy5wcm9wZXJ0aWVzLicpLnJlcGxhY2UoL1xcWy9nLCAnLml0bWVzWycpOyAvLyBBZGQgZmlyc3QgcHJvcGVydGllc1xuXG4gIHNjaGVtYVBhdGggPSBcInByb3BlcnRpZXMuXCIuY29uY2F0KHNjaGVtYVBhdGgpO1xuICByZXR1cm4gc2NoZW1hUGF0aDtcbn07XG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBGb3JtYXR0ZXIgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxudmFyIGdldEZvcm1hdHRlciA9IGZ1bmN0aW9uIGdldEZvcm1hdHRlcihmb3JtYXR0ZXIsIHZhbHVlKSB7XG4gIC8vIElmIG1hc2sgaXMgYSBzdHJpbmcgdHVybiBpdCBpbnRvIGFuIGFycmF5O1xuICBpZiAodHlwZW9mIGZvcm1hdHRlciA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZm9ybWF0dGVyLnNwbGl0KCcnKS5tYXAoZnVuY3Rpb24gKF9jaGFyKSB7XG4gICAgICBpZiAoX2NoYXIgPT09ICcjJykge1xuICAgICAgICByZXR1cm4gL1xcZC87XG4gICAgICB9XG5cbiAgICAgIGlmIChfY2hhciA9PT0gJyonKSB7XG4gICAgICAgIHJldHVybiAvW1xcd10vO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2NoYXI7XG4gICAgfSk7XG4gIH0gLy8gSWYgbWFzayBpcyBhIGZ1bmN0aW9uIHVzZSBpdCB0byBnZW5yZWF0ZSBjdXJyZW50IG1hc2tcblxuXG4gIGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZvcm1hdHRlcih2YWx1ZSk7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShmb3JtYXR0ZXIpKSB7XG4gICAgcmV0dXJuIGZvcm1hdHRlcjtcbiAgfSAvLyBTaG91bGQgbmV2ZXIgbWFrZSBpdCBoZXJlIHRocm93XG5cblxuICB0aHJvdyBuZXcgRXJyb3IoJ0Zvcm1hdHRlciBtdXN0IGJlIHN0cmluZywgYXJyYXksIG9yIGZ1bmN0aW9uJyk7XG59O1xuXG52YXIgbWF0Y2hpbmdJbmRleCA9IGZ1bmN0aW9uIG1hdGNoaW5nSW5kZXgoYSwgYikge1xuICB2YXIgaSA9IDA7XG4gIHZhciBtaSA9IC0xO1xuICB2YXIgbWF0Y2hpbmcgPSB0cnVlOyAvLyBhID0gXCIrMSBcIlxuICAvLyBiID0gXCIrMTJcIlxuXG4gIHdoaWxlIChtYXRjaGluZyAmJiBpIDwgYS5sZW5ndGgpIHtcbiAgICBpZiAoYVtpXSA9PSBiW2ldKSB7XG4gICAgICBtaSA9IGk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hdGNoaW5nID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaSA9IGkgKyAxO1xuICB9XG5cbiAgcmV0dXJuIG1pO1xufTtcblxudmFyIGluZm9ybWVkRm9ybWF0ID0gZnVuY3Rpb24gaW5mb3JtZWRGb3JtYXQodmFsdWUsIGZybXRyKSB7XG4gIC8vIGNvbnNvbGUubG9nKCdGb3JtYXR0aW5nJywgdmFsdWUpO1xuICAvLyBOdWxsIGNoZWNrXG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfTtcbiAgfSAvLyBHZW5lcmF0ZSBmb3JtYXR0ZXIgYXJyYXlcblxuXG4gIHZhciBmb3JtYXR0ZXIgPSBnZXRGb3JtYXR0ZXIoZnJtdHIsIHZhbHVlKTsgLy8gU3RhcnQgdG8gZmlsbCBpbiB0aGUgYXJyYXlcbiAgLy8gRXhhbXBsZTogcGhvbmUgZm9ybWF0dGVyXG4gIC8vIGZvcm1hdHRlciA9WycrJywgJzEnLCAnICcsIC9cXGQvLCAvXFxkLywgL1xcZC8sICctJywgL1xcZC8sIC9cXGQvLCAvXFxkLywgJy0nLCAvXFxkLywgL1xcZC8sIC9cXGQvLCAvXFxkL11cbiAgLy8gdmFsdWUgZXhhbXBsZXM6XG4gIC8vIFwiMTIzMTIzMTIzNCAtLS0tPiArMSAxMjMtMTIzLTEyMzRcbiAgLy8gXCIrXCIgXHRcdFx0XHQgLS0tLT4gK1xuICAvLyBcIisxXCIgXHRcdFx0IC0tLS0+ICsxXG4gIC8vIFwiKzJcIlx0XHRcdFx0IC0tLS0+ICsxIDJcbiAgLy8gXCIxXCJcdFx0XHRcdCAtLS0tPiArMSAxXG4gIC8vIFwiMTIzNFwiXHRcdFx0IC0tLS0+ICsxIDEyMy00XG4gIC8vIFwiMTIzYVwiICAgICAgLS0tLT4gKzEgMTIzXG4gIC8vIERldGVybWluZSBwcmVmaXggbGVuZ3RoIGFuZCBzdWZmaXggc3RhcnRcblxuICB2YXIgcHJlZml4TGVuZ3RoID0gZm9ybWF0dGVyLmZpbmRJbmRleChmdW5jdGlvbiAodikge1xuICAgIHJldHVybiB0eXBlb2YgdiAhPSAnc3RyaW5nJztcbiAgfSk7XG5cbiAgdmFyIHN1ZmZpeFN0YXJ0ID0gZm9ybWF0dGVyLmxlbmd0aCAtIF90b0NvbnN1bWFibGVBcnJheShmb3JtYXR0ZXIpLnJldmVyc2UoKS5maW5kSW5kZXgoZnVuY3Rpb24gKHYpIHtcbiAgICByZXR1cm4gdHlwZW9mIHYgIT0gJ3N0cmluZyc7XG4gIH0pOyAvLyBGb3JtYXR0ZWQgdmFsdWVcblxuXG4gIHZhciBmb3JtYXR0ZWQgPSBbXTsgLy8gVGhlIGNoYXJhY3RlcnMgZnJvbSB0aGUgY3VycmVudCB2YWx1ZVxuXG4gIHZhciBjaGFycyA9IHZhbHVlLnNwbGl0KCcnKTsgLy8gVG8gdHJhY2sgdGhlIHZhbHVlIGluZGV4IGR1cmluZyBpdHRlcmF0aW9uXG5cbiAgdmFyIHZJbmRleCA9IDA7XG4gIHZhciBzdGFydCA9IDA7IC8vIElmIHRoZSB2YWx1ZSBtYXRjaGVzIHBhcnQgb2YgdGhlIHByZWZpeCB0YWtlIGl0IG91dFxuICAvLyBFeGFtcGxlIHByZWZpeCA9IFwiKzEgXCIgdmFsdWUgPSBbXCIrMSAxMjMtMTIzLTEyMzRcIiwgXCIrMTJcIiwgXCIrMlwiXVxuXG4gIHZhciBtYXRjaEluZGV4ID0gbWF0Y2hpbmdJbmRleChmb3JtYXR0ZXIuc2xpY2UoMCwgcHJlZml4TGVuZ3RoKSwgY2hhcnMuc2xpY2UoMCwgcHJlZml4TGVuZ3RoKSk7IC8vIGNvbnNvbGUubG9nKCdNYXRjaGluZyBpbmRleCcsIG1hdGNoSW5kZXgpO1xuXG4gIGlmIChtYXRjaEluZGV4ID4gLTEpIHtcbiAgICAvL3ZJbmRleCA9IHByZWZpeExlbmd0aDtcbiAgICB2SW5kZXggPSBtYXRjaEluZGV4ICsgMTtcbiAgICBmb3JtYXR0ZWQgPSBmb3JtYXR0ZWQuY29uY2F0KGZvcm1hdHRlci5zbGljZSgwLCBtYXRjaEluZGV4ICsgMSkpO1xuICAgIHN0YXJ0ID0gbWF0Y2hJbmRleCArIDE7XG4gIH0gLy8gRXhhbXBsZSBwcmVmaXggPSBcIisxIFwiIHZhbHVlPVtcIjFcIiwgXCIxMjM0XCJdXG5cblxuICBpZiAobWF0Y2hJbmRleCA8IDApIHtcbiAgICAvLyBTdGFydCBwYXN0IHRoZSBwcmVmaXhcbiAgICBmb3JtYXR0ZWQgPSBmb3JtYXR0ZWQuY29uY2F0KGZvcm1hdHRlci5zbGljZSgwLCBwcmVmaXhMZW5ndGgpKTtcbiAgICBzdGFydCA9IHByZWZpeExlbmd0aDtcbiAgfSAvLyBjb25zb2xlLmxvZygnc3RhcnQnLCBzdGFydCwgZm9ybWF0dGVkKTtcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBmb3JtYXR0ZXIubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBHZXQgY3VycmVudCBmb3JtYXR0ZXIgbG9jYXRpb24gbWF0Y2hlclxuICAgIHZhciBtYXRjaGVyID0gZm9ybWF0dGVyW2ldOyAvLyBXZSBnZXQgcGFzdCB0aGUgcHJlZml4IGlmIG1hdGNoZXIgaXMgbm90IGEgc3RyaW5nXG5cblxuICAgIGlmICh2SW5kZXggIT0gY2hhcnMubGVuZ3RoKSB7XG4gICAgICAvLyBHZXQgdGhlIGN1cnJlbnQgdmFsdWUgY2hhcmFjdGVyXG4gICAgICB2YXIgY3VyQ2hhciA9IGNoYXJzW3ZJbmRleF07IC8vIElmIHR5cGUgaXMgc3RyaW5nIG5vcm1hbCBjb21wYXJlIG90aGVyd2lzZSByZWdleCBjb21wYXJlXG5cbiAgICAgIHZhciBtYXRjaCA9IHR5cGVvZiBtYXRjaGVyID09PSAnc3RyaW5nJyA/IG1hdGNoZXIgPT09IGN1ckNoYXIgOiBtYXRjaGVyLnRlc3QoY3VyQ2hhcik7IC8vIElmIHRoZSBjdXJyZW50IGNoYXJhY3RlciBvZiB0aGUgdmFsdWUgbWF0Y2hlcyBhbmQgbWF0Y2hlciBpcyBhIHN0cmluZ1xuICAgICAgLy8gXCIxXCIgPT09IFwiMVwiXG5cbiAgICAgIGlmIChtYXRjaCAmJiB0eXBlb2YgbWF0Y2hlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZm9ybWF0dGVkLnB1c2gobWF0Y2hlcik7IC8vaWYoIHBhc3RQcmVmaXggKXtcblxuICAgICAgICB2SW5kZXggPSB2SW5kZXggKyAxOyAvL31cbiAgICAgIH0gLy8gSWYgdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGRvZXMgbm90IG1hdGNoIGFuZCBtYXRjaGVyIGlzIGEgc3Rpcm5nXG4gICAgICAvLyBcIjFcIiAhPSBcIitcIlxuICAgICAgZWxzZSBpZiAoIW1hdGNoICYmIHR5cGVvZiBtYXRjaGVyID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIC8vIFNwZWNpYWwgY2hlY2sgZm9yIDEyM2EgLS0tPiBkb250IHdhbnQgXCIrMSAxMjMtXCJcbiAgICAgICAgICAvLyBTcGVjaWFsIGNoZWNrIGZvciAxMjM0IC0tLT4gRE8gd2FudCBcIisxIDEyMy00XCJcbiAgICAgICAgICBpZiAodkluZGV4ICE9IGNoYXJzLmxlbmd0aCkgZm9ybWF0dGVkLnB1c2gobWF0Y2hlcik7XG4gICAgICAgIH0gLy8gSWYgdGhlIGN1cnJlbnQgY2hhcmFjdGVyIG1hdGNoZXMgYW5kIHRoZSBtYXRjaGVyIGlzIG5vdCBhIHN0cmluZ1xuICAgICAgICAvLyAvXFxkLy50ZXN0KFwiMlwiKVxuICAgICAgICBlbHNlIGlmIChtYXRjaCAmJiB0eXBlb2YgbWF0Y2hlciAhPSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZm9ybWF0dGVkLnB1c2goY3VyQ2hhcik7XG4gICAgICAgICAgICB2SW5kZXggPSB2SW5kZXggKyAxO1xuICAgICAgICAgIH0gLy8gSWYgdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGRvZXMgTk9UIG1hdGNoIGFuZCB0aGUgbWF0ZWNlciBpcyByZWdleFxuICAgICAgICAgIC8vIC9cXGQvLnRlc3QoXCJhXCIpXG4gICAgICAgICAgZWxzZSBpZiAoIW1hdGNoICYmIHR5cGVvZiBtYXRjaGVyICE9ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIC8vIFRocm93IG91dCB0aGlzIHZhbHVlXG4gICAgICAgICAgICAgIHZJbmRleCA9IHZJbmRleCArIDE7XG4gICAgICAgICAgICAgIGkgPSBpIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgbWF0dGNoZXIgaXMgYSBzdHJpbmcgYW5kIHdlIGFyZSBhdCBzdWZmaXgga2VlcCBnb2luZ1xuICAgICAgaWYgKHR5cGVvZiBtYXRjaGVyID09PSAnc3RyaW5nJyAmJiBpID49IHN1ZmZpeFN0YXJ0KSB7XG4gICAgICAgIGZvcm1hdHRlZC5wdXNoKG1hdGNoZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gT3RoZXJ3aXNlIHdlIHdhbnQgdG8gYnJlYWsgb3V0XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdmFsdWU6IGZvcm1hdHRlZC5qb2luKCcnKSxcbiAgICBvZmZzZXQ6IHZhbHVlID8gZm9ybWF0dGVkLmxlbmd0aCAtIHZhbHVlLmxlbmd0aCA6IDBcbiAgfTtcbn07XG5cbi8vIFRvIGdldCBhcm91bmQgaXQsIHdlIGNhbiBjb25kaXRpb25hbGx5IHVzZUVmZmVjdCBvbiB0aGUgc2VydmVyIChuby1vcCkgYW5kXG4vLyB1c2VMYXlvdXRFZmZlY3QgaW4gdGhlIGJyb3dzZXIuXG4vLyBAc2VlIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2dhZWFyb24vZTdkOTdjZGYzOGEyOTA3OTI0ZWExMmU0ZWJkZjNjODVcblxudmFyIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgIT09ICd1bmRlZmluZWQnID8gdXNlTGF5b3V0RWZmZWN0IDogdXNlRWZmZWN0O1xuXG52YXIgbG9nZ2VyID0gZGVidWcoJ2luZm9ybWVkOnVzZUZpZWxkJyArICdcXHQnKTsgLy8gbG9jYWxTdG9yYWdlLmRlYnVnID0gJ2luZm9ybWVkOi4qJyA8PCBIT1cgdG8gZW5hYmxlIGRlYnVnaW5nXG5cbnZhciBpbml0aWFsaXplVmFsdWUgPSBmdW5jdGlvbiBpbml0aWFsaXplVmFsdWUodmFsdWUsIG1hc2ssIGZvcm1hdHRlciwgcGFyc2VyKSB7XG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgLy8gQ2FsbCBtYXNrIGlmIGl0IHdhcyBwYXNzZWRcbiAgICBpZiAobWFzaykge1xuICAgICAgcmV0dXJuIG1hc2sodmFsdWUpO1xuICAgIH1cblxuICAgIGlmIChmb3JtYXR0ZXIgJiYgIXBhcnNlcikge1xuICAgICAgdmFyIHJlcyA9IGluZm9ybWVkRm9ybWF0KHZhbHVlLCBmb3JtYXR0ZXIpO1xuICAgICAgcmV0dXJuIHJlcy52YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH0gLy8gTm90IG5lZWRlZCBidXQgY2FsbGVkIG91dCBzcGVjaWZpY2FsbHlcblxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG52YXIgaW5pdGlhbGl6ZU1hc2sgPSBmdW5jdGlvbiBpbml0aWFsaXplTWFzayh2YWx1ZSwgZm9ybWF0LCBwYXJzZSwgZm9ybWF0dGVyKSB7XG4gIC8vIENhbGwgZm9ybWF0IGFuZCBwYXJzZSBpZiB0aGV5IHdlcmUgcGFzc2VkXG4gIGlmIChmb3JtYXQgJiYgcGFyc2UpIHtcbiAgICByZXR1cm4gZm9ybWF0KHZhbHVlKTtcbiAgfSAvLyBDYWxsIGZvcm1hdHRlclxuXG5cbiAgaWYgKGZvcm1hdHRlcikge1xuICAgIHZhciByZXMgPSBpbmZvcm1lZEZvcm1hdCh2YWx1ZSwgZm9ybWF0dGVyKTtcbiAgICByZXR1cm4gcmVzLnZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufTtcblxudmFyIGdlbmVyYXRlVmFsaWRhdGlvbkZ1bmN0aW9uID0gZnVuY3Rpb24gZ2VuZXJhdGVWYWxpZGF0aW9uRnVuY3Rpb24odmFsaWRhdGlvbkZ1bmMsIHZhbGlkYXRpb25TY2hlbWEsIF9yZWYpIHtcbiAgdmFyIHJlcXVpcmVkID0gX3JlZi5yZXF1aXJlZDtcblxuICAvLyBXZSBkb250IHdhbnQgYSB2YWxpZGF0aW9uIGZ1bmN0aW9uIGlmIHRoZXJlIHdhcyBub3RoaW5nIHBhc3NlZFxuICBpZiAodmFsaWRhdGlvbkZ1bmMgfHwgdmFsaWRhdGlvblNjaGVtYSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAodmFsLCB2YWx1ZXMpIHtcbiAgICAgIGlmICh2YWxpZGF0aW9uU2NoZW1hKSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZVl1cEZpZWxkKHZhbGlkYXRpb25TY2hlbWEsIHZhbCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWxpZGF0aW9uRnVuYykge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGlvbkZ1bmModmFsLCB2YWx1ZXMpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBpZiAocmVxdWlyZWQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgcmV0dXJuIHZhbGlkYXRlUmVxdWlyZWQodmFsLCByZXF1aXJlZCk7XG4gICAgfTtcbiAgfVxufTtcblxudmFyIGdlbmVyYXRlT25DaGFuZ2UgPSBmdW5jdGlvbiBnZW5lcmF0ZU9uQ2hhbmdlKF9yZWYyKSB7XG4gIHZhciBmaWVsZFR5cGUgPSBfcmVmMi5maWVsZFR5cGUsXG4gICAgICBzZXRWYWx1ZSA9IF9yZWYyLnNldFZhbHVlLFxuICAgICAgb25DaGFuZ2UgPSBfcmVmMi5vbkNoYW5nZSxcbiAgICAgIG11bHRpcGxlID0gX3JlZjIubXVsdGlwbGUsXG4gICAgICByZWYgPSBfcmVmMi5yZWY7XG5cbiAgdmFyIHNldHRlciA9IGZ1bmN0aW9uIHNldHRlcih2YWwpIHtcbiAgICByZXR1cm4gc2V0VmFsdWUodmFsKTtcbiAgfTtcblxuICBpZiAoZmllbGRUeXBlID09PSAndGV4dCcgfHwgZmllbGRUeXBlID09PSAndGV4dEFyZWEnIHx8IGZpZWxkVHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICBzZXR0ZXIgPSBmdW5jdGlvbiBzZXR0ZXIoZSkge1xuICAgICAgcmV0dXJuIHNldFZhbHVlKGUudGFyZ2V0LnZhbHVlLCBlKTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKGZpZWxkVHlwZSA9PT0gJ3NlbGVjdCcpIHtcbiAgICBzZXR0ZXIgPSBmdW5jdGlvbiBzZXR0ZXIoKSB7XG4gICAgICB2YXIgc2VsZWN0ZWQgPSBBcnJheS5mcm9tKHJlZi5jdXJyZW50KS5maWx0ZXIoZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgICByZXR1cm4gb3B0aW9uLnNlbGVjdGVkO1xuICAgICAgfSkubWFwKGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbi52YWx1ZTtcbiAgICAgIH0pO1xuICAgICAgc2V0VmFsdWUobXVsdGlwbGUgPyBzZWxlY3RlZCA6IHNlbGVjdGVkWzBdIHx8ICcnKTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKGZpZWxkVHlwZSA9PT0gJ2NoZWNrYm94Jykge1xuICAgIHNldHRlciA9IGZ1bmN0aW9uIHNldHRlcihlKSB7XG4gICAgICBzZXRWYWx1ZShlLnRhcmdldC5jaGVja2VkKTtcblxuICAgICAgaWYgKG9uQ2hhbmdlKSB7XG4gICAgICAgIG9uQ2hhbmdlKGUpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKHZhbCkge1xuICAgIHNldHRlcih2YWwpO1xuXG4gICAgaWYgKG9uQ2hhbmdlKSB7XG4gICAgICBvbkNoYW5nZSh2YWwpO1xuICAgIH1cbiAgfTtcbn07XG5cbnZhciBnZW5lcmF0ZU9uQmx1ciA9IGZ1bmN0aW9uIGdlbmVyYXRlT25CbHVyKF9yZWYzKSB7XG4gIHZhciBzZXRUb3VjaGVkID0gX3JlZjMuc2V0VG91Y2hlZCxcbiAgICAgIG9uQmx1ciA9IF9yZWYzLm9uQmx1cjtcbiAgcmV0dXJuIGZ1bmN0aW9uIChlKSB7XG4gICAgc2V0VG91Y2hlZCh0cnVlKTtcblxuICAgIGlmIChvbkJsdXIpIHtcbiAgICAgIG9uQmx1cihlKTtcbiAgICB9XG4gIH07XG59O1xuXG52YXIgZ2VuZXJhdGVWYWx1ZSA9IGZ1bmN0aW9uIGdlbmVyYXRlVmFsdWUoX3JlZjQpIHtcbiAgdmFyIGZpZWxkVHlwZSA9IF9yZWY0LmZpZWxkVHlwZSxcbiAgICAgIG1hc2tlZFZhbHVlID0gX3JlZjQubWFza2VkVmFsdWUsXG4gICAgICBtdWx0aXBsZSA9IF9yZWY0Lm11bHRpcGxlLFxuICAgICAgdmFsdWUgPSBfcmVmNC52YWx1ZTtcblxuICBzd2l0Y2ggKGZpZWxkVHlwZSkge1xuICAgIGNhc2UgJ3RleHQnOlxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICByZXR1cm4gIW1hc2tlZFZhbHVlICYmIG1hc2tlZFZhbHVlICE9PSAwID8gJycgOiBtYXNrZWRWYWx1ZTtcblxuICAgIGNhc2UgJ3RleHRBcmVhJzpcbiAgICAgIHJldHVybiAhbWFza2VkVmFsdWUgPyAnJyA6IG1hc2tlZFZhbHVlO1xuXG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIHJldHVybiB2YWx1ZSB8fCAobXVsdGlwbGUgPyBbXSA6ICcnKTtcblxuICAgIGNhc2UgJ2NoZWNrYm94JzpcbiAgICAgIHJldHVybiAhIXZhbHVlO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufTtcblxudmFyIGdlbmVyYXRlRmllbGRUeXBlID0gZnVuY3Rpb24gZ2VuZXJhdGVGaWVsZFR5cGUoZmllbGRUeXBlKSB7XG4gIHN3aXRjaCAoZmllbGRUeXBlKSB7XG4gICAgY2FzZSAndGV4dCc6XG4gICAgICByZXR1cm4gZmllbGRUeXBlO1xuXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIHJldHVybiBmaWVsZFR5cGU7XG5cbiAgICBjYXNlICdjaGVja2JveCc6XG4gICAgICByZXR1cm4gZmllbGRUeXBlO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybjtcbiAgfVxufTtcblxudmFyIHZhbGlkYXRlUmVxdWlyZWQgPSBmdW5jdGlvbiB2YWxpZGF0ZVJlcXVpcmVkKHZhbHVlLCByZXF1aXJlZCkge1xuICBpZiAocmVxdWlyZWQgJiYgKHZhbHVlID09IG51bGwgfHwgdmFsdWUgPT09ICcnKSkge1xuICAgIHJldHVybiB0eXBlb2YgcmVxdWlyZWQgPT09ICdzdHJpbmcnID8gcmVxdWlyZWQgOiAnVGhpcyBmaWVsZCBpcyByZXF1aXJlZCc7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHVzZUZpZWxkKCkge1xuICB2YXIgZmllbGRQcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIHZhciB1c2VyUmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG5cbiAgLy8gUHVsbCBwcm9wcyBvZmYgb2YgZmllbGQgcHJvcHNcbiAgdmFyIGZpZWxkID0gZmllbGRQcm9wcy5maWVsZCxcbiAgICAgIHZhbGlkYXRpb25GdW5jID0gZmllbGRQcm9wcy52YWxpZGF0ZSxcbiAgICAgIGFzeW5jVmFsaWRhdGUgPSBmaWVsZFByb3BzLmFzeW5jVmFsaWRhdGUsXG4gICAgICB2YWxpZGF0aW9uU2NoZW1hID0gZmllbGRQcm9wcy52YWxpZGF0aW9uU2NoZW1hLFxuICAgICAgbWFzayA9IGZpZWxkUHJvcHMubWFzayxcbiAgICAgIG1hc2tXaXRoQ3Vyc29yT2Zmc2V0ID0gZmllbGRQcm9wcy5tYXNrV2l0aEN1cnNvck9mZnNldCxcbiAgICAgIGZvcm1hdCA9IGZpZWxkUHJvcHMuZm9ybWF0LFxuICAgICAgcGFyc2UgPSBmaWVsZFByb3BzLnBhcnNlLFxuICAgICAgZm9ybWF0dGVyID0gZmllbGRQcm9wcy5mb3JtYXR0ZXIsXG4gICAgICBwYXJzZXIgPSBmaWVsZFByb3BzLnBhcnNlcixcbiAgICAgIGluaXRpYWxWYWx1ZSA9IGZpZWxkUHJvcHMuaW5pdGlhbFZhbHVlLFxuICAgICAgdmFsaWRhdGVPbkNoYW5nZSA9IGZpZWxkUHJvcHMudmFsaWRhdGVPbkNoYW5nZSxcbiAgICAgIHZhbGlkYXRlT25CbHVyID0gZmllbGRQcm9wcy52YWxpZGF0ZU9uQmx1cixcbiAgICAgIHZhbGlkYXRlT25Nb3VudCA9IGZpZWxkUHJvcHMudmFsaWRhdGVPbk1vdW50LFxuICAgICAgYXN5bmNWYWxpZGF0ZU9uQmx1ciA9IGZpZWxkUHJvcHMuYXN5bmNWYWxpZGF0ZU9uQmx1cixcbiAgICAgIG1hc2tPbkJsdXIgPSBmaWVsZFByb3BzLm1hc2tPbkJsdXIsXG4gICAgICBhbGxvd0VtcHR5U3RyaW5nID0gZmllbGRQcm9wcy5hbGxvd0VtcHR5U3RyaW5nLFxuICAgICAgb25WYWx1ZUNoYW5nZSA9IGZpZWxkUHJvcHMub25WYWx1ZUNoYW5nZSxcbiAgICAgIG5vdGlmeSA9IGZpZWxkUHJvcHMubm90aWZ5LFxuICAgICAga2VlcFN0YXRlID0gZmllbGRQcm9wcy5rZWVwU3RhdGUsXG4gICAgICBtYWludGFpbkN1cnNvciA9IGZpZWxkUHJvcHMubWFpbnRhaW5DdXJzb3IsXG4gICAgICBkZWJ1ZyA9IGZpZWxkUHJvcHMuZGVidWcsXG4gICAgICBzaGFkb3cgPSBmaWVsZFByb3BzLnNoYWRvdyxcbiAgICAgIHN0ZXAgPSBmaWVsZFByb3BzLnN0ZXAsXG4gICAgICBmaWVsZFR5cGUgPSBmaWVsZFByb3BzLmZpZWxkVHlwZSxcbiAgICAgIG11bHRpcGxlID0gZmllbGRQcm9wcy5tdWx0aXBsZSxcbiAgICAgIG9uQ2hhbmdlID0gZmllbGRQcm9wcy5vbkNoYW5nZSxcbiAgICAgIG9uQmx1ciA9IGZpZWxkUHJvcHMub25CbHVyLFxuICAgICAgZm9ybUNvbnRyb2xsZXIgPSBmaWVsZFByb3BzLmZvcm1Db250cm9sbGVyLFxuICAgICAgdXNlclJlbGV2YW50ID0gZmllbGRQcm9wcy5yZWxldmFudCxcbiAgICAgIHJlcXVpcmVkID0gZmllbGRQcm9wcy5yZXF1aXJlZCxcbiAgICAgIGtlZXBTdGF0ZUlmUmVsZXZhbnQgPSBmaWVsZFByb3BzLmtlZXBTdGF0ZUlmUmVsZXZhbnQsXG4gICAgICB1c2VyUHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoZmllbGRQcm9wcywgW1wiZmllbGRcIiwgXCJ2YWxpZGF0ZVwiLCBcImFzeW5jVmFsaWRhdGVcIiwgXCJ2YWxpZGF0aW9uU2NoZW1hXCIsIFwibWFza1wiLCBcIm1hc2tXaXRoQ3Vyc29yT2Zmc2V0XCIsIFwiZm9ybWF0XCIsIFwicGFyc2VcIiwgXCJmb3JtYXR0ZXJcIiwgXCJwYXJzZXJcIiwgXCJpbml0aWFsVmFsdWVcIiwgXCJ2YWxpZGF0ZU9uQ2hhbmdlXCIsIFwidmFsaWRhdGVPbkJsdXJcIiwgXCJ2YWxpZGF0ZU9uTW91bnRcIiwgXCJhc3luY1ZhbGlkYXRlT25CbHVyXCIsIFwibWFza09uQmx1clwiLCBcImFsbG93RW1wdHlTdHJpbmdcIiwgXCJvblZhbHVlQ2hhbmdlXCIsIFwibm90aWZ5XCIsIFwia2VlcFN0YXRlXCIsIFwibWFpbnRhaW5DdXJzb3JcIiwgXCJkZWJ1Z1wiLCBcInNoYWRvd1wiLCBcInN0ZXBcIiwgXCJmaWVsZFR5cGVcIiwgXCJtdWx0aXBsZVwiLCBcIm9uQ2hhbmdlXCIsIFwib25CbHVyXCIsIFwiZm9ybUNvbnRyb2xsZXJcIiwgXCJyZWxldmFudFwiLCBcInJlcXVpcmVkXCIsIFwia2VlcFN0YXRlSWZSZWxldmFudFwiXSk7IC8vIENyZWF0ZSByZWYgdG8gYSBmaWVsZCBpZFxuXG5cbiAgdmFyIF91c2VTdGF0ZSA9IHVzZVN0YXRlKHV1aWR2NCgpKSxcbiAgICAgIF91c2VTdGF0ZTIgPSBfc2xpY2VkVG9BcnJheShfdXNlU3RhdGUsIDEpLFxuICAgICAgZmllbGRJZCA9IF91c2VTdGF0ZTJbMF07IC8vIEdyYWIgdGhlIGZvcm0gcmVnaXN0ZXIgY29udGV4dFxuXG5cbiAgdmFyIHVwZGF0ZXIgPSB1c2VDb250ZXh0KEZvcm1SZWdpc3RlckNvbnRleHQpOyAvLyBHcmFiIG11bHRpc3RlcENvbnRleHRcblxuICB2YXIgbXVsdGlzdGVwQ29udGV4dCA9IHVzZUNvbnRleHQoTXVsdGlzdGVwU3RlcENvbnRleHQpO1xuICB2YXIgaW5NdWx0aXN0ZXAgPSBtdWx0aXN0ZXBDb250ZXh0IHx8IGtlZXBTdGF0ZUlmUmVsZXZhbnQ7IC8vIEdyYWIgdGhlIGZvcm0gYXBpXG5cbiAgdmFyIGZvcm1BcGkgPSB1c2VGb3JtQXBpKCk7IC8vIENyZWF0ZSByZWYgdG8gZmllbGRBcGlcblxuICB2YXIgZmllbGRBcGlSZWYgPSB1c2VSZWYoKTsgLy8gQ3JlYXRlIGluaXRpYWwgcmVuZGVyIHJlZlxuXG4gIHZhciBpbml0aWFsUmVuZXJSZWYgPSB1c2VSZWYodHJ1ZSk7IC8vIENyZWF0ZSByZWYgdG8gZmllbGRPYmplY3RcblxuICB2YXIgZmllbGRPYmplY3RSZWYgPSB1c2VSZWYoKTsgLy8gSWYgdGhlIGZvcm0gQ29udHJvbGxlciB3YXMgcGFzc2VkIGluIHRoZW4gdXNlIHRoYXQgaW5zdGVhZFxuXG4gIGlmIChmb3JtQ29udHJvbGxlcikge1xuICAgIHVwZGF0ZXIgPSBmb3JtQ29udHJvbGxlci51cGRhdGVyO1xuICAgIGZvcm1BcGkgPSBmb3JtQ29udHJvbGxlci5nZXRGb3JtQXBpKCk7XG4gIH0gLy8gR2VuZXJhdGUgdmFsaWRhdGlvbiBmdW5jdGlvblxuXG5cbiAgdmFyIHZhbGlkYXRlID0gZ2VuZXJhdGVWYWxpZGF0aW9uRnVuY3Rpb24odmFsaWRhdGlvbkZ1bmMsIHZhbGlkYXRpb25TY2hlbWEsIHtcbiAgICByZXF1aXJlZDogcmVxdWlyZWRcbiAgfSk7IC8vIEdyYWIgcG9zc2libGUgaW5pdGlhbCB2YWx1ZSBmcm9tIGZvcm1cblxuICB2YXIgX3VzZVN0YXRlMyA9IHVzZVN0YXRlKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdXBkYXRlci5nZXRJbml0aWFsVmFsdWUoZmllbGQpO1xuICB9KSxcbiAgICAgIF91c2VTdGF0ZTQgPSBfc2xpY2VkVG9BcnJheShfdXNlU3RhdGUzLCAxKSxcbiAgICAgIGZvcm1Jbml0aWFsVmFsdWUgPSBfdXNlU3RhdGU0WzBdOyAvLyBXZSBtaWdodCBoYXZlIGtlZXAgc3RhdGUgc28gY2hlY2sgZm9yIGl0IVxuXG5cbiAgdmFyIHNhdmVkU3RhdGUgPSBmb3JtQXBpLmdldFNhdmVkVmFsdWUoZmllbGQpOyAvLyBDcmVhdGUgSW5pdGlhbCBWYWx1ZXNcblxuICB2YXIgaW5pdFZhbDtcbiAgdmFyIGluaXRUb3VjaGVkOyAvLyBXZSBkbyB0aGVzZSBjaGVja3MgYmVjYXVzZSBpbml0aWFsIHZhbHVlIGNvdWxkIGJlIGZhbHNlIG9yIHplcm8hIVxuXG4gIGlmICgoa2VlcFN0YXRlIHx8IGluTXVsdGlzdGVwKSAmJiBzYXZlZFN0YXRlKSB7XG4gICAgbG9nZ2VyKFwiU2V0dGluZyBmaWVsZCBcIi5jb25jYXQobmFtZSwgXCIncyBrZXB0IHN0YXRlXCIpLCBzYXZlZFN0YXRlKTtcbiAgICBpbml0VmFsID0gc2F2ZWRTdGF0ZS52YWx1ZTtcbiAgICBpbml0VG91Y2hlZCA9IHNhdmVkU3RhdGUudG91Y2hlZDsgLy8gUmVtb3ZlIHRoZSBzYXZlZCBzdGF0ZVxuXG4gICAgZm9ybUFwaS5yZW1vdmVTYXZlZFN0YXRlKG5hbWUpO1xuICB9IGVsc2UgaWYgKGluaXRpYWxWYWx1ZSAhPSB1bmRlZmluZWQpIHtcbiAgICBpbml0VmFsID0gaW5pdGlhbFZhbHVlO1xuICB9IGVsc2Uge1xuICAgIGluaXRWYWwgPSBmb3JtSW5pdGlhbFZhbHVlO1xuICB9IC8vIEluaXRpYWxpemUgc3RhdGVcblxuXG4gIHZhciBfdXNlU3RhdGVXaXRoR2V0dGVyID0gdXNlU3RhdGVXaXRoR2V0dGVyKGluaXRpYWxpemVWYWx1ZShpbml0VmFsLCBtYXNrLCBmb3JtYXR0ZXIsIHBhcnNlcikpLFxuICAgICAgX3VzZVN0YXRlV2l0aEdldHRlcjIgPSBfc2xpY2VkVG9BcnJheShfdXNlU3RhdGVXaXRoR2V0dGVyLCAzKSxcbiAgICAgIHZhbHVlID0gX3VzZVN0YXRlV2l0aEdldHRlcjJbMF0sXG4gICAgICBzZXRWYWwgPSBfdXNlU3RhdGVXaXRoR2V0dGVyMlsxXSxcbiAgICAgIGdldFRoZVZhbCA9IF91c2VTdGF0ZVdpdGhHZXR0ZXIyWzJdO1xuXG4gIHZhciBfdXNlU3RhdGVXaXRoR2V0dGVyMyA9IHVzZVN0YXRlV2l0aEdldHRlcih2YWxpZGF0ZU9uTW91bnQgPyB2YWxpZGF0ZSh2YWx1ZSkgOiB1bmRlZmluZWQpLFxuICAgICAgX3VzZVN0YXRlV2l0aEdldHRlcjQgPSBfc2xpY2VkVG9BcnJheShfdXNlU3RhdGVXaXRoR2V0dGVyMywgMyksXG4gICAgICBlcnJvciA9IF91c2VTdGF0ZVdpdGhHZXR0ZXI0WzBdLFxuICAgICAgc2V0RXJyID0gX3VzZVN0YXRlV2l0aEdldHRlcjRbMV0sXG4gICAgICBnZXRFcnIgPSBfdXNlU3RhdGVXaXRoR2V0dGVyNFsyXTtcblxuICB2YXIgX3VzZVN0YXRlV2l0aEdldHRlcjUgPSB1c2VTdGF0ZVdpdGhHZXR0ZXIoaW5pdFRvdWNoZWQpLFxuICAgICAgX3VzZVN0YXRlV2l0aEdldHRlcjYgPSBfc2xpY2VkVG9BcnJheShfdXNlU3RhdGVXaXRoR2V0dGVyNSwgMyksXG4gICAgICB0b3VjaGVkID0gX3VzZVN0YXRlV2l0aEdldHRlcjZbMF0sXG4gICAgICBzZXRUb3VjaCA9IF91c2VTdGF0ZVdpdGhHZXR0ZXI2WzFdLFxuICAgICAgZ2V0VG91Y2ggPSBfdXNlU3RhdGVXaXRoR2V0dGVyNlsyXTtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuXG4gIHZhciBfdXNlU3RhdGVXaXRoR2V0dGVyNyA9IHVzZVN0YXRlV2l0aEdldHRlcigwKSxcbiAgICAgIF91c2VTdGF0ZVdpdGhHZXR0ZXI4ID0gX3NsaWNlZFRvQXJyYXkoX3VzZVN0YXRlV2l0aEdldHRlcjcsIDMpLFxuICAgICAgY3Vyc29yID0gX3VzZVN0YXRlV2l0aEdldHRlcjhbMF0sXG4gICAgICBzZXRDdXJzb3IgPSBfdXNlU3RhdGVXaXRoR2V0dGVyOFsxXSxcbiAgICAgIGdldEN1cnNvciA9IF91c2VTdGF0ZVdpdGhHZXR0ZXI4WzJdO1xuXG4gIHZhciBfdXNlU3RhdGVXaXRoR2V0dGVyOSA9IHVzZVN0YXRlV2l0aEdldHRlcigwKSxcbiAgICAgIF91c2VTdGF0ZVdpdGhHZXR0ZXIxMCA9IF9zbGljZWRUb0FycmF5KF91c2VTdGF0ZVdpdGhHZXR0ZXI5LCAzKSxcbiAgICAgIGN1cnNvck9mZnNldCA9IF91c2VTdGF0ZVdpdGhHZXR0ZXIxMFswXSxcbiAgICAgIHNldEN1cnNvck9mZnNldCA9IF91c2VTdGF0ZVdpdGhHZXR0ZXIxMFsxXSxcbiAgICAgIGdldEN1cnNvck9mZnNldCA9IF91c2VTdGF0ZVdpdGhHZXR0ZXIxMFsyXTtcblxuICB2YXIgX3VzZVN0YXRlNSA9IHVzZVN0YXRlKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gaW5pdGlhbGl6ZU1hc2sodmFsdWUsIGZvcm1hdCwgcGFyc2UsIGZvcm1hdHRlcik7XG4gIH0pLFxuICAgICAgX3VzZVN0YXRlNiA9IF9zbGljZWRUb0FycmF5KF91c2VTdGF0ZTUsIDIpLFxuICAgICAgbWFza2VkVmFsdWUgPSBfdXNlU3RhdGU2WzBdLFxuICAgICAgc2V0TWFza2VkVmFsdWUgPSBfdXNlU3RhdGU2WzFdOyAvLyBDcmVhdGUgdGhlbiB1cGRhdGUgcmVmcyB0byBwcm9wc1xuXG5cbiAgdmFyIGluaXRpYWxWYWx1ZVJlZiA9IHVzZVJlZihpbml0aWFsVmFsdWUpO1xuICB2YXIgZmllbGRSZWYgPSB1c2VSZWYoZmllbGQpO1xuICB2YXIgcHJldkZpZWxkUmVmID0gdXNlUmVmKCk7XG4gIGluaXRpYWxWYWx1ZVJlZi5jdXJyZW50ID0gaW5pdGlhbFZhbHVlO1xuICBmaWVsZFJlZi5jdXJyZW50ID0gZmllbGQ7IC8vIERlZmF1bHQgcmVsZXZhbnQgZnVuY3Rpb25cblxuICB2YXIgcmVsZXZhbnRGdW5jID0gZnVuY3Rpb24gcmVsZXZhbnRGdW5jKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIHZhciByZWxldmFudCA9IGZ1bmN0aW9uIHJlbGV2YW50KHBhcmFtcykge1xuICAgIHZhciByZWwgPSB1c2VyUmVsZXZhbnQgfHwgcmVsZXZhbnRGdW5jO1xuICAgIHZhciBmZiA9IGZvcm1BcGkuZ2V0RnVsbEZpZWxkKGZpZWxkUmVmLmN1cnJlbnQpIHx8IGZpZWxkUmVmLmN1cnJlbnQ7XG4gICAgdmFyIGFyZ3MgPSB7XG4gICAgICBwYXRoOiBmZixcbiAgICAgIHBhcmVudFBhdGg6IGZmLnJlcGxhY2UoLyguKilbLltdLiovLCAnJDEnKSxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KHZhbHVlcywgcGF0aCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0TWFwLmdldCh2YWx1ZXMsIHBhdGgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAobXVsdGlzdGVwQ29udGV4dCAmJiBtdWx0aXN0ZXBDb250ZXh0LnJlbGV2YW50KSB7XG4gICAgICByZXR1cm4gcmVsKHBhcmFtcywgYXJncykgJiYgbXVsdGlzdGVwQ29udGV4dC5yZWxldmFudChwYXJhbXMsIGFyZ3MpO1xuICAgIH1cblxuICAgIHJldHVybiByZWwocGFyYW1zLCBhcmdzKTtcbiAgfTtcblxuICB2YXIgX3VzZVN0YXRlV2l0aEdldHRlcjExID0gdXNlU3RhdGVXaXRoR2V0dGVyKHJlbGV2YW50KGZvcm1BcGkuZ2V0VmFsdWVzKCkpKSxcbiAgICAgIF91c2VTdGF0ZVdpdGhHZXR0ZXIxMiA9IF9zbGljZWRUb0FycmF5KF91c2VTdGF0ZVdpdGhHZXR0ZXIxMSwgMyksXG4gICAgICBpc1JlbGV2YW50ID0gX3VzZVN0YXRlV2l0aEdldHRlcjEyWzBdLFxuICAgICAgc2V0SXNSZWxldmFudCA9IF91c2VTdGF0ZVdpdGhHZXR0ZXIxMlsxXSxcbiAgICAgIGdldElzUmVsZXZhbnQgPSBfdXNlU3RhdGVXaXRoR2V0dGVyMTJbMl07XG5cbiAgdmFyIG11bHRpc3RlcFJlbGV2YW50ID0gZnVuY3Rpb24gbXVsdGlzdGVwUmVsZXZhbnQocGFyYW1zKSB7XG4gICAgaWYgKG11bHRpc3RlcENvbnRleHQgJiYgbXVsdGlzdGVwQ29udGV4dC5yZWxldmFudCkge1xuICAgICAgcmV0dXJuIG11bHRpc3RlcENvbnRleHQucmVsZXZhbnQocGFyYW1zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICB2YXIgY2hlY2tSZWxldmFudCA9IGZ1bmN0aW9uIGNoZWNrUmVsZXZhbnQoKSB7XG4gICAgdmFyIG5ld1JlbCA9IHJlbGV2YW50KGZvcm1BcGkuZ2V0VmFsdWVzKCkpO1xuICAgIHZhciBjdXJSZWwgPSBnZXRJc1JlbGV2YW50KCk7XG5cbiAgICBpZiAobmV3UmVsICE9IGN1clJlbCkge1xuICAgICAgc2V0SXNSZWxldmFudChuZXdSZWwpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXdSZWw7XG4gIH07XG5cbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAvLyBSZXNldCBpZiB3ZSBkb250IGhhdmUga2VlcCBzdGF0ZSBhbmQgcmVsZXZhbmNlIGNoYW5nZWQuXG4gICAgaWYgKCFpc1JlbGV2YW50ICYmICFrZWVwU3RhdGUpIHtcbiAgICAgIGZpZWxkQXBpUmVmLmN1cnJlbnQucmVzZXQoKTtcbiAgICB9XG4gIH0sIFtpc1JlbGV2YW50XSk7IC8vIFNwZWNpYWwgZ2V0dGVyIHRvIHN1cHBvcnQgc2hhZG93IGZpZWxkc1xuXG4gIHZhciBnZXRWYWwgPSBmdW5jdGlvbiBnZXRWYWwoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyA/IGZvcm1BcGkuZ2V0RGVycml2ZWRWYWx1ZShmaWVsZCkgOiBnZXRUaGVWYWwoKTtcbiAgfTtcbiAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBTZXR0ZXJzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbiAgLy8gLS0tLSBEZWZpbmUgc2V0IGVycm9yIC0tLS1cblxuXG4gIHZhciBzZXRFcnJvciA9IGZ1bmN0aW9uIHNldEVycm9yKHZhbCkge1xuICAgIHZhciBfcmVmNSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge30sXG4gICAgICAgIHByZXZlbnRVcGRhdGUgPSBfcmVmNS5wcmV2ZW50VXBkYXRlO1xuXG4gICAgLy8gRm9yIG11bHRpc3RlcCBmb3JtcyBhbHdheXMgc2V0IGVycm9yIHRvIHVuZGVmaW5lZCB3aGVuIG5vdCBhdCB0aGF0IHN0ZXBcbiAgICBpZiAoc3RlcCAmJiBmb3JtQXBpLmdldFN0ZXAoKSA8IHN0ZXApIHtcbiAgICAgIGxvZ2dlcihcIlNldHRpbmcgXCIuY29uY2F0KGZpZWxkLCBcIidzIGVycm9yIHRvIHVuZGVmaW5lZCBhcyB3ZSBhcmUgbm90IGF0IHRoYXQgc3RlcFwiKSk7XG4gICAgICBzZXRFcnIodW5kZWZpbmVkKTtcbiAgICAgIHVwZGF0ZXIuc2V0RXJyb3IoZmllbGRJZCwgdW5kZWZpbmVkLCAhcHJldmVudFVwZGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ2dlcihcIlNldHRpbmcgXCIuY29uY2F0KGZpZWxkLCBcIidzIGVycm9yIHRvIFwiKS5jb25jYXQodmFsKSk7XG4gICAgICBzZXRFcnIodmFsKTtcbiAgICAgIHVwZGF0ZXIuc2V0RXJyb3IoZmllbGRJZCwgdmFsLCAhcHJldmVudFVwZGF0ZSk7XG4gICAgfVxuICB9OyAvLyAtLS0tIERlZmluZSBzZXQgdmFsdWUgLS0tLVxuXG5cbiAgdmFyIHNldFZhbHVlID0gZnVuY3Rpb24gc2V0VmFsdWUodmFsLCBlKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIGxvZ2dlcihcIlNldHRpbmcgXCIuY29uY2F0KGZpZWxkLCBcIiB0byBcIikuY29uY2F0KHZhbCkpOyAvLyBHZXQgdGhlIG1vc3QgdXAgdG8gZGF0ZSBvcHRpb25zXG5cbiAgICB2YXIgZm9ybU9wdGlvbnMgPSBmb3JtQXBpLmdldE9wdGlvbnMoKTsgLy8gSW5pdGlhbGl6ZSBtYWtlZCB2YWx1ZVxuXG4gICAgdmFyIG1hc2tlZFZhbCA9IHZhbDtcblxuICAgIGlmICh2YWwgPT09ICcnICYmICFhbGxvd0VtcHR5U3RyaW5nICYmICFvcHRpb25zLmFsbG93RW1wdHlTdHJpbmcgJiYgIWZvcm1PcHRpb25zLmFsbG93RW1wdHlTdHJpbmdzKSB7XG4gICAgICB2YWwgPSB1bmRlZmluZWQ7XG4gICAgfSAvLyBUdXJuIHN0cmluZyBpbnRvIG51bWJlciBmb3IgbnVtYmVyIGZpZWxkc1xuXG5cbiAgICBpZiAoKGZpZWxkUHJvcHMudHlwZSA9PT0gJ251bWJlcicgfHwgZmllbGRUeXBlID09PSAnbnVtYmVyJykgJiYgdmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhbCA9ICt2YWw7XG4gICAgfSAvLyBSZW1lbWJlciBDdXJzb3IgcG9zaXRpb24hXG5cblxuICAgIGlmIChlICYmIGUudGFyZ2V0ICYmIGUudGFyZ2V0LnNlbGVjdGlvblN0YXJ0KSB7XG4gICAgICBzZXRDdXJzb3IoZS50YXJnZXQuc2VsZWN0aW9uU3RhcnQpO1xuICAgIH0gLy8gQ2FsbCBtYXNrIGlmIGl0IHdhcyBwYXNzZWRcblxuXG4gICAgaWYgKG1hc2sgJiYgIW1hc2tPbkJsdXIpIHtcbiAgICAgIG1hc2tlZFZhbCA9IG1hc2sodmFsLCBnZXRDdXJzb3IoKSk7XG4gICAgICB2YWwgPSBtYXNrKHZhbCwgZ2V0Q3Vyc29yKCkpO1xuICAgIH0gLy8gQ2FsbCBtYXNrV2l0aEN1cnNvck9mZnNldCBpZiBpdCB3YXMgcGFzc2VkXG5cblxuICAgIGlmIChtYXNrV2l0aEN1cnNvck9mZnNldCAmJiAhbWFza09uQmx1cikge1xuICAgICAgdmFyIHJlcyA9IG1hc2tXaXRoQ3Vyc29yT2Zmc2V0KHZhbCwgZ2V0Q3Vyc29yKCkpO1xuICAgICAgbWFza2VkVmFsID0gcmVzLnZhbHVlO1xuICAgICAgdmFsID0gcmVzLnZhbHVlO1xuICAgICAgc2V0Q3Vyc29yT2Zmc2V0KHJlcy5vZmZzZXQpO1xuICAgIH0gLy8gQ2FsbCBmb3JtYXQgYW5kIHBhcnNlIGlmIHRoZXkgd2VyZSBwYXNzZWRcblxuXG4gICAgaWYgKGZvcm1hdCAmJiBwYXJzZSkge1xuICAgICAgLy8gTWFza2VkIHZhbHVlIG9ubHkgZGlmZmVycyBmcm9tIHZhbHVlIHdoZW4gZm9ybWF0IGFuZCBwYXJzZSBhcmUgdXNlZFxuICAgICAgdmFsID0gcGFyc2UodmFsKTtcbiAgICAgIG1hc2tlZFZhbCA9IGZvcm1hdCh2YWwpO1xuICAgIH0gLy8gQ2FsbCBmb3JtYXR0ZXIgYW5kIHBhcnNlciBpZiBwYXNzZWRcblxuXG4gICAgaWYgKGZvcm1hdHRlcikge1xuICAgICAgdmFyIF9yZXMgPSBpbmZvcm1lZEZvcm1hdCh2YWwsIGZvcm1hdHRlcik7XG5cbiAgICAgIHNldEN1cnNvck9mZnNldChfcmVzLm9mZnNldCk7XG4gICAgICBtYXNrZWRWYWwgPSBfcmVzLnZhbHVlO1xuICAgICAgdmFsID0gbWFza2VkVmFsO1xuICAgIH0gLy8gLy8gT25seSBwYXJzZSBpZiBwYXJzZXIgd2FzIHBhc3NlZFxuXG5cbiAgICBpZiAocGFyc2VyKSB7XG4gICAgICB2YWwgPSB2YWwgIT0gbnVsbCA/IHBhcnNlcih2YWwpIDogdmFsO1xuICAgIH0gLy8gV2Ugb25seSBuZWVkIHRvIGNhbGwgdmFsaWRhdGUgaWYgdGhlIHVzZXIgZ2F2ZSB1cyBvbmVcbiAgICAvLyBhbmQgdGhleSB3YW50IHVzIHRvIHZhbGlkYXRlIG9uIGNoYW5nZSAmJiBpdHMgbm90IHRoZSBpbml0aWFsIHZhbGlkYXRpb25cblxuXG4gICAgaWYgKHZhbGlkYXRlICYmIHZhbGlkYXRlT25DaGFuZ2UgJiYgIW9wdGlvbnMuaW5pdGlhbCkge1xuICAgICAgbG9nZ2VyKFwiVmFsaWRhdGluZyBhZnRlciBjaGFuZ2UgXCIuY29uY2F0KGZpZWxkLCBcIiBcIikuY29uY2F0KHZhbCkpO1xuICAgICAgc2V0RXJyb3IodmFsaWRhdGUodmFsLCBmb3JtQXBpLmdldFZhbHVlcygpKSk7XG4gICAgfSAvLyBOb3cgd2UgdXBkYXRlIHRoZSB2YWx1ZVxuXG5cbiAgICBzZXRWYWwodmFsKTtcbiAgICBzZXRNYXNrZWRWYWx1ZShtYXNrZWRWYWwpOyAvLyBJZiB0aGUgdXNlciBwYXNzZWQgaW4gb25WYWx1ZUNoYW5nZSB0aGVuIGNhbGwgaXQhXG5cbiAgICBpZiAob25WYWx1ZUNoYW5nZSkge1xuICAgICAgb25WYWx1ZUNoYW5nZSh2YWwpO1xuICAgIH0gLy8gQ2FsbCB0aGUgdXBkYXRlclxuXG5cbiAgICB1cGRhdGVyLnNldFZhbHVlKGZpZWxkSWQsIHZhbCwgIW9wdGlvbnMucHJldmVudFVwZGF0ZSk7XG4gIH07IC8vIC0tLS0gRGVmaW5lIHNldCB0b3VjaGVkIC0tLS1cblxuXG4gIHZhciBzZXRUb3VjaGVkID0gZnVuY3Rpb24gc2V0VG91Y2hlZCh2YWwsIHJlc2V0KSB7XG4gICAgdmFyIF9yZWY2ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fSxcbiAgICAgICAgcHJldmVudFVwZGF0ZSA9IF9yZWY2LnByZXZlbnRVcGRhdGU7XG5cbiAgICBsb2dnZXIoXCJGaWVsZCBcIi5jb25jYXQoZmllbGQsIFwiIGhhcyBiZWVuIHRvdWNoZWRcIikpOyAvLyBXZSBvbmx5IG5lZWQgdG8gY2FsbCB2YWxpZGF0ZSBpZiB0aGUgdXNlciBnYXZlIHVzIG9uZVxuICAgIC8vIGFuZCB0aGV5IHdhbnQgdXMgdG8gdmFsaWRhdGUgb24gYmx1clxuXG4gICAgaWYgKHZhbGlkYXRlICYmIHZhbGlkYXRlT25CbHVyICYmICFyZXNldCAmJiB2YWwpIHtcbiAgICAgIGxvZ2dlcihcIlZhbGlkYXRpbmcgYWZ0ZXIgYmx1ciBcIi5jb25jYXQoZmllbGQsIFwiIFwiKS5jb25jYXQoZ2V0VmFsKCkpKTtcbiAgICAgIHNldEVycm9yKHZhbGlkYXRlKGdldFZhbCgpLCBmb3JtQXBpLmdldFZhbHVlcygpKSk7XG4gICAgfSAvLyBTYW1lIGZvciBhc3luY1xuXG5cbiAgICBpZiAoYXN5bmNWYWxpZGF0ZSAmJiBhc3luY1ZhbGlkYXRlT25CbHVyICYmICFyZXNldCAmJiB2YWwpIHtcbiAgICAgIGxvZ2dlcihcIlZhbGlkYXRpbmcgYXN5bmMgYWZ0ZXIgYmx1ciBcIi5jb25jYXQoZmllbGQsIFwiIFwiKS5jb25jYXQoZ2V0VmFsKCkpKTtcbiAgICAgIGFzeW5jVmFsaWRhdGUoZ2V0VmFsKCksIGZvcm1BcGkuZ2V0VmFsdWVzKCkpO1xuICAgIH0gLy8gQ2FsbCBtYXNrIGlmIGl0IHdhcyBwYXNzZWRcblxuXG4gICAgaWYgKG1hc2sgJiYgbWFza09uQmx1cikge1xuICAgICAgLy8gR2VuZXJhdGUgdGhlIG1hc2tlZCB2YWx1ZSBmcm9tIHRoZSBjdXJyZW50IHZhbHVlXG4gICAgICB2YXIgbWFza2VkVmFsID0gbWFzayhnZXRWYWwoKSk7IC8vIE5vdyB3ZSB1cGRhdGUgdGhlIHZhbHVlXG5cbiAgICAgIHNldFZhbChtYXNrZWRWYWwpO1xuICAgICAgc2V0TWFza2VkVmFsdWUobWFza2VkVmFsKTsgLy8gSWYgdGhlIHVzZXIgcGFzc2VkIGluIG9uVmFsdWVDaGFuZ2UgdGhlbiBjYWxsIGl0IVxuXG4gICAgICBpZiAob25WYWx1ZUNoYW5nZSkge1xuICAgICAgICBvblZhbHVlQ2hhbmdlKG1hc2tlZFZhbCk7XG4gICAgICB9IC8vIENhbGwgdGhlIHVwZGF0ZXJcblxuXG4gICAgICB1cGRhdGVyLnNldFZhbHVlKGZpZWxkSWQsIG1hc2tlZFZhbCwgIXByZXZlbnRVcGRhdGUpO1xuICAgIH0gLy8gQ2FsbCBtYXNrV2l0aEN1cnNvck9mZnNldCBpZiBpdCB3YXMgcGFzc2VkXG5cblxuICAgIGlmIChtYXNrV2l0aEN1cnNvck9mZnNldCAmJiBtYXNrT25CbHVyKSB7XG4gICAgICAvLyBHZW5lcmF0ZSB0aGUgbWFzayBhbmQgb2Zmc2V0XG4gICAgICB2YXIgcmVzID0gbWFza1dpdGhDdXJzb3JPZmZzZXQoZ2V0VmFsKCkpOyAvLyBTZXQgdGhlIG9mZnNldFxuXG4gICAgICBzZXRDdXJzb3JPZmZzZXQocmVzLm9mZnNldCk7IC8vIE5vdyB3ZSB1cGRhdGUgdGhlIHZhbHVlXG5cbiAgICAgIHNldFZhbChyZXMudmFsdWUpO1xuICAgICAgc2V0TWFza2VkVmFsdWUocmVzLnZhbHVlKTsgLy8gSWYgdGhlIHVzZXIgcGFzc2VkIGluIG9uVmFsdWVDaGFuZ2UgdGhlbiBjYWxsIGl0IVxuXG4gICAgICBpZiAob25WYWx1ZUNoYW5nZSkge1xuICAgICAgICBvblZhbHVlQ2hhbmdlKHJlcy52YWx1ZSk7XG4gICAgICB9IC8vIENhbGwgdGhlIHVwZGF0ZXJcblxuXG4gICAgICB1cGRhdGVyLnNldFZhbHVlKGZpZWxkSWQsIHJlcy52YWx1ZSwgIXByZXZlbnRVcGRhdGUpO1xuICAgIH0gLy8gRmluYWxseSB3ZSBzZXQgdG91Y2hlZCBhbmQgY2FsbCB0aGUgdXBkYXRlclxuXG5cbiAgICBzZXRUb3VjaCh2YWwpO1xuICAgIHVwZGF0ZXIuc2V0VG91Y2hlZChmaWVsZElkLCB2YWwsICFwcmV2ZW50VXBkYXRlKTtcbiAgfTsgLy8gLS0tLSBEZWZpbmUgcmVzZXQgLS0tLVxuXG5cbiAgdmFyIHJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgdmFyIF9yZWY3ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgICAgcHJldmVudFVwZGF0ZSA9IF9yZWY3LnByZXZlbnRVcGRhdGU7XG5cbiAgICB2YXIgaW5pdFZhbCA9IGluaXRpYWxpemVWYWx1ZShpbml0aWFsVmFsdWVSZWYuY3VycmVudCB8fCB1cGRhdGVyLmdldEluaXRpYWxWYWx1ZShmaWVsZFJlZi5jdXJyZW50KSwgbWFzaywgZm9ybWF0dGVyLCBwYXJzZXIpOyAvLyBUT0RPIHN1cHBvcnQgbnVtYmVyc1xuXG4gICAgc2V0VmFsdWUoaW5pdFZhbCwgbnVsbCwge1xuICAgICAgaW5pdGlhbDogdHJ1ZSxcbiAgICAgIHByZXZlbnRVcGRhdGU6IHByZXZlbnRVcGRhdGVcbiAgICB9KTsgLy8gU2V0dGluZyBzb210aGluZyB0byB1bmRlZmluZWQgd2lsbCByZW1vdmUgaXRcblxuICAgIHNldEVycm9yKHZhbGlkYXRlT25Nb3VudCA/IHZhbGlkYXRlKGluaXRWYWwpIDogdW5kZWZpbmVkLCB7XG4gICAgICBwcmV2ZW50VXBkYXRlOiBwcmV2ZW50VXBkYXRlXG4gICAgfSk7XG4gICAgc2V0VG91Y2hlZCh1bmRlZmluZWQsIHRydWUsIHtcbiAgICAgIHByZXZlbnRVcGRhdGU6IHByZXZlbnRVcGRhdGVcbiAgICB9KTtcbiAgfTsgLy8gLS0tLSBEZWZpbmUgdmFsaWRhdGUgLS0tLVxuICAvLyBOb3RlOiBpdCB0YWtlcyB2YWx1ZXMgYXMgYW4gb3B0aW1pemF0aW9uIGZvciB3aGVuXG4gIC8vIHRoZSBmb3JtIGNvbnRyb2xsZXIgY2FsbHMgaXQgKCBkb250IG5lZWQgdG8gZ2VuZXJhdGUgYWxsIHZhbHVlcyApXG4gIC8vIG92ZXIgYW5kIG92ZXIgOilcblxuXG4gIHZhciBmaWVsZFZhbGlkYXRlID0gZnVuY3Rpb24gZmllbGRWYWxpZGF0ZSh2YWx1ZXMpIHtcbiAgICBpZiAodmFsaWRhdGUpIHtcbiAgICAgIGxvZ2dlcihcIkZpZWxkIHZhbGlkYXRpbmcgXCIuY29uY2F0KGZpZWxkLCBcIiBcIikuY29uY2F0KGdldFZhbCgpKSk7XG4gICAgICBzZXRFcnJvcih2YWxpZGF0ZShnZXRWYWwoKSwgdmFsdWVzIHx8IGZvcm1BcGkuZ2V0VmFsdWVzKCkpKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGZpZWxkQXN5bmNWYWxpZGF0ZSA9IGZ1bmN0aW9uIGZpZWxkQXN5bmNWYWxpZGF0ZSh2YWx1ZXMpIHtcbiAgICBpZiAoYXN5bmNWYWxpZGF0ZSkge1xuICAgICAgbG9nZ2VyKFwiRmllbGQgYXN5bmMgdmFsaWRhdGluZyBcIi5jb25jYXQoZmllbGQsIFwiIFwiKS5jb25jYXQoZ2V0VmFsKCkpKTtcbiAgICAgIGFzeW5jVmFsaWRhdGUoZ2V0VmFsKCksIHZhbHVlcyB8fCBmb3JtQXBpLmdldFZhbHVlcygpKTtcbiAgICB9XG4gIH07XG4gIC8qIC0tLS0tLS0tLS0tLS0tLS0tIEZpZWxkIEFwaSAmJiBTdGF0ZSAtLS0tLS0tLS0tLS0tLS0tLSAqL1xuICAvLyBCdWlsZCB0aGUgZmllbGQgYXBpXG5cblxuICB2YXIgZmllbGRBcGkgPSB7XG4gICAgc2V0VmFsdWU6IHNldFZhbHVlLFxuICAgIHNldFRvdWNoZWQ6IHNldFRvdWNoZWQsXG4gICAgc2V0RXJyb3I6IHNldEVycm9yLFxuICAgIHJlc2V0OiByZXNldCxcbiAgICB2YWxpZGF0ZTogZmllbGRWYWxpZGF0ZSxcbiAgICBhc3luY1ZhbGlkYXRlOiBmaWVsZEFzeW5jVmFsaWRhdGUsXG4gICAgZ2V0VmFsdWU6IGdldFZhbCxcbiAgICBnZXRUb3VjaGVkOiBnZXRUb3VjaCxcbiAgICBnZXRFcnJvcjogZ2V0RXJyLFxuICAgIGdldElzUmVsZXZhbnQ6IGdldElzUmVsZXZhbnQsXG4gICAgZ2V0RmllbGRTdGF0ZTogZnVuY3Rpb24gZ2V0RmllbGRTdGF0ZSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiBnZXRWYWwoKSxcbiAgICAgICAgdG91Y2hlZDogZ2V0VG91Y2goKVxuICAgICAgfTtcbiAgICB9LFxuICAgIHJlbGV2YW50OiByZWxldmFudCxcbiAgICBtdWx0aXN0ZXBSZWxldmFudDogbXVsdGlzdGVwUmVsZXZhbnQsXG4gICAgY2hlY2tSZWxldmFudDogY2hlY2tSZWxldmFudFxuICB9O1xuICBmaWVsZEFwaVJlZi5jdXJyZW50ID0gZmllbGRBcGk7IC8vIEJ1aWxkIHRoZSBmaWVsZCBzdGF0ZVxuXG4gIHZhciBmaWVsZFN0YXRlID0ge1xuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBlcnJvcjogZXJyb3IsXG4gICAgdG91Y2hlZDogdG91Y2hlZCxcbiAgICBtYXNrZWRWYWx1ZTogbWFza2VkVmFsdWUsXG4gICAgaXNSZWxldmFudDogaXNSZWxldmFudFxuICB9OyAvLyBDcmVhdGUgc2hhZG93IHN0YXRlIGlmIHRoaXMgaXMgYSBzaGFkb3cgZmllbGRcblxuICBpZiAoc2hhZG93KSB7XG4gICAgZmllbGRTdGF0ZSA9IHtcbiAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgIHRvdWNoZWQ6IHRvdWNoZWRcbiAgICB9O1xuICB9XG5cbiAgbG9nZ2VyKCdSZW5kZXInLCBmb3JtQXBpLmdldEZ1bGxGaWVsZChmaWVsZCksIGZpZWxkU3RhdGUpO1xuICB2YXIgaW50ZXJuYWxSZWYgPSB1c2VSZWYobnVsbCk7XG4gIHZhciByZWYgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdXNlclJlZiB8fCBpbnRlcm5hbFJlZjtcbiAgfSwgW10pOyAvLyBXZSB3YW50IHRvIHJlZ2lzdGVyIGFuZCBkZXJlZ2lzdGVyIHRoaXMgZmllbGRcblxuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZnVsbEZpZWxkID0gZm9ybUFwaS5nZXRGdWxsRmllbGQoZmllbGRSZWYuY3VycmVudCk7XG4gICAgbG9nZ2VyKCdSZWdpc3RlcicsIGZpZWxkSWQsIGZpZWxkUmVmLmN1cnJlbnQpO1xuICAgIGZpZWxkT2JqZWN0UmVmLmN1cnJlbnQgPSB7XG4gICAgICBmaWVsZDogZnVsbEZpZWxkLFxuICAgICAgZmllbGRJZDogZmllbGRJZCxcbiAgICAgIGZpZWxkQXBpOiBmaWVsZEFwaSxcbiAgICAgIGZpZWxkU3RhdGU6IGZpZWxkU3RhdGUsXG4gICAgICBub3RpZnk6IG5vdGlmeSxcbiAgICAgIGtlZXBTdGF0ZToga2VlcFN0YXRlLFxuICAgICAgaW5NdWx0aXN0ZXA6IGluTXVsdGlzdGVwLFxuICAgICAgc2hhZG93OiBzaGFkb3dcbiAgICB9O1xuICAgIHVwZGF0ZXIucmVnaXN0ZXIoZmllbGRJZCwgZmllbGRPYmplY3RSZWYuY3VycmVudCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBmdWxsRmllbGQgPSBmb3JtQXBpLmdldEZ1bGxGaWVsZChmaWVsZFJlZi5jdXJyZW50KTtcbiAgICAgIGxvZ2dlcignRGVyZWdpc3RlcicsIGZpZWxkSWQsIGZ1bGxGaWVsZCk7XG4gICAgICB1cGRhdGVyLmRlcmVnaXN0ZXIoZmllbGRJZCk7XG4gICAgfTtcbiAgfSwgW10pOyAvLyBXZSB3YW50IHRvIGxldCB0aGUgY29udHJvbGxlciBrbm93IG9mIGNoYW5nZXMgb24gdGhpcyBmaWVsZCB3aGVuIHNwZWNpZmljIHByb3BzIGNoYW5nZVxuXG4gIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZ1bGxGaWVsZCA9IGZvcm1BcGkuZ2V0RnVsbEZpZWxkKGZpZWxkKTtcblxuICAgIGlmIChpbml0aWFsUmVuZXJSZWYuY3VycmVudCkge1xuICAgICAgaW5pdGlhbFJlbmVyUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nZ2VyKCdVcGRhdGUnLCBmaWVsZCwgaW5NdWx0aXN0ZXApO1xuICAgICAgZmllbGRPYmplY3RSZWYuY3VycmVudC5maWVsZCA9IGZ1bGxGaWVsZDtcbiAgICAgIHVwZGF0ZXIudXBkYXRlKGZpZWxkSWQsIGZpZWxkT2JqZWN0UmVmLmN1cnJlbnQsIHByZXZGaWVsZFJlZi5jdXJyZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcHJldkZpZWxkUmVmLmN1cnJlbnQgPSBmdWxsRmllbGQ7XG4gICAgfTtcbiAgfSwgW2ZpZWxkXSk7IC8vIE1haW50YWluIGN1cnNvciBwb3NpdGlvblxuXG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmIChtYWludGFpbkN1cnNvciAmJiByZWYuY3VycmVudCAhPSBudWxsICYmIGdldEN1cnNvcigpKSByZWYuY3VycmVudC5zZWxlY3Rpb25FbmQgPSBnZXRDdXJzb3IoKSArIGdldEN1cnNvck9mZnNldCgpO1xuICB9LCBbdmFsdWVdKTsgLy8gZm9yIGRlYnVnZ2luZ1xuXG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmIChkZWJ1ZyAmJiByZWYpIHtcbiAgICAgIHJlZi5jdXJyZW50LnN0eWxlLmJvcmRlciA9ICc1cHggc29saWQgb3JhbmdlJztcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICByZWYuY3VycmVudC5zdHlsZS5ib3JkZXJXaWR0aCA9ICcycHgnO1xuICAgICAgICByZWYuY3VycmVudC5zdHlsZS5ib3JkZXJTdHlsZSA9ICdpbnNldCc7XG4gICAgICAgIHJlZi5jdXJyZW50LnN0eWxlLmJvcmRlckNvbG9yID0gJ2luaXRpYWwnO1xuICAgICAgICByZWYuY3VycmVudC5zdHlsZS5ib3JkZXJJbWFnZSA9ICdpbml0aWFsJztcbiAgICAgIH0sIDUwMCk7XG4gICAgfVxuICB9KTsgLy8gVGhpcyBpcyBhbiBhd2Vzb21lIG9wdGltaXphdGlvbiEhXG5cbiAgdmFyIHNob3VsZFVwZGF0ZSA9IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoT2JqZWN0LnZhbHVlcyhmaWVsZFN0YXRlKSksIF90b0NvbnN1bWFibGVBcnJheShPYmplY3QudmFsdWVzKGZpZWxkUHJvcHMpKSwgX3RvQ29uc3VtYWJsZUFycmF5KE9iamVjdC52YWx1ZXModXNlclByb3BzKSkpO1xuXG4gIHZhciByZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoY2hpbGRyZW4pIHtcbiAgICByZXR1cm4gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gaXNSZWxldmFudCA/IGNoaWxkcmVuIDogbnVsbDtcbiAgICB9LCBfdG9Db25zdW1hYmxlQXJyYXkoc2hvdWxkVXBkYXRlKSk7XG4gIH07IC8vIEJ1aWxkIHNvbWUgc2V0dWIgZmllbGRzIHNvIHVzZXJzIGNhbiBlYXNpbHkgaW50YWdyYXRlIHdpdGhvdXQgYW55IGhvb2t1cCBjb2RlXG5cblxuICB2YXIgbmFtZSA9IGZpZWxkO1xuICB2YXIgY2hhbmdlSGFuZGxlciA9IGdlbmVyYXRlT25DaGFuZ2Uoe1xuICAgIGZpZWxkVHlwZTogZmllbGRUeXBlLFxuICAgIHNldFZhbHVlOiBzZXRWYWx1ZSxcbiAgICBvbkNoYW5nZTogb25DaGFuZ2UsXG4gICAgbXVsdGlwbGU6IG11bHRpcGxlLFxuICAgIHJlZjogcmVmXG4gIH0pO1xuICB2YXIgYmx1ckhhbmRsZXIgPSBnZW5lcmF0ZU9uQmx1cih7XG4gICAgc2V0VG91Y2hlZDogc2V0VG91Y2hlZCxcbiAgICBvbkJsdXI6IG9uQmx1clxuICB9KTtcbiAgdmFyIGhvb2tlZFZhbHVlID0gZ2VuZXJhdGVWYWx1ZSh7XG4gICAgZmllbGRUeXBlOiBmaWVsZFR5cGUsXG4gICAgbWFza2VkVmFsdWU6IG1hc2tlZFZhbHVlLFxuICAgIG11bHRpcGxlOiBtdWx0aXBsZSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfSk7XG4gIHZhciB0eXBlID0gZ2VuZXJhdGVGaWVsZFR5cGUoZmllbGRUeXBlKTtcbiAgcmV0dXJuIHtcbiAgICBmaWVsZFN0YXRlOiBmaWVsZFN0YXRlLFxuICAgIGZpZWxkQXBpOiBmaWVsZEFwaSxcbiAgICByZW5kZXI6IHJlbmRlcixcbiAgICByZWY6IHJlZixcbiAgICB1c2VyUHJvcHM6IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCB1c2VyUHJvcHMpLCB7fSwge1xuICAgICAgbXVsdGlwbGU6IG11bHRpcGxlLFxuICAgICAgLy8gV0UgTkVFRCBUTyBQVVQgVEhFU0UgQkFDSyEhXG4gICAgICBvbkNoYW5nZTogb25DaGFuZ2UsXG4gICAgICAvLyBXRSBORUVEIFRPIFBVVCBUSEVTRSBCQUNLISFcbiAgICAgIG9uQmx1cjogb25CbHVyLFxuICAgICAgLy8gV0UgTkVFRCBUTyBQVVQgVEhFU0UgQkFDSyEhXG4gICAgICAvLyByZXF1aXJlZCAvLyBXRSBORUVEIFRPIFBVVCBUSEVTRSBCQUNLISFcbiAgICAgIGlkOiB1c2VyUHJvcHMuaWQgfHwgZmllbGRJZCAvLyBJZiB1c2VyIGRpZCBub3QgcGFzcyBpZCB3ZSBwYXNzIGZpZWxkcyBpZFxuXG4gICAgfSksXG4gICAgaW5mb3JtZWQ6IF9vYmplY3RTcHJlYWQyKHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBtdWx0aXBsZTogbXVsdGlwbGUsXG4gICAgICBvbkNoYW5nZTogY2hhbmdlSGFuZGxlcixcbiAgICAgIG9uQmx1cjogYmx1ckhhbmRsZXIsXG4gICAgICB2YWx1ZTogaG9va2VkVmFsdWUsXG4gICAgICByZWY6IHJlZixcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBpZDogdXNlclByb3BzLmlkIHx8IGZpZWxkSWRcbiAgICB9LCB1c2VyUHJvcHMpXG4gIH07XG59XG5cbnZhciBhc0ZpZWxkID0gZnVuY3Rpb24gYXNGaWVsZChDb21wb25lbnQpIHtcbiAgdmFyIGZvcndhcmRSZWYgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiAocHJvcHMsIHVzZXJSZWYpIHtcbiAgICB2YXIgX3VzZUZpZWxkID0gdXNlRmllbGQocHJvcHMsIHVzZXJSZWYpLFxuICAgICAgICBmaWVsZFN0YXRlID0gX3VzZUZpZWxkLmZpZWxkU3RhdGUsXG4gICAgICAgIGZpZWxkQXBpID0gX3VzZUZpZWxkLmZpZWxkQXBpLFxuICAgICAgICByZW5kZXIgPSBfdXNlRmllbGQucmVuZGVyLFxuICAgICAgICByZWYgPSBfdXNlRmllbGQucmVmLFxuICAgICAgICB1c2VyUHJvcHMgPSBfdXNlRmllbGQudXNlclByb3BzO1xuXG4gICAgcmV0dXJuIHJlbmRlciggLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50LCBfZXh0ZW5kcyh7XG4gICAgICBmaWVsZEFwaTogZmllbGRBcGksXG4gICAgICBmaWVsZFN0YXRlOiBmaWVsZFN0YXRlLFxuICAgICAgZmllbGQ6IHByb3BzLmZpZWxkLFxuICAgICAgZm9yd2FyZGVkUmVmOiByZWYsXG4gICAgICBkZWJ1ZzogcHJvcHMuZGVidWcsXG4gICAgICB0eXBlOiBwcm9wcy50eXBlXG4gICAgfSwgdXNlclByb3BzKSkpO1xuICB9KTtcbiAgZm9yd2FyZFJlZi5kaXNwbGF5TmFtZSA9IFwiYXNGaWVsZChcIi5jb25jYXQoZ2V0Q2hpbGREaXNwbGF5TmFtZShDb21wb25lbnQpLCBcIilcIik7XG4gIHJldHVybiBmb3J3YXJkUmVmO1xufTtcblxudmFyIGxvZ2dlciQxID0gZGVidWcoJ2luZm9ybWVkOlRleHQnICsgJ1xcdCcpO1xuXG52YXIgVGV4dCA9IGZ1bmN0aW9uIFRleHQoX3JlZikge1xuICB2YXIgZmllbGRBcGkgPSBfcmVmLmZpZWxkQXBpLFxuICAgICAgZmllbGRTdGF0ZSA9IF9yZWYuZmllbGRTdGF0ZSxcbiAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFtcImZpZWxkQXBpXCIsIFwiZmllbGRTdGF0ZVwiXSk7XG5cbiAgdmFyIG1hc2tlZFZhbHVlID0gZmllbGRTdGF0ZS5tYXNrZWRWYWx1ZTtcbiAgdmFyIHNldFZhbHVlID0gZmllbGRBcGkuc2V0VmFsdWUsXG4gICAgICBzZXRUb3VjaGVkID0gZmllbGRBcGkuc2V0VG91Y2hlZDtcblxuICB2YXIgX29uQ2hhbmdlID0gcHJvcHMub25DaGFuZ2UsXG4gICAgICBfb25CbHVyID0gcHJvcHMub25CbHVyLFxuICAgICAgZmllbGQgPSBwcm9wcy5maWVsZCxcbiAgICAgIGluaXRpYWxWYWx1ZSA9IHByb3BzLmluaXRpYWxWYWx1ZSxcbiAgICAgIGZvcndhcmRlZFJlZiA9IHByb3BzLmZvcndhcmRlZFJlZixcbiAgICAgIGRlYnVnID0gcHJvcHMuZGVidWcsXG4gICAgICBsYWJlbCA9IHByb3BzLmxhYmVsLFxuICAgICAgdGl0bGUgPSBwcm9wcy50aXRsZSxcbiAgICAgIGlkID0gcHJvcHMuaWQsXG4gICAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBbXCJvbkNoYW5nZVwiLCBcIm9uQmx1clwiLCBcImZpZWxkXCIsIFwiaW5pdGlhbFZhbHVlXCIsIFwiZm9yd2FyZGVkUmVmXCIsIFwiZGVidWdcIiwgXCJsYWJlbFwiLCBcInRpdGxlXCIsIFwiaWRcIl0pO1xuXG4gIGxvZ2dlciQxKCdSZW5kZXInLCBmaWVsZCk7IC8vIGZvciBkZWJ1Z2dpbmdcblxuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZGVidWcgJiYgZm9yd2FyZGVkUmVmKSB7XG4gICAgICBmb3J3YXJkZWRSZWYuY3VycmVudC5zdHlsZS5iYWNrZ3JvdW5kID0gJ3JlZCc7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yd2FyZGVkUmVmLmN1cnJlbnQuc3R5bGUuYmFja2dyb3VuZCA9ICd3aGl0ZSc7XG4gICAgICB9LCA1MDApO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgbGFiZWwgPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImxhYmVsXCIsIHtcbiAgICBodG1sRm9yOiBpZFxuICB9LCBcIiBcIiwgbGFiZWwsIFwiIFwiKSA6IG51bGwsIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIiwgX2V4dGVuZHMoe30sIHJlc3QsIHtcbiAgICBpZDogaWQsXG4gICAgbmFtZTogZmllbGQsXG4gICAgcmVmOiBmb3J3YXJkZWRSZWYsXG4gICAgdmFsdWU6ICFtYXNrZWRWYWx1ZSAmJiBtYXNrZWRWYWx1ZSAhPT0gMCA/ICcnIDogbWFza2VkVmFsdWUsXG4gICAgb25DaGFuZ2U6IGZ1bmN0aW9uIG9uQ2hhbmdlKGUpIHtcbiAgICAgIHNldFZhbHVlKGUudGFyZ2V0LnZhbHVlLCBlKTtcblxuICAgICAgaWYgKF9vbkNoYW5nZSkge1xuICAgICAgICBfb25DaGFuZ2UoZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBvbkJsdXI6IGZ1bmN0aW9uIG9uQmx1cihlKSB7XG4gICAgICBzZXRUb3VjaGVkKHRydWUpO1xuXG4gICAgICBpZiAoX29uQmx1cikge1xuICAgICAgICBfb25CbHVyKGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSkpKTtcbn07XG52YXIgVGV4dCQxID0gYXNGaWVsZChUZXh0KTtcblxudmFyIFRleHRBcmVhID0gZnVuY3Rpb24gVGV4dEFyZWEoX3JlZikge1xuICB2YXIgZmllbGRBcGkgPSBfcmVmLmZpZWxkQXBpLFxuICAgICAgZmllbGRTdGF0ZSA9IF9yZWYuZmllbGRTdGF0ZSxcbiAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFtcImZpZWxkQXBpXCIsIFwiZmllbGRTdGF0ZVwiXSk7XG5cbiAgdmFyIG1hc2tlZFZhbHVlID0gZmllbGRTdGF0ZS5tYXNrZWRWYWx1ZTtcbiAgdmFyIHNldFZhbHVlID0gZmllbGRBcGkuc2V0VmFsdWUsXG4gICAgICBzZXRUb3VjaGVkID0gZmllbGRBcGkuc2V0VG91Y2hlZDtcblxuICB2YXIgX29uQ2hhbmdlID0gcHJvcHMub25DaGFuZ2UsXG4gICAgICBfb25CbHVyID0gcHJvcHMub25CbHVyLFxuICAgICAgZmllbGQgPSBwcm9wcy5maWVsZCxcbiAgICAgIGluaXRpYWxWYWx1ZSA9IHByb3BzLmluaXRpYWxWYWx1ZSxcbiAgICAgIGZvcndhcmRlZFJlZiA9IHByb3BzLmZvcndhcmRlZFJlZixcbiAgICAgIGRlYnVnID0gcHJvcHMuZGVidWcsXG4gICAgICBsYWJlbCA9IHByb3BzLmxhYmVsLFxuICAgICAgaWQgPSBwcm9wcy5pZCxcbiAgICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocHJvcHMsIFtcIm9uQ2hhbmdlXCIsIFwib25CbHVyXCIsIFwiZmllbGRcIiwgXCJpbml0aWFsVmFsdWVcIiwgXCJmb3J3YXJkZWRSZWZcIiwgXCJkZWJ1Z1wiLCBcImxhYmVsXCIsIFwiaWRcIl0pOyAvLyBmb3IgZGVidWdnaW5nXG5cblxuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZGVidWcgJiYgZm9yd2FyZGVkUmVmKSB7XG4gICAgICBmb3J3YXJkZWRSZWYuY3VycmVudC5zdHlsZS5iYWNrZ3JvdW5kID0gJ3JlZCc7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yd2FyZGVkUmVmLmN1cnJlbnQuc3R5bGUuYmFja2dyb3VuZCA9ICd3aGl0ZSc7XG4gICAgICB9LCA1MDApO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgbGFiZWwgPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImxhYmVsXCIsIHtcbiAgICBodG1sRm9yOiBpZFxuICB9LCBcIiBcIiwgbGFiZWwsIFwiIFwiKSA6IG51bGwsIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwidGV4dGFyZWFcIiwgX2V4dGVuZHMoe30sIHJlc3QsIHtcbiAgICBpZDogaWQsXG4gICAgbmFtZTogZmllbGQsXG4gICAgcmVmOiBmb3J3YXJkZWRSZWYsXG4gICAgdmFsdWU6ICFtYXNrZWRWYWx1ZSA/ICcnIDogbWFza2VkVmFsdWUsXG4gICAgb25DaGFuZ2U6IGZ1bmN0aW9uIG9uQ2hhbmdlKGUpIHtcbiAgICAgIHNldFZhbHVlKGUudGFyZ2V0LnZhbHVlLCBlKTtcblxuICAgICAgaWYgKF9vbkNoYW5nZSkge1xuICAgICAgICBfb25DaGFuZ2UoZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBvbkJsdXI6IGZ1bmN0aW9uIG9uQmx1cihlKSB7XG4gICAgICBzZXRUb3VjaGVkKHRydWUpO1xuXG4gICAgICBpZiAoX29uQmx1cikge1xuICAgICAgICBfb25CbHVyKGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSkpKTtcbn07XG52YXIgVGV4dEFyZWEkMSA9IGFzRmllbGQoVGV4dEFyZWEpO1xuXG52YXIgbG9nZ2VyJDIgPSBkZWJ1ZygnaW5mb3JtZWQ6U2VsZWN0JyArICdcXHQnKTtcblxudmFyIFNlbGVjdCA9IGZ1bmN0aW9uIFNlbGVjdChfcmVmKSB7XG4gIHZhciBmaWVsZEFwaSA9IF9yZWYuZmllbGRBcGksXG4gICAgICBmaWVsZFN0YXRlID0gX3JlZi5maWVsZFN0YXRlLFxuICAgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgW1wiZmllbGRBcGlcIiwgXCJmaWVsZFN0YXRlXCJdKTtcblxuICB2YXIgdmFsdWUgPSBmaWVsZFN0YXRlLnZhbHVlO1xuICB2YXIgc2V0VG91Y2hlZCA9IGZpZWxkQXBpLnNldFRvdWNoZWQ7XG5cbiAgdmFyIG9uQ2hhbmdlID0gcHJvcHMub25DaGFuZ2UsXG4gICAgICBfb25CbHVyID0gcHJvcHMub25CbHVyLFxuICAgICAgZmllbGQgPSBwcm9wcy5maWVsZCxcbiAgICAgIGluaXRpYWxWYWx1ZSA9IHByb3BzLmluaXRpYWxWYWx1ZSxcbiAgICAgIG9wdGlvbnMgPSBwcm9wcy5vcHRpb25zLFxuICAgICAgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbixcbiAgICAgIGZvcndhcmRlZFJlZiA9IHByb3BzLmZvcndhcmRlZFJlZixcbiAgICAgIGRlYnVnID0gcHJvcHMuZGVidWcsXG4gICAgICBtdWx0aXBsZSA9IHByb3BzLm11bHRpcGxlLFxuICAgICAgbGFiZWwgPSBwcm9wcy5sYWJlbCxcbiAgICAgIGlkID0gcHJvcHMuaWQsXG4gICAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBbXCJvbkNoYW5nZVwiLCBcIm9uQmx1clwiLCBcImZpZWxkXCIsIFwiaW5pdGlhbFZhbHVlXCIsIFwib3B0aW9uc1wiLCBcImNoaWxkcmVuXCIsIFwiZm9yd2FyZGVkUmVmXCIsIFwiZGVidWdcIiwgXCJtdWx0aXBsZVwiLCBcImxhYmVsXCIsIFwiaWRcIl0pO1xuXG4gIHZhciBzZWxlY3RSZWYgPSB1c2VSZWYoKTtcblxuICB2YXIgaGFuZGxlQ2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlQ2hhbmdlKGUpIHtcbiAgICB2YXIgc2VsZWN0ZWQgPSBBcnJheS5mcm9tKChmb3J3YXJkZWRSZWYgfHwgc2VsZWN0UmVmKS5jdXJyZW50KS5maWx0ZXIoZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgcmV0dXJuIG9wdGlvbi5zZWxlY3RlZDtcbiAgICB9KS5tYXAoZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgcmV0dXJuIG9wdGlvbi52YWx1ZTtcbiAgICB9KTtcbiAgICBmaWVsZEFwaS5zZXRWYWx1ZShtdWx0aXBsZSA/IHNlbGVjdGVkIDogc2VsZWN0ZWRbMF0gfHwgJycpO1xuXG4gICAgaWYgKG9uQ2hhbmdlICYmIGUpIHtcbiAgICAgIG9uQ2hhbmdlKGUpO1xuICAgIH1cbiAgfTsgLy8gZm9yIGRlYnVnZ2luZ1xuXG5cbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGRlYnVnICYmIGZvcndhcmRlZFJlZikge1xuICAgICAgZm9yd2FyZGVkUmVmLmN1cnJlbnQuc3R5bGUuYmFja2dyb3VuZCA9ICdyZWQnO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvcndhcmRlZFJlZi5jdXJyZW50LnN0eWxlLmJhY2tncm91bmQgPSAnd2hpdGUnO1xuICAgICAgfSwgNTAwKTtcbiAgICB9XG4gIH0pO1xuICBsb2dnZXIkMignUmVuZGVyJywgZmllbGQsIHZhbHVlKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBsYWJlbCA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwibGFiZWxcIiwge1xuICAgIGh0bWxGb3I6IGlkXG4gIH0sIFwiIFwiLCBsYWJlbCwgXCIgXCIpIDogbnVsbCwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzZWxlY3RcIiwgX2V4dGVuZHMoe30sIHJlc3QsIHtcbiAgICBpZDogaWQsXG4gICAgbXVsdGlwbGU6IG11bHRpcGxlLFxuICAgIG5hbWU6IGZpZWxkLFxuICAgIHJlZjogZm9yd2FyZGVkUmVmIHx8IHNlbGVjdFJlZixcbiAgICB2YWx1ZTogdmFsdWUgfHwgKG11bHRpcGxlID8gW10gOiAnJyksXG4gICAgb25DaGFuZ2U6IGhhbmRsZUNoYW5nZSxcbiAgICBvbkJsdXI6IGZ1bmN0aW9uIG9uQmx1cihlKSB7XG4gICAgICBzZXRUb3VjaGVkKHRydWUpO1xuXG4gICAgICBpZiAoX29uQmx1cikge1xuICAgICAgICBfb25CbHVyKGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSksIG9wdGlvbnMgPyBvcHRpb25zLm1hcChmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIsIHtcbiAgICAgIGtleTogb3B0aW9uLnZhbHVlLFxuICAgICAgdmFsdWU6IG9wdGlvbi52YWx1ZSxcbiAgICAgIGRpc2FibGVkOiBvcHRpb24uZGlzYWJsZWRcbiAgICB9LCBvcHRpb24ubGFiZWwpO1xuICB9KSA6IGNoaWxkcmVuKSk7XG59O1xudmFyIFNlbGVjdCQxID0gYXNGaWVsZChTZWxlY3QpO1xuXG52YXIgQ2hlY2tib3ggPSBmdW5jdGlvbiBDaGVja2JveChfcmVmKSB7XG4gIHZhciBmaWVsZEFwaSA9IF9yZWYuZmllbGRBcGksXG4gICAgICBmaWVsZFN0YXRlID0gX3JlZi5maWVsZFN0YXRlLFxuICAgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgW1wiZmllbGRBcGlcIiwgXCJmaWVsZFN0YXRlXCJdKTtcblxuICB2YXIgdmFsdWUgPSBmaWVsZFN0YXRlLnZhbHVlO1xuICB2YXIgc2V0VmFsdWUgPSBmaWVsZEFwaS5zZXRWYWx1ZSxcbiAgICAgIHNldFRvdWNoZWQgPSBmaWVsZEFwaS5zZXRUb3VjaGVkO1xuXG4gIHZhciBfb25DaGFuZ2UgPSBwcm9wcy5vbkNoYW5nZSxcbiAgICAgIF9vbkJsdXIgPSBwcm9wcy5vbkJsdXIsXG4gICAgICBmaWVsZCA9IHByb3BzLmZpZWxkLFxuICAgICAgaW5pdGlhbFZhbHVlID0gcHJvcHMuaW5pdGlhbFZhbHVlLFxuICAgICAgZGVidWcgPSBwcm9wcy5kZWJ1ZyxcbiAgICAgIGZvcndhcmRlZFJlZiA9IHByb3BzLmZvcndhcmRlZFJlZixcbiAgICAgIGlkID0gcHJvcHMuaWQsXG4gICAgICBsYWJlbCA9IHByb3BzLmxhYmVsLFxuICAgICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgW1wib25DaGFuZ2VcIiwgXCJvbkJsdXJcIiwgXCJmaWVsZFwiLCBcImluaXRpYWxWYWx1ZVwiLCBcImRlYnVnXCIsIFwiZm9yd2FyZGVkUmVmXCIsIFwiaWRcIiwgXCJsYWJlbFwiXSk7XG5cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBsYWJlbCA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwibGFiZWxcIiwge1xuICAgIGh0bWxGb3I6IGlkXG4gIH0sIFwiIFwiLCBsYWJlbCwgXCIgXCIpIDogbnVsbCwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiLCBfZXh0ZW5kcyh7fSwgcmVzdCwge1xuICAgIGlkOiBpZCxcbiAgICBuYW1lOiBmaWVsZCxcbiAgICByZWY6IGZvcndhcmRlZFJlZixcbiAgICBjaGVja2VkOiAhIXZhbHVlLFxuICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiBvbkNoYW5nZShlKSB7XG4gICAgICBzZXRWYWx1ZShlLnRhcmdldC5jaGVja2VkKTtcblxuICAgICAgaWYgKF9vbkNoYW5nZSkge1xuICAgICAgICBfb25DaGFuZ2UoZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBvbkJsdXI6IGZ1bmN0aW9uIG9uQmx1cihlKSB7XG4gICAgICBzZXRUb3VjaGVkKHRydWUpO1xuXG4gICAgICBpZiAoX29uQmx1cikge1xuICAgICAgICBfb25CbHVyKGUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgdHlwZTogXCJjaGVja2JveFwiXG4gIH0pKSk7XG59O1xudmFyIENoZWNrYm94JDEgPSBhc0ZpZWxkKENoZWNrYm94KTtcblxudmFyIHdpdGhSYWRpb0dyb3VwID0gZnVuY3Rpb24gd2l0aFJhZGlvR3JvdXAoQ29tcG9uZW50KSB7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiAocHJvcHMsIHJlZikge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChHcm91cENvbnRleHQuQ29uc3VtZXIsIG51bGwsIGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICB2YXIgcmFkaW9Hcm91cEFwaSA9IF9yZWYucmFkaW9Hcm91cEFwaSxcbiAgICAgICAgICByYWRpb0dyb3VwU3RhdGUgPSBfcmVmLnJhZGlvR3JvdXBTdGF0ZTtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIF9leHRlbmRzKHtcbiAgICAgICAgcmFkaW9Hcm91cEFwaTogcmFkaW9Hcm91cEFwaSxcbiAgICAgICAgcmFkaW9Hcm91cFN0YXRlOiByYWRpb0dyb3VwU3RhdGUsXG4gICAgICAgIHJlZjogcmVmXG4gICAgICB9LCBwcm9wcykpO1xuICAgIH0pO1xuICB9KTtcbn07XG5cbnZhciBSYWRpbyA9IGZ1bmN0aW9uIFJhZGlvKF9yZWYpIHtcbiAgdmFyIHJhZGlvR3JvdXBBcGkgPSBfcmVmLnJhZGlvR3JvdXBBcGksXG4gICAgICByYWRpb0dyb3VwU3RhdGUgPSBfcmVmLnJhZGlvR3JvdXBTdGF0ZSxcbiAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFtcInJhZGlvR3JvdXBBcGlcIiwgXCJyYWRpb0dyb3VwU3RhdGVcIl0pO1xuXG4gIHZhciBncm91cFZhbHVlID0gcmFkaW9Hcm91cFN0YXRlLnZhbHVlO1xuICB2YXIgc2V0VmFsdWUgPSByYWRpb0dyb3VwQXBpLnNldFZhbHVlLFxuICAgICAgc2V0VG91Y2hlZCA9IHJhZGlvR3JvdXBBcGkuc2V0VG91Y2hlZCxcbiAgICAgIGdyb3VwT25DaGFuZ2UgPSByYWRpb0dyb3VwQXBpLm9uQ2hhbmdlLFxuICAgICAgZ3JvdXBPbkJsdXIgPSByYWRpb0dyb3VwQXBpLm9uQmx1cjtcblxuICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZSxcbiAgICAgIF9vbkNoYW5nZSA9IHByb3BzLm9uQ2hhbmdlLFxuICAgICAgX29uQmx1ciA9IHByb3BzLm9uQmx1cixcbiAgICAgIGZpZWxkID0gcHJvcHMuZmllbGQsXG4gICAgICBpbml0aWFsVmFsdWUgPSBwcm9wcy5pbml0aWFsVmFsdWUsXG4gICAgICBmb3J3YXJkZWRSZWYgPSBwcm9wcy5mb3J3YXJkZWRSZWYsXG4gICAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBbXCJ2YWx1ZVwiLCBcIm9uQ2hhbmdlXCIsIFwib25CbHVyXCIsIFwiZmllbGRcIiwgXCJpbml0aWFsVmFsdWVcIiwgXCJmb3J3YXJkZWRSZWZcIl0pO1xuXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImlucHV0XCIsIF9leHRlbmRzKHt9LCByZXN0LCB7XG4gICAgbmFtZTogZmllbGQsXG4gICAgcmVmOiBmb3J3YXJkZWRSZWYsXG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIGNoZWNrZWQ6IGdyb3VwVmFsdWUgPT09IHZhbHVlLFxuICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiBvbkNoYW5nZShlKSB7XG4gICAgICBpZiAoIWUudGFyZ2V0LmNoZWNrZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBzZXRWYWx1ZSh2YWx1ZSk7XG5cbiAgICAgIGlmIChfb25DaGFuZ2UpIHtcbiAgICAgICAgX29uQ2hhbmdlKGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZ3JvdXBPbkNoYW5nZSkge1xuICAgICAgICBncm91cE9uQ2hhbmdlKGUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgb25CbHVyOiBmdW5jdGlvbiBvbkJsdXIoZSkge1xuICAgICAgc2V0VG91Y2hlZCh0cnVlKTtcblxuICAgICAgaWYgKF9vbkJsdXIpIHtcbiAgICAgICAgX29uQmx1cihlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGdyb3VwT25CbHVyKSB7XG4gICAgICAgIGdyb3VwT25CbHVyKGUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgdHlwZTogXCJyYWRpb1wiXG4gIH0pKTtcbn07XG52YXIgUmFkaW8kMSA9IHdpdGhSYWRpb0dyb3VwKFJhZGlvKTtcblxudmFyIFJhZGlvR3JvdXAgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFJhZGlvR3JvdXAsIF9Db21wb25lbnQpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoUmFkaW9Hcm91cCk7XG5cbiAgZnVuY3Rpb24gUmFkaW9Hcm91cCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmFkaW9Hcm91cCk7XG5cbiAgICByZXR1cm4gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUmFkaW9Hcm91cCwgW3tcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgb3B0aW9ucyA9IF90aGlzJHByb3BzLm9wdGlvbnMsXG4gICAgICAgICAgY2hpbGRyZW4gPSBfdGhpcyRwcm9wcy5jaGlsZHJlbjtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChHcm91cENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IHRoaXMuZ3JvdXBDb250ZXh0XG4gICAgICB9LCBvcHRpb25zID8gb3B0aW9ucy5tYXAoZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJsYWJlbFwiLCB7XG4gICAgICAgICAga2V5OiBvcHRpb24udmFsdWVcbiAgICAgICAgfSwgb3B0aW9uLmxhYmVsLCBcIiBcIiwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmFkaW8kMSwge1xuICAgICAgICAgIHZhbHVlOiBvcHRpb24udmFsdWVcbiAgICAgICAgfSkpO1xuICAgICAgfSkgOiBjaGlsZHJlbik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdyb3VwQ29udGV4dFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmFkaW9Hcm91cEFwaTogX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIHRoaXMucHJvcHMuZmllbGRBcGkpLCB7fSwge1xuICAgICAgICAgIG9uQ2hhbmdlOiB0aGlzLnByb3BzLm9uQ2hhbmdlLFxuICAgICAgICAgIG9uQmx1cjogdGhpcy5wcm9wcy5vbkJsdXJcbiAgICAgICAgfSksXG4gICAgICAgIHJhZGlvR3JvdXBTdGF0ZTogdGhpcy5wcm9wcy5maWVsZFN0YXRlXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBSYWRpb0dyb3VwO1xufShDb21wb25lbnQpO1xudmFyIFJhZGlvR3JvdXAkMSA9IGFzRmllbGQoUmFkaW9Hcm91cCk7XG5cbmZ1bmN0aW9uIHVzZUFycmF5RmllbGRBcGkoKSB7XG4gIHJldHVybiB1c2VDb250ZXh0KEFycmF5RmllbGRBcGlDb250ZXh0KTtcbn1cblxudmFyIEFkZEJ1dHRvbiA9IGZ1bmN0aW9uIEFkZEJ1dHRvbigpIHtcbiAgdmFyIF91c2VBcnJheUZpZWxkQXBpID0gdXNlQXJyYXlGaWVsZEFwaSgpLFxuICAgICAgYWRkID0gX3VzZUFycmF5RmllbGRBcGkuYWRkO1xuXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCB7XG4gICAgb25DbGljazogZnVuY3Rpb24gb25DbGljaygpIHtcbiAgICAgIGFkZCgpO1xuICAgIH0sXG4gICAgdHlwZTogXCJidXR0b25cIlxuICB9LCBcIkFkZFwiKTtcbn07XG5cbmZ1bmN0aW9uIHVzZUFycmF5RmllbGRJdGVtQXBpKCkge1xuICByZXR1cm4gdXNlQ29udGV4dChBcnJheUZpZWxkSXRlbUFwaUNvbnRleHQpO1xufVxuXG52YXIgQWRkQnV0dG9uJDEgPSBmdW5jdGlvbiBBZGRCdXR0b24oKSB7XG4gIHZhciBfdXNlQXJyYXlGaWVsZEl0ZW1BcGkgPSB1c2VBcnJheUZpZWxkSXRlbUFwaSgpLFxuICAgICAgcmVtb3ZlID0gX3VzZUFycmF5RmllbGRJdGVtQXBpLnJlbW92ZTtcblxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwge1xuICAgIG9uQ2xpY2s6IGZ1bmN0aW9uIG9uQ2xpY2soKSB7XG4gICAgICByZW1vdmUoKTtcbiAgICB9LFxuICAgIHR5cGU6IFwiYnV0dG9uXCJcbiAgfSwgXCJSZW1vdmVcIik7XG59O1xuXG52YXIgbG9nZ2VyJDMgPSBkZWJ1ZygnaW5mb3JtZWQ6dXNlQXJyYXlGaWVsZCcgKyAnXFx0Jyk7XG5cbnZhciB1c2VBcnJheUZpZWxkID0gZnVuY3Rpb24gdXNlQXJyYXlGaWVsZChfcmVmKSB7XG4gIHZhciBmaWVsZCA9IF9yZWYuZmllbGQsXG4gICAgICBpbml0aWFsVmFsdWUgPSBfcmVmLmluaXRpYWxWYWx1ZSxcbiAgICAgIHZhbGlkYXRlID0gX3JlZi52YWxpZGF0ZSxcbiAgICAgIGFycmF5RmllbGRBcGlSZWYgPSBfcmVmLmFycmF5RmllbGRBcGlSZWYsXG4gICAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbXCJmaWVsZFwiLCBcImluaXRpYWxWYWx1ZVwiLCBcInZhbGlkYXRlXCIsIFwiYXJyYXlGaWVsZEFwaVJlZlwiXSk7XG5cbiAgLy8gUmVmZXJlbmNlIHRvIHRoZSBmb3JtIEFwaVxuICB2YXIgZm9ybUFwaSA9IHVzZUZvcm1BcGkoKTsgLy8gS2VlcCB0cmFjayBvZiBmaWVsZHMgdGhhdCBiZWxvbmcgdG8gdGhpcyBhcnJheSBmaWVsZFxuXG4gIHZhciBfdXNlU3RhdGUgPSB1c2VTdGF0ZShuZXcgTWFwKCkpLFxuICAgICAgX3VzZVN0YXRlMiA9IF9zbGljZWRUb0FycmF5KF91c2VTdGF0ZSwgMSksXG4gICAgICBmaWVsZHNCeUlkID0gX3VzZVN0YXRlMlswXTsgLy8gR3JhYiB0aGUgZm9ybSByZWdpc3RlciBjb250ZXh0XG5cblxuICB2YXIgdXBkYXRlciA9IHVzZUNvbnRleHQoRm9ybVJlZ2lzdGVyQ29udGV4dCk7IC8vIE1heSBiZSBzY29wZWQgc28gZ2V0IGZ1bGwgZmllbGQgbmFtZSEhXG5cbiAgdmFyIGZ1bGxGaWVsZCA9IGZvcm1BcGkuZ2V0RnVsbEZpZWxkKGZpZWxkKTtcbiAgdmFyIGluaXRpYWxWYWxzID0gdXBkYXRlci5nZXRJbml0aWFsVmFsdWUoZmllbGQpIHx8IGluaXRpYWxWYWx1ZSB8fCBbXTsgLy8gVE9ETyB0aHJvdyBlcnJvciBpZiBpbml0aWFsIHZhbHVlIGFuZCBpdHMgbm90IGFycmF5XG4gIC8vIElmIGtlZXAgc3RhdGUgd2FzIHBhc3NlZCBpbnRvIHRoZSBjaGlsZCBpbnB1dHMgd2UgbmVlZCB0byBtYWludGFpbiB0aGUgbGVuZ3RoIG9mXG4gIC8vIGtleXMsIGluIG9yZGVyIHRvIGRvIHNvIHdlIGdyYWIgdGhlIHZhbHVlIGZyb20gaW5mb3JtZWRzIGFwaVxuXG4gIHZhciBrZXB0VmFsdWVzID0gZm9ybUFwaS5nZXRTYXZlZFZhbHVlKGZ1bGxGaWVsZCkgJiYgZm9ybUFwaS5nZXRTYXZlZFZhbHVlKGZ1bGxGaWVsZCkudmFsdWU7XG5cbiAgdmFyIF91c2VTdGF0ZVdpdGhHZXR0ZXIgPSB1c2VTdGF0ZVdpdGhHZXR0ZXIoa2VwdFZhbHVlcyB8fCBpbml0aWFsVmFscyksXG4gICAgICBfdXNlU3RhdGVXaXRoR2V0dGVyMiA9IF9zbGljZWRUb0FycmF5KF91c2VTdGF0ZVdpdGhHZXR0ZXIsIDMpLFxuICAgICAgaW5pdGlhbFZhbHVlcyA9IF91c2VTdGF0ZVdpdGhHZXR0ZXIyWzBdLFxuICAgICAgc2V0SW5pdGlhbFZhbHVlcyA9IF91c2VTdGF0ZVdpdGhHZXR0ZXIyWzFdLFxuICAgICAgZ2V0SW5pdGlhbFZhbHVlcyA9IF91c2VTdGF0ZVdpdGhHZXR0ZXIyWzJdO1xuXG4gIHZhciBpbml0aWFsS2V5cyA9IGluaXRpYWxWYWx1ZXMgPyBpbml0aWFsVmFsdWVzLm1hcChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHV1aWR2NCgpO1xuICB9KSA6IFtdO1xuXG4gIHZhciBfdXNlU3RhdGVXaXRoR2V0dGVyMyA9IHVzZVN0YXRlV2l0aEdldHRlcihpbml0aWFsS2V5cyksXG4gICAgICBfdXNlU3RhdGVXaXRoR2V0dGVyNCA9IF9zbGljZWRUb0FycmF5KF91c2VTdGF0ZVdpdGhHZXR0ZXIzLCAzKSxcbiAgICAgIGtleXMgPSBfdXNlU3RhdGVXaXRoR2V0dGVyNFswXSxcbiAgICAgIHNldEtleXMgPSBfdXNlU3RhdGVXaXRoR2V0dGVyNFsxXSxcbiAgICAgIGdldEtleXMgPSBfdXNlU3RhdGVXaXRoR2V0dGVyNFsyXTtcblxuICB2YXIgdmFsaWRhdGVXaXRoTGVuZ3RoID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSwgdmFsdWVzKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gZ2V0S2V5cygpID09IG51bGwgPyAwIDogZ2V0S2V5cygpLmxlbmd0aDtcbiAgICAgIHJldHVybiB2YWxpZGF0ZSA/IHZhbGlkYXRlKHZhbHVlLCBsZW5ndGgsIHZhbHVlcykgOiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgfSk7IC8vIFJlZ2lzdGVyIHNoYWRvdyBmaWVsZFxuXG4gIHZhciBfdXNlRmllbGQgPSB1c2VGaWVsZChfb2JqZWN0U3ByZWFkMih7XG4gICAgZmllbGQ6IGZpZWxkLFxuICAgIHZhbGlkYXRlOiB2YWxpZGF0ZSA/IHZhbGlkYXRlV2l0aExlbmd0aCA6IHVuZGVmaW5lZCxcbiAgICBzaGFkb3c6IHRydWVcbiAgfSwgcHJvcHMpKSxcbiAgICAgIGZpZWxkQXBpID0gX3VzZUZpZWxkLmZpZWxkQXBpOyAvLyBSZWdpc3RlciBmb3IgZXZlbnRzXG5cblxuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAvLyBEZWZpbmUgZXZlbnQgaGFuZGxlclxuICAgIHZhciBvbkNoYW5nZUhhbmRsZXIgPSBmdW5jdGlvbiBvbkNoYW5nZUhhbmRsZXIoZmllbGROYW1lKSB7XG4gICAgICAvLyBEb250IGRvIGFueXRoaWduIGlmIHdlIHVwZGF0ZWRcbiAgICAgIGlmIChmaWVsZE5hbWUgPT09IGZ1bGxGaWVsZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxvZ2dlciQzKFwiXCIuY29uY2F0KGZ1bGxGaWVsZCwgXCIgY2hhbmdlZFwiKSk7IC8vIGRldGVybWluZSBpZiBvbmUgb2Ygb3VyIGFycmF5IGNoaWxkcmVuIHRyaWdnZXJlZCB0aGlzIGNoYW5nZVxuXG4gICAgICBpZiAoUmVnRXhwKFwiXCIuY29uY2F0KGZ1bGxGaWVsZCwgXCJcXFxcW1swLTldK1xcXFxdXCIpKS50ZXN0KGZpZWxkTmFtZSkpIHtcbiAgICAgICAgLy8gSWYgaXQgd2FzIHdlIG5lZWQgdG8gY2FsbCB2YWxpZGF0ZVxuICAgICAgICBmaWVsZEFwaS52YWxpZGF0ZSgpO1xuICAgICAgfVxuICAgIH07IC8vIFJlZ2lzdGVyIGZvciBldmVudHNcblxuXG4gICAgZm9ybUFwaS5lbWl0dGVyLm9uKCd2YWx1ZScsIG9uQ2hhbmdlSGFuZGxlcik7IC8vIFVucmVnaXN0ZXIgZXZlbnRzXG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgZm9ybUFwaS5lbWl0dGVyLnJlbW92ZUxpc3RlbmVyKCd2YWx1ZScsIG9uQ2hhbmdlSGFuZGxlcik7XG4gICAgfTtcbiAgfSwgW2ZpZWxkXSk7XG5cbiAgdmFyIF9yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUoaSkge1xuICAgIC8vIE5vdGlmeSBmb3JtIHRvIGV4cGVjdCByZW1vdmFsIG9uIHRoaXMgZmllbGRcbiAgICBsb2dnZXIkMygnRVhQRUNUSU5HIFJFTU9WQUwgT0YnLCBcIlwiLmNvbmNhdChmaWVsZCwgXCJbXCIpLmNvbmNhdChpLCBcIl0gYW5kIFwiKS5jb25jYXQoZmllbGQsIFwiW1wiKS5jb25jYXQoa2V5cy5sZW5ndGggLSAxLCBcIl1cIikpO1xuICAgIHVwZGF0ZXIuZXhwZWN0UmVtb3ZhbChcIlwiLmNvbmNhdChmaWVsZCwgXCJbXCIpLmNvbmNhdChpLCBcIl1cIikpO1xuICAgIHVwZGF0ZXIuZXhwZWN0UmVtb3ZhbChcIlwiLmNvbmNhdChmaWVsZCwgXCJbXCIpLmNvbmNhdChrZXlzLmxlbmd0aCAtIDEsIFwiXVwiKSk7IC8vIFJlbW92ZSB0aGUga2V5XG5cbiAgICB2YXIgbmV3S2V5cyA9IGtleXMuc2xpY2UoMCwgaSkuY29uY2F0KGtleXMuc2xpY2UoaSArIDEsIGtleXMubGVuZ3RoKSk7XG4gICAgc2V0S2V5cyhuZXdLZXlzKTsgLy8gUmVtb3ZlIHRoZSBpbml0aWFsIHZhbHVlICggdXNlciB3YW50ZWQgdG8gZ2V0IHJpZCBvZiB0aGF0IGlucHV0IClcblxuICAgIHZhciBpbml0VmFscyA9IGdldEluaXRpYWxWYWx1ZXMoKTtcbiAgICB2YXIgbmV3SW5pdGlhbFZhbHVlcyA9IGluaXRWYWxzLnNsaWNlKDAsIGkpLmNvbmNhdChpbml0VmFscy5zbGljZShpICsgMSwgaW5pdFZhbHMubGVuZ3RoKSk7XG4gICAgc2V0SW5pdGlhbFZhbHVlcyhuZXdJbml0aWFsVmFsdWVzKTsgLy9mb3JtQXBpLnNldEluaXRpYWxWYWx1ZShmaWVsZCwgbmV3SW5pdGlhbFZhbHVlcyk7XG4gIH07XG5cbiAgdmFyIHN3YXAgPSBmdW5jdGlvbiBzd2FwKGEsIGIpIHtcbiAgICBsb2dnZXIkMygnU3dhcHBpbmcnLCBcIlwiLmNvbmNhdChmaWVsZCwgXCJbXCIpLmNvbmNhdChhLCBcIl0gYW5kIFwiKS5jb25jYXQoZmllbGQsIFwiW1wiKS5jb25jYXQoYiwgXCJdXCIpKTsgLy8gU3dhcCB0aGUga2V5c1xuXG4gICAgdmFyIG5ld0tleXMgPSBfdG9Db25zdW1hYmxlQXJyYXkoa2V5cyk7XG5cbiAgICBpZiAoa2V5c1thXSAmJiBrZXlzW2JdKSB7XG4gICAgICBuZXdLZXlzW2FdID0ga2V5c1tiXTtcbiAgICAgIG5ld0tleXNbYl0gPSBrZXlzW2FdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS53YXJuKFwiQXR0ZW1wdGVkIHRvIHN3YXAgXCIuY29uY2F0KGEsIFwiIHdpdGggXCIpLmNvbmNhdChiLCBcIiBidXQgb25lIG9mIHRoZW0gZG9lcyBub3QgZXhpc3QgOihcIikpO1xuICAgIH1cblxuICAgIHNldEtleXMobmV3S2V5cyk7XG4gIH07XG5cbiAgdmFyIGFkZCA9IGZ1bmN0aW9uIGFkZCgpIHtcbiAgICBrZXlzLnB1c2godXVpZHY0KCkpO1xuICAgIHNldEtleXMoX3RvQ29uc3VtYWJsZUFycmF5KGtleXMpKTtcbiAgfTtcblxuICB2YXIgYWRkV2l0aEluaXRpYWxWYWx1ZSA9IGZ1bmN0aW9uIGFkZFdpdGhJbml0aWFsVmFsdWUoaW5pdGlhbFZhbHVlKSB7XG4gICAga2V5cy5wdXNoKHV1aWR2NCgpKTtcbiAgICBzZXRLZXlzKF90b0NvbnN1bWFibGVBcnJheShrZXlzKSk7XG5cbiAgICB2YXIgbmV3SW5pdGlhbFZhbHVlcyA9IF90b0NvbnN1bWFibGVBcnJheShnZXRJbml0aWFsVmFsdWVzKCkpO1xuXG4gICAgbmV3SW5pdGlhbFZhbHVlc1trZXlzLmxlbmd0aCAtIDFdID0gaW5pdGlhbFZhbHVlO1xuICAgIHNldEluaXRpYWxWYWx1ZXMobmV3SW5pdGlhbFZhbHVlcyk7XG4gIH07XG5cbiAgdmFyIHJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgLy8gV2hlbiByZXNldHRpbmcgd2UgcmVzZXQgdG8gdGhlIHVzZXJzIGluaXRpYWwgdmFsdWUgbm90IHRoZSBvbmUgdHJhY2tlZCBieSB0aGlzIGhvb2tcbiAgICB2YXIgaW5pdFZhbHMgPSB1cGRhdGVyLmdldEluaXRpYWxWYWx1ZShmaWVsZCkgfHwgaW5pdGlhbFZhbHVlIHx8IFtdOyAvLyBTZXQgb3VyIGluaXRpYWwgdmFsdWVzIGJhY2sgdG8gd2hhdCB0aGUgdXNlciBzZXQgYXQgYmVnaW5uaW5nXG5cbiAgICBzZXRJbml0aWFsVmFsdWVzKGluaXRWYWxzKTsgLy8gQnVpbGQgYSBuZXcgc2V0IG9mIGtleXMgYmVjYXVzZSBldmVyeXRoaW5nIGlzIG5ldyAhISFcblxuICAgIHZhciByZXNldEtleXMgPSBpbml0VmFscyA/IGluaXRWYWxzLm1hcChmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdXVpZHY0KCk7XG4gICAgfSkgOiBbXTsgLy8gRmluYWxseSBzZXQgdGhhdCBzaGl0ICFcblxuICAgIHNldEtleXMocmVzZXRLZXlzKTtcbiAgfTtcblxuICB2YXIgZmllbGRzID0ga2V5cy5tYXAoZnVuY3Rpb24gKGtleSwgaSkge1xuICAgIHZhciBhcnJheUZpZWxkSXRlbUFwaSA9IHtcbiAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICByZXR1cm4gX3JlbW92ZShpKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBhcnJheUZpZWxkSXRlbVN0YXRlID0ge1xuICAgICAgaW5pdGlhbFZhbHVlOiBpbml0aWFsVmFsdWVzICYmIGluaXRpYWxWYWx1ZXNbaV0sXG4gICAgICBrZXk6IGtleSxcbiAgICAgIGZpZWxkOiBcIlwiLmNvbmNhdChmaWVsZCwgXCJbXCIpLmNvbmNhdChpLCBcIl1cIiksXG4gICAgICBpbmRleDogaVxuICAgIH07XG4gICAgcmV0dXJuIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHtcbiAgICAgIGFycmF5RmllbGRJdGVtQXBpOiBhcnJheUZpZWxkSXRlbUFwaSxcbiAgICAgIGFycmF5RmllbGRJdGVtU3RhdGU6IGFycmF5RmllbGRJdGVtU3RhdGVcbiAgICB9LCBhcnJheUZpZWxkSXRlbUFwaSksIGFycmF5RmllbGRJdGVtU3RhdGUpO1xuICB9KTtcbiAgdmFyIGFycmF5RmllbGRBcGkgPSB7XG4gICAgYWRkOiBhZGQsXG4gICAgc3dhcDogc3dhcCxcbiAgICBhZGRXaXRoSW5pdGlhbFZhbHVlOiBhZGRXaXRoSW5pdGlhbFZhbHVlLFxuICAgIHJlc2V0OiByZXNldFxuICB9O1xuXG4gIGlmIChhcnJheUZpZWxkQXBpUmVmKSB7XG4gICAgYXJyYXlGaWVsZEFwaVJlZi5jdXJyZW50ID0gYXJyYXlGaWVsZEFwaTtcbiAgfVxuXG4gIHZhciBhcnJheUZpZWxkU3RhdGUgPSB7XG4gICAgZmllbGRzOiBmaWVsZHMsXG4gICAgZmllbGQ6IGZpZWxkXG4gIH07IC8vIFdyYXAgdGhlIHVwZGF0ZXIgdG8gdXBkYXRlIGFycmF5IGZpZWxkcyByZWZlcmVuY2VzXG5cbiAgdmFyIHdyYXBwZWRVcGRhdG9yID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIHVwZGF0ZXIpLCB7fSwge1xuICAgIHJlZ2lzdGVyOiBmdW5jdGlvbiByZWdpc3RlcihpZCwgZmxkKSB7XG4gICAgICBmaWVsZHNCeUlkLnNldChpZCwgZmxkKTtcblxuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDIgPyBfbGVuIC0gMiA6IDApLCBfa2V5ID0gMjsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXkgLSAyXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgdXBkYXRlci5yZWdpc3Rlci5hcHBseSh1cGRhdGVyLCBbaWQsIGZsZF0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIGRlcmVnaXN0ZXI6IGZ1bmN0aW9uIGRlcmVnaXN0ZXIoaWQpIHtcbiAgICAgIGZpZWxkc0J5SWRbXCJkZWxldGVcIl0oaWQpO1xuXG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICB1cGRhdGVyLmRlcmVnaXN0ZXIuYXBwbHkodXBkYXRlciwgW2lkXS5jb25jYXQoYXJncykpO1xuICAgIH0sXG4gICAgZ2V0SW5pdGlhbFZhbHVlOiBmdW5jdGlvbiBnZXRJbml0aWFsVmFsdWUoZmllbGROYW1lKSB7XG4gICAgICAvLyBJZiB3ZSBhcmUgZ2V0dGluZyBpbml0aWFsIHZhbHVlIGFuZCBpdHMgZm9yIHRoaXMgZmllbGQgcmV0dXJuIHRoYXRcbiAgICAgIGlmIChSZWdFeHAoXCJcIi5jb25jYXQoZnVsbEZpZWxkLCBcIlxcXFxbWzAtOV0rXFxcXF1cIikpLnRlc3QoZmllbGROYW1lKSkge1xuICAgICAgICB2YXIgcGF0aCA9IGZpZWxkTmFtZS5yZXBsYWNlKGZpZWxkLCAnJyk7XG4gICAgICAgIHZhciB2ID0gT2JqZWN0TWFwLmdldChnZXRJbml0aWFsVmFsdWVzKCksIHBhdGgpO1xuICAgICAgICBsb2dnZXIkMyhcIlJlc2V0dGluZyBcIi5jb25jYXQocGF0aCwgXCIgdG8gXCIpLmNvbmNhdCh2KSk7XG4gICAgICAgIHJldHVybiB2O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdXBkYXRlci5nZXRJbml0aWFsVmFsdWUoZmllbGROYW1lKTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciByZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoY2hpbGRyZW4pIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRm9ybVJlZ2lzdGVyQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgdmFsdWU6IHdyYXBwZWRVcGRhdG9yXG4gICAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQXJyYXlGaWVsZEFwaUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgIHZhbHVlOiBhcnJheUZpZWxkQXBpXG4gICAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQXJyYXlGaWVsZFN0YXRlQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgdmFsdWU6IGFycmF5RmllbGRTdGF0ZVxuICAgIH0sIGNoaWxkcmVuKSkpO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgcmVuZGVyOiByZW5kZXIsXG4gICAgYWRkOiBhZGQsXG4gICAgc3dhcDogc3dhcCxcbiAgICBhZGRXaXRoSW5pdGlhbFZhbHVlOiBhZGRXaXRoSW5pdGlhbFZhbHVlLFxuICAgIGZpZWxkczogZmllbGRzLFxuICAgIGFycmF5RmllbGRTdGF0ZTogYXJyYXlGaWVsZFN0YXRlLFxuICAgIGFycmF5RmllbGRBcGk6IGFycmF5RmllbGRBcGksXG4gICAgZmllbGQ6IGZpZWxkXG4gIH07XG59O1xuXG52YXIgYnVpbGRTY29wZWRGb3JtQXBpID0gZnVuY3Rpb24gYnVpbGRTY29wZWRGb3JtQXBpKHNjb3BlLCBmb3JtQXBpKSB7XG4gIHJldHVybiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgZm9ybUFwaSksIHt9LCB7XG4gICAgZ2V0VmFsdWU6IGZ1bmN0aW9uIGdldFZhbHVlKGZpZWxkKSB7XG4gICAgICByZXR1cm4gZm9ybUFwaS5nZXRWYWx1ZShcIlwiLmNvbmNhdChzY29wZSwgXCIuXCIpLmNvbmNhdChmaWVsZCkpO1xuICAgIH0sXG4gICAgZ2V0VG91Y2hlZDogZnVuY3Rpb24gZ2V0VG91Y2hlZChmaWVsZCkge1xuICAgICAgcmV0dXJuIGZvcm1BcGkuZ2V0VG91Y2hlZChcIlwiLmNvbmNhdChzY29wZSwgXCIuXCIpLmNvbmNhdChmaWVsZCkpO1xuICAgIH0sXG4gICAgZ2V0RXJyb3I6IGZ1bmN0aW9uIGdldEVycm9yKGZpZWxkKSB7XG4gICAgICByZXR1cm4gZm9ybUFwaS5nZXRFcnJvcihcIlwiLmNvbmNhdChzY29wZSwgXCIuXCIpLmNvbmNhdChmaWVsZCkpO1xuICAgIH0sXG4gICAgc2V0VmFsdWU6IGZ1bmN0aW9uIHNldFZhbHVlKGZpZWxkLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGZvcm1BcGkuc2V0VmFsdWUoXCJcIi5jb25jYXQoc2NvcGUsIFwiLlwiKS5jb25jYXQoZmllbGQpLCB2YWx1ZSk7XG4gICAgfSxcbiAgICBzZXRUb3VjaGVkOiBmdW5jdGlvbiBzZXRUb3VjaGVkKGZpZWxkLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGZvcm1BcGkuc2V0VG91Y2hlZChcIlwiLmNvbmNhdChzY29wZSwgXCIuXCIpLmNvbmNhdChmaWVsZCksIHZhbHVlKTtcbiAgICB9LFxuICAgIHNldEVycm9yOiBmdW5jdGlvbiBzZXRFcnJvcihmaWVsZCwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBmb3JtQXBpLnNldEVycm9yKFwiXCIuY29uY2F0KHNjb3BlLCBcIi5cIikuY29uY2F0KGZpZWxkKSwgdmFsdWUpO1xuICAgIH0sXG4gICAgZ2V0SW5pdGlhbFZhbHVlOiBmdW5jdGlvbiBnZXRJbml0aWFsVmFsdWUoZmllbGQpIHtcbiAgICAgIHJldHVybiBmb3JtQXBpLmdldEluaXRpYWxWYWx1ZShcIlwiLmNvbmNhdChzY29wZSwgXCIuXCIpLmNvbmNhdChmaWVsZCkpO1xuICAgIH0sXG4gICAgZ2V0RnVsbEZpZWxkOiBmdW5jdGlvbiBnZXRGdWxsRmllbGQoZmllbGQpIHtcbiAgICAgIHJldHVybiBcIlwiLmNvbmNhdChmb3JtQXBpLmdldEZ1bGxGaWVsZChzY29wZSksIFwiLlwiKS5jb25jYXQoZmllbGQpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5mdW5jdGlvbiB1c2VTY29wZWRBcGkoc2NvcGUpIHtcbiAgdmFyIGZvcm1BcGkgPSB1c2VGb3JtQXBpKCk7IC8vIFZFUlkgaW1wb3J0YW50IHRvIG1lbW9pemUgdGhlIGJ1aWxkZXIhXG5cbiAgdmFyIHNjb3BlZEZvcm1BcGkgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYnVpbGRTY29wZWRGb3JtQXBpKHNjb3BlLCBmb3JtQXBpKTtcbiAgfSwgW3Njb3BlXSk7XG4gIHJldHVybiBzY29wZWRGb3JtQXBpO1xufVxuXG5mdW5jdGlvbiB1c2VGb3JtU3RhdGUoKSB7XG4gIHZhciBmb3JtU3RhdGUgPSB1c2VDb250ZXh0KEZvcm1TdGF0ZUNvbnRleHQpO1xuICByZXR1cm4gZm9ybVN0YXRlO1xufVxuXG52YXIgUmVsZXZhbnQgPSBmdW5jdGlvbiBSZWxldmFudChfcmVmKSB7XG4gIHZhciB3aGVuID0gX3JlZi53aGVuLFxuICAgICAgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuO1xuICB2YXIgZm9ybVN0YXRlID0gdXNlRm9ybVN0YXRlKCk7XG4gIHZhciBpc1JlbGV2YW50ID0gd2hlbihmb3JtU3RhdGUpO1xuXG4gIGlmIChpc1JlbGV2YW50KSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG52YXIgQXJyYXlGaWVsZCA9IGZ1bmN0aW9uIEFycmF5RmllbGQoX3JlZikge1xuICB2YXIgcmVsZXZhbnQgPSBfcmVmLnJlbGV2YW50LFxuICAgICAgZmllbGQgPSBfcmVmLmZpZWxkLFxuICAgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgW1wicmVsZXZhbnRcIiwgXCJmaWVsZFwiXSk7XG5cbiAgLy8gTmVlZCB0byBnZXQgZm9ybUFwaSB0byBoYXZlIGNvbnNpc3RhbnQgaW50ZXJmYWNlIGZvciByZWxldmFudCBmdW5jdGlvblxuICB2YXIgZm9ybUFwaSA9IHVzZUZvcm1BcGkoKTtcblxuICBpZiAocmVsZXZhbnQpIHtcbiAgICB2YXIgZmYgPSBmb3JtQXBpLmdldEZ1bGxGaWVsZChmaWVsZCk7XG4gICAgdmFyIGFyZ3MgPSB7XG4gICAgICBwYXRoOiBmZixcbiAgICAgIHBhcmVudFBhdGg6IGZmLnJlcGxhY2UoLyguKilbLltdLiovLCAnJDEnKSxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KHZhbHVlcywgcGF0aCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0TWFwLmdldCh2YWx1ZXMsIHBhdGgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgd2hlbiA9IGZ1bmN0aW9uIHdoZW4oX3JlZjIpIHtcbiAgICAgIHZhciB2YWx1ZXMgPSBfcmVmMi52YWx1ZXM7XG4gICAgICByZXR1cm4gcmVsZXZhbnQodmFsdWVzLCBhcmdzKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlbGV2YW50LCB7XG4gICAgICB3aGVuOiB3aGVuXG4gICAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQXJyYXlGaWVsZFdyYXBwZXIsIF9leHRlbmRzKHtcbiAgICAgIGZpZWxkOiBmaWVsZFxuICAgIH0sIHByb3BzKSkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChBcnJheUZpZWxkV3JhcHBlciwgX2V4dGVuZHMoe1xuICAgICAgZmllbGQ6IGZpZWxkXG4gICAgfSwgcHJvcHMpKTtcbiAgfVxufTtcblxudmFyIEFycmF5RmllbGRXcmFwcGVyID0gZnVuY3Rpb24gQXJyYXlGaWVsZFdyYXBwZXIoX3JlZjMpIHtcbiAgdmFyIGNoaWxkcmVuID0gX3JlZjMuY2hpbGRyZW4sXG4gICAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmMywgW1wiY2hpbGRyZW5cIl0pO1xuXG4gIHZhciBfdXNlQXJyYXlGaWVsZCA9IHVzZUFycmF5RmllbGQocHJvcHMpLFxuICAgICAgcmVuZGVyID0gX3VzZUFycmF5RmllbGQucmVuZGVyLFxuICAgICAgYXJyYXlGaWVsZFN0YXRlID0gX3VzZUFycmF5RmllbGQuYXJyYXlGaWVsZFN0YXRlLFxuICAgICAgYXJyYXlGaWVsZEFwaSA9IF91c2VBcnJheUZpZWxkLmFycmF5RmllbGRBcGksXG4gICAgICBmaWVsZCA9IF91c2VBcnJheUZpZWxkLmZpZWxkO1xuXG4gIGlmICh0eXBlb2YgY2hpbGRyZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gcmVuZGVyKGNoaWxkcmVuKF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHtcbiAgICAgIGZpZWxkOiBmaWVsZCxcbiAgICAgIGFycmF5RmllbGRBcGk6IGFycmF5RmllbGRBcGksXG4gICAgICBhcnJheUZpZWxkU3RhdGU6IGFycmF5RmllbGRTdGF0ZVxuICAgIH0sIGFycmF5RmllbGRBcGkpLCBhcnJheUZpZWxkU3RhdGUpKSk7XG4gIH1cblxuICByZXR1cm4gcmVuZGVyKGNoaWxkcmVuKTtcbn07XG5cbnZhciBBcnJheUZpZWxkSXRlbSA9IGZ1bmN0aW9uIEFycmF5RmllbGRJdGVtKF9yZWY0KSB7XG4gIHZhciBhcnJheUZpZWxkSXRlbVN0YXRlID0gX3JlZjQuYXJyYXlGaWVsZEl0ZW1TdGF0ZSxcbiAgICAgIGFycmF5RmllbGRJdGVtQXBpID0gX3JlZjQuYXJyYXlGaWVsZEl0ZW1BcGksXG4gICAgICBjaGlsZHJlbiA9IF9yZWY0LmNoaWxkcmVuO1xuICAvLyBHcmFiIHRoZSBmb3JtIHJlZ2lzdGVyIGNvbnRleHRcbiAgdmFyIHVwZGF0ZXIgPSB1c2VDb250ZXh0KEZvcm1SZWdpc3RlckNvbnRleHQpOyAvLyBHcmFiIHRoZSBmb3JtIHN0YXRlXG5cbiAgdmFyIGZvcm1BcGkgPSB1c2VGb3JtQXBpKCk7IC8vIEEgbGl0dGxlIHRyaWNrIEkgbGVhcm5lZCBpbiBuYW0gdG8gdHJpZ2dlciByZXJlbmRlclxuXG4gIHZhciBfdXNlU3RhdGUgPSB1c2VTdGF0ZSgwKSxcbiAgICAgIF91c2VTdGF0ZTIgPSBfc2xpY2VkVG9BcnJheShfdXNlU3RhdGUsIDIpLFxuICAgICAgc3RhdGUgPSBfdXNlU3RhdGUyWzBdLFxuICAgICAgc2V0U3RhdGUgPSBfdXNlU3RhdGUyWzFdOyAvLyBLZWVwIHRyYWNrIG9mIGZpZWxkcyB0aGF0IGJlbG9uZyB0byB0aGlzIGFycmF5IGZpZWxkXG5cblxuICB2YXIgX3VzZVN0YXRlMyA9IHVzZVN0YXRlKG5ldyBNYXAoKSksXG4gICAgICBfdXNlU3RhdGU0ID0gX3NsaWNlZFRvQXJyYXkoX3VzZVN0YXRlMywgMSksXG4gICAgICBmaWVsZHNCeUlkID0gX3VzZVN0YXRlNFswXTsgLy8gR2V0IHRoaXMgaXRlbXMgZmllbGRcblxuXG4gIHZhciBmaWVsZCA9IGFycmF5RmllbGRJdGVtU3RhdGUuZmllbGQ7IC8vIENyZWF0ZSBzY29wZWQgYXBpXG5cbiAgdmFyIHNjb3BlZEFwaSA9IHVzZVNjb3BlZEFwaShmaWVsZCk7IC8vIFN0YXRlIGdlbmVyYXRpb24gZnVuY3Rpb25cblxuICB2YXIgZ2V0U3RhdGUgPSBmdW5jdGlvbiBnZXRTdGF0ZSgpIHtcbiAgICB2YXIgX2Zvcm1BcGkkZ2V0U3RhdGUgPSBmb3JtQXBpLmdldFN0YXRlKCksXG4gICAgICAgIHZhbHVlcyA9IF9mb3JtQXBpJGdldFN0YXRlLnZhbHVlcyxcbiAgICAgICAgZXJyb3JzID0gX2Zvcm1BcGkkZ2V0U3RhdGUuZXJyb3JzLFxuICAgICAgICB0b3VjaGVkID0gX2Zvcm1BcGkkZ2V0U3RhdGUudG91Y2hlZDsgLy8gR2V0IHRoaXMgZmllbGRzIHN0YXRlXG5cblxuICAgIHZhciBpdGVtU3RhdGUgPSB7XG4gICAgICB2YWx1ZXM6IE9iamVjdE1hcC5nZXQodmFsdWVzLCBmaWVsZCksXG4gICAgICBlcnJvcnM6IE9iamVjdE1hcC5nZXQoZXJyb3JzLCBmaWVsZCksXG4gICAgICB0b3VjaGVkOiBPYmplY3RNYXAuZ2V0KHRvdWNoZWQsIGZpZWxkKVxuICAgIH07XG4gICAgcmV0dXJuIGl0ZW1TdGF0ZTtcbiAgfTsgLy8gUmVnaXN0ZXIgZm9yIGV2ZW50cyBmb3IgcmVyZW5kZXJzIVxuXG5cbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAvLyBEZWZpbmUgZXZlbnQgaGFuZGxlclxuICAgIHZhciBvbkNoYW5nZUhhbmRsZXIgPSBmdW5jdGlvbiBvbkNoYW5nZUhhbmRsZXIoZmllbGROYW1lKSB7XG4gICAgICAvLyBFeGFtcGxlIGZvby5iYXIuYmF6WzNdLmJheiA+Pj4+IGZvby5iYXIuYmF6WzNdXG4gICAgICB2YXIgbWFnaWNWYWx1ZSA9IGZpZWxkTmFtZS5zbGljZSgwLCBmaWVsZE5hbWUubGFzdEluZGV4T2YoJ1snKSAhPSAtMSA/IGZpZWxkTmFtZS5sYXN0SW5kZXhPZignXScpICsgMSA6IGZpZWxkTmFtZS5sZW5ndGgpOyAvLyBUaGlzIGZpZWxkIHVwZGF0ZWQgc28gdHJpZ2dlciByZXJlbmRlclxuXG4gICAgICBpZiAobWFnaWNWYWx1ZSA9PT0gZmllbGQpIHtcbiAgICAgICAgc2V0U3RhdGUoTWF0aC5yYW5kb20oKSk7XG4gICAgICB9XG4gICAgfTsgLy8gUmVnaXN0ZXIgZm9yIGV2ZW50c1xuXG5cbiAgICBmb3JtQXBpLmVtaXR0ZXIub24oJ3ZhbHVlJywgb25DaGFuZ2VIYW5kbGVyKTsgLy8gVW5yZWdpc3RlciBldmVudHNcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3JtQXBpLmVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoJ3ZhbHVlJywgb25DaGFuZ2VIYW5kbGVyKTtcbiAgICB9O1xuICB9LCBbZmllbGRdKTsgLy8gUmVzZXRzIGFsbCBmaWVsZHMgaW4gdGhpcyBpdGVtXG5cbiAgdmFyIHJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgZmllbGRzQnlJZC5mb3JFYWNoKGZ1bmN0aW9uIChmbGQpIHtcbiAgICAgIGZsZC5maWVsZEFwaS5yZXNldCgpO1xuICAgIH0pO1xuICB9OyAvLyBHZW5lcmF0ZSB0aGUgaXRlbSBzdGF0ZVxuXG5cbiAgdmFyIGl0ZW1TdGF0ZSA9IGdldFN0YXRlKCk7IC8vIFdyYXAgdGhlIHVwZGF0ZXIgdG8gdXBkYXRlIGFycmF5IGZpZWxkcyByZWZlcmVuY2VzXG5cbiAgdmFyIHdyYXBwZWRVcGRhdG9yID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIHVwZGF0ZXIpLCB7fSwge1xuICAgIHJlZ2lzdGVyOiBmdW5jdGlvbiByZWdpc3RlcihpZCwgZmxkLCBpbml0aWFsUmVuZGVyKSB7XG4gICAgICBmaWVsZHNCeUlkLnNldChpZCwgZmxkKTtcbiAgICAgIHVwZGF0ZXIucmVnaXN0ZXIoaWQsIGZsZCwgaW5pdGlhbFJlbmRlcik7XG4gICAgfSxcbiAgICBkZXJlZ2lzdGVyOiBmdW5jdGlvbiBkZXJlZ2lzdGVyKGlkKSB7XG4gICAgICBmaWVsZHNCeUlkW1wiZGVsZXRlXCJdKGlkKTtcblxuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgdXBkYXRlci5kZXJlZ2lzdGVyLmFwcGx5KHVwZGF0ZXIsIFtpZF0uY29uY2F0KGFyZ3MpKTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBhcnJheUZpZWxkSXRlbUFwaVZhbHVlID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGFycmF5RmllbGRJdGVtQXBpKSwgc2NvcGVkQXBpKSwge30sIHtcbiAgICByZXNldDogcmVzZXRcbiAgfSk7XG5cbiAgdmFyIGFycmF5RmllbGRJdGVtU3RhdGVWYWx1ZSA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBhcnJheUZpZWxkSXRlbVN0YXRlKSwgaXRlbVN0YXRlKTtcblxuICBpZiAodHlwZW9mIGNoaWxkcmVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZvcm1SZWdpc3RlckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgIHZhbHVlOiB3cmFwcGVkVXBkYXRvclxuICAgIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEFycmF5RmllbGRJdGVtQXBpQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgdmFsdWU6IGFycmF5RmllbGRJdGVtQXBpVmFsdWVcbiAgICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChBcnJheUZpZWxkSXRlbVN0YXRlQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgdmFsdWU6IGFycmF5RmllbGRJdGVtU3RhdGVWYWx1ZVxuICAgIH0sIGNoaWxkcmVuKF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHtcbiAgICAgIGFycmF5RmllbGRJdGVtQXBpOiBhcnJheUZpZWxkSXRlbUFwaVZhbHVlLFxuICAgICAgYXJyYXlGaWVsZEl0ZW1TdGF0ZTogYXJyYXlGaWVsZEl0ZW1TdGF0ZVZhbHVlXG4gICAgfSwgYXJyYXlGaWVsZEl0ZW1BcGlWYWx1ZSksIGFycmF5RmllbGRJdGVtU3RhdGVWYWx1ZSkpKSkpO1xuICB9XG5cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZvcm1SZWdpc3RlckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogd3JhcHBlZFVwZGF0b3JcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQXJyYXlGaWVsZEl0ZW1BcGlDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGFycmF5RmllbGRJdGVtQXBpVmFsdWVcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQXJyYXlGaWVsZEl0ZW1TdGF0ZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogYXJyYXlGaWVsZEl0ZW1TdGF0ZVZhbHVlXG4gIH0sIGNoaWxkcmVuKSkpO1xufTtcblxuQXJyYXlGaWVsZC5JdGVtcyA9IGZ1bmN0aW9uIChfcmVmNSkge1xuICB2YXIgY2hpbGRyZW4gPSBfcmVmNS5jaGlsZHJlbjtcblxuICB2YXIgX3VzZUNvbnRleHQgPSB1c2VDb250ZXh0KEFycmF5RmllbGRTdGF0ZUNvbnRleHQpLFxuICAgICAgZmllbGRzID0gX3VzZUNvbnRleHQuZmllbGRzO1xuXG4gIHJldHVybiBmaWVsZHMubWFwKGZ1bmN0aW9uIChfcmVmNikge1xuICAgIHZhciBhcnJheUZpZWxkSXRlbVN0YXRlID0gX3JlZjYuYXJyYXlGaWVsZEl0ZW1TdGF0ZSxcbiAgICAgICAgYXJyYXlGaWVsZEl0ZW1BcGkgPSBfcmVmNi5hcnJheUZpZWxkSXRlbUFwaTtcbiAgICB2YXIga2V5ID0gYXJyYXlGaWVsZEl0ZW1TdGF0ZS5rZXk7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEFycmF5RmllbGRJdGVtLCB7XG4gICAgICBrZXk6IGtleSxcbiAgICAgIGFycmF5RmllbGRJdGVtQXBpOiBhcnJheUZpZWxkSXRlbUFwaSxcbiAgICAgIGFycmF5RmllbGRJdGVtU3RhdGU6IGFycmF5RmllbGRJdGVtU3RhdGVcbiAgICB9LCBjaGlsZHJlbik7XG4gIH0pO1xufTtcblxudmFyIEZvcm1Db21wb25lbnRzID0gZnVuY3Rpb24gRm9ybUNvbXBvbmVudHMoX3JlZikge1xuICB2YXIgY29tcG9uZW50cyA9IF9yZWYuY29tcG9uZW50cztcblxuICAvLyBHZXQgdGhlIGZpZWxkIG1hcCBvZmYgdGhlIGZvcm1zIGNvbnRleHRcbiAgdmFyIF91c2VDb250ZXh0ID0gdXNlQ29udGV4dChGb3JtUmVnaXN0ZXJDb250ZXh0KSxcbiAgICAgIGZpZWxkTWFwID0gX3VzZUNvbnRleHQuZmllbGRNYXA7XG5cbiAgaWYgKCFjb21wb25lbnRzKSByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIGNvbXBvbmVudHMubWFwKGZ1bmN0aW9uIChjb21wLCBpKSB7XG4gICAgdmFyIGNvbXBvbmVudFR5cGUgPSBjb21wWyd1aTpjb250cm9sJ107XG4gICAgdmFyIENvbXBvbmVudCA9IGZpZWxkTWFwW2NvbXBvbmVudFR5cGVdO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIHtcbiAgICAgIGtleTogXCJ1aS1jb21wLVwiLmNvbmNhdChpKVxuICAgIH0pO1xuICB9KTtcbn07XG5cbnZhciBsb2dnZXIkNCA9IGRlYnVnKCdpbmZvcm1lZDpGb3JtRmllbGRzJyArICdcXHQnKTtcblxudmFyIEZvcm1GaWVsZHMgPSBmdW5jdGlvbiBGb3JtRmllbGRzKF9yZWYpIHtcbiAgdmFyIHNjaGVtYSA9IF9yZWYuc2NoZW1hLFxuICAgICAgcHJlZml4ID0gX3JlZi5wcmVmaXgsXG4gICAgICBvbmx5VmFsaWRhdGVTY2hlbWEgPSBfcmVmLm9ubHlWYWxpZGF0ZVNjaGVtYTtcblxuICAvLyBHZXQgdGhlIGZpZWxkIG1hcCBvZmYgdGhlIGZvcm1zIGNvbnRleHRcbiAgdmFyIF91c2VDb250ZXh0ID0gdXNlQ29udGV4dChGb3JtUmVnaXN0ZXJDb250ZXh0KSxcbiAgICAgIGZpZWxkTWFwID0gX3VzZUNvbnRleHQuZmllbGRNYXA7IC8vIEdldCBmaWVsZHMgZnJvbSBzY2hlYW1hXG5cblxuICB2YXIgZmllbGRzID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNjaGVtYUZpZWxkcyA9IGNvbXB1dGVGaWVsZHNGcm9tU2NoZW1hKHNjaGVtYSwgb25seVZhbGlkYXRlU2NoZW1hLCBwcmVmaXgpO1xuICAgIHZhciBtYXBlZEZpZWxkcyA9IHNjaGVtYUZpZWxkcy5tYXAoZnVuY3Rpb24gKHNjaGVtYUZpZWxkLCBpKSB7XG4gICAgICB2YXIgZmllbGQgPSBzY2hlbWFGaWVsZC5maWVsZCxcbiAgICAgICAgICBwcm9wcyA9IHNjaGVtYUZpZWxkLnByb3BzLFxuICAgICAgICAgIHR5cGUgPSBzY2hlbWFGaWVsZC50eXBlLFxuICAgICAgICAgIHByb3BlcnRpZXMgPSBzY2hlbWFGaWVsZC5wcm9wZXJ0aWVzLFxuICAgICAgICAgIGl0ZW1zID0gc2NoZW1hRmllbGQuaXRlbXMsXG4gICAgICAgICAgY29tcG9uZW50VHlwZSA9IHNjaGVtYUZpZWxkLmNvbXBvbmVudFR5cGUsXG4gICAgICAgICAgdWlCZWZvcmUgPSBzY2hlbWFGaWVsZC51aUJlZm9yZSxcbiAgICAgICAgICB1aUFmdGVyID0gc2NoZW1hRmllbGQudWlBZnRlcixcbiAgICAgICAgICBhbGxPZiA9IHNjaGVtYUZpZWxkLmFsbE9mO1xuICAgICAgdmFyIENvbXBvbmVudCA9IGZpZWxkTWFwW2NvbXBvbmVudFR5cGVdOyAvLyBjb25zb2xlLmxvZygnV1RGJywgc2NoZW1hRmllbGQpO1xuXG4gICAgICBsb2dnZXIkNCgnUmVuZGVyaW5nIEZpZWxkJywgZmllbGQsIHNjaGVtYUZpZWxkKTsgLy8gU2NvcGUgZm9yIG5lc3RlZFxuXG4gICAgICBpZiAoIUNvbXBvbmVudCAmJiB0eXBlID09PSAnb2JqZWN0JyAmJiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChGb3JtRmllbGRzLCB7XG4gICAgICAgICAgc2NoZW1hOiBzY2hlbWFGaWVsZCxcbiAgICAgICAgICBwcmVmaXg6IGZpZWxkLFxuICAgICAgICAgIGtleTogXCJTY2hlYW1GaWVsZC1cIi5jb25jYXQoaSlcbiAgICAgICAgfSk7XG4gICAgICB9IC8vIEFycmF5IGZpZWxkIGZvciBhcnJheSAoIGlmIG5vbmUgd2FzIHByb3ZpZGVkIHVzZSBvdXIgZGVmYXVsdCApXG5cblxuICAgICAgaWYgKCFDb21wb25lbnQgJiYgdHlwZSA9PT0gJ2FycmF5JyAmJiBpdGVtcykge1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQXJyYXlGaWVsZCQxLCBfZXh0ZW5kcyh7XG4gICAgICAgICAga2V5OiBcIlNjaGVhbUZpZWxkLVwiLmNvbmNhdChpKSxcbiAgICAgICAgICBmaWVsZDogZmllbGQsXG4gICAgICAgICAgaXRlbXM6IGl0ZW1zLFxuICAgICAgICAgIHVpQmVmb3JlOiB1aUJlZm9yZSxcbiAgICAgICAgICB1aUFmdGVyOiB1aUFmdGVyXG4gICAgICAgIH0sIHByb3BzKSk7XG4gICAgICB9IC8vIFVzZXIgY3JlYXRlZCBjdXN0b20gYXJyYXkgZmllbGRcblxuXG4gICAgICBpZiAoQ29tcG9uZW50ICYmIGNvbXBvbmVudFR5cGUgPT09ICdhcnJheScgJiYgaXRlbXMgJiYgdHlwZSA9PT0gJ2FycmF5Jykge1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50LCBfZXh0ZW5kcyh7XG4gICAgICAgICAga2V5OiBcIlNjaGVhbUZpZWxkLVwiLmNvbmNhdChpKSxcbiAgICAgICAgICBmaWVsZDogZmllbGQsXG4gICAgICAgICAgaXRlbXM6IGl0ZW1zLFxuICAgICAgICAgIHVpQmVmb3JlOiB1aUJlZm9yZSxcbiAgICAgICAgICB1aUFmdGVyOiB1aUFmdGVyXG4gICAgICAgIH0sIHByb3BzKSk7XG4gICAgICB9IC8vIEZvciBjb25kaXRpb25hbHNcblxuXG4gICAgICBpZiAoY29tcG9uZW50VHlwZSA9PT0gJ2NvbmRpdGlvbmFscycpIHtcbiAgICAgICAgcmV0dXJuIGFsbE9mLm1hcChmdW5jdGlvbiAoY29uZGl0aW9uYWwpIHtcbiAgICAgICAgICAvLyBFeGFtcGxlIHRoZW4gKCBpdHMgYSBzdWJzY2hlbWEgKVxuICAgICAgICAgIC8vIHRoZW46IHtcbiAgICAgICAgICAvLyAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAvLyAgICAgc3BvdXNlOiB7XG4gICAgICAgICAgLy8gICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgLy8gICAgICAgdGl0bGU6ICdTcG91c2UgbmFtZScsXG4gICAgICAgICAgLy8gICAgICAgJ3VpOmNvbnRyb2wnOiAnaW5wdXQnXG4gICAgICAgICAgLy8gICAgIH1cbiAgICAgICAgICAvLyAgIH1cbiAgICAgICAgICAvLyB9XG4gICAgICAgICAgdmFyIHN1YlNjaGVtYSA9IGNvbmRpdGlvbmFsLnRoZW47IC8vIFR1cm4gdGhlIGlmIGludG8gYSB3aGVuIGZ1bmN0aW9uIGZvciBpbmZvcm1lZFxuICAgICAgICAgIC8vIEV4YW1wbGUgaWYgY29uZGl0aW9uXG4gICAgICAgICAgLy8gaWY6IHtcbiAgICAgICAgICAvLyAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAvLyAgICAgbWFycmllZDogeyBjb25zdDogJ3llcycgfVxuICAgICAgICAgIC8vICAgfSxcbiAgICAgICAgICAvLyAgIHJlcXVpcmVkOiBbJ21hcnJpZWQnXVxuICAgICAgICAgIC8vIH0sXG5cbiAgICAgICAgICB2YXIgY29uZGl0aW9ucyA9IGNvbmRpdGlvbmFsW1wiaWZcIl0ucHJvcGVydGllcztcblxuICAgICAgICAgIHZhciB3aGVuID0gZnVuY3Rpb24gd2hlbihfcmVmMikge1xuICAgICAgICAgICAgdmFyIHZhbHVlcyA9IF9yZWYyLnZhbHVlcztcbiAgICAgICAgICAgIC8vIEV4YW1wbGUga2V5IFwibWFycmllZCwgRXhhbXBsZSBjb25kaXRpb246IFwieyBjb25zdDogJ3llcycgfVwiXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoY29uZGl0aW9ucykuZXZlcnkoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICB2YXIgY29uZGl0aW9uID0gY29uZGl0aW9uc1trZXldOyAvLyB2YWx1ZXMubWFycmllZCA9PT0gJ3llcydcblxuICAgICAgICAgICAgICByZXR1cm4gdmFsdWVzW2tleV0gPT09IGNvbmRpdGlvbltcImNvbnN0XCJdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWxldmFudCwge1xuICAgICAgICAgICAga2V5OiBcIlNjaGVhbUZpZWxkLVwiLmNvbmNhdChpKSxcbiAgICAgICAgICAgIHdoZW46IHdoZW5cbiAgICAgICAgICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChGb3JtRmllbGRzLCB7XG4gICAgICAgICAgICBzY2hlbWE6IHN1YlNjaGVtYVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgICB9IC8vIElmIG5vIGNvbSByZXQgbnVsbCAoIGRvbnQgcmVuZGVyIClcblxuXG4gICAgICBpZiAoIUNvbXBvbmVudCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENvbXBvbmVudCwgX2V4dGVuZHMoe1xuICAgICAgICBrZXk6IFwiU2NoZWFtRmllbGQtXCIuY29uY2F0KGkpLFxuICAgICAgICBmaWVsZDogZmllbGRcbiAgICAgIH0sIHByb3BzKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG1hcGVkRmllbGRzO1xuICB9LCBbc2NoZW1hLCBwcmVmaXhdKTtcbiAgcmV0dXJuIGZpZWxkcztcbn07XG5cbnZhciBBcnJheUZpZWxkJDEgPSBmdW5jdGlvbiBBcnJheUZpZWxkJDEoX3JlZikge1xuICB2YXIgZmllbGQgPSBfcmVmLmZpZWxkLFxuICAgICAgaXRlbXMgPSBfcmVmLml0ZW1zLFxuICAgICAgdWlCZWZvcmUgPSBfcmVmLnVpQmVmb3JlLFxuICAgICAgdWlBZnRlciA9IF9yZWYudWlBZnRlcixcbiAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFtcImZpZWxkXCIsIFwiaXRlbXNcIiwgXCJ1aUJlZm9yZVwiLCBcInVpQWZ0ZXJcIl0pO1xuXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChBcnJheUZpZWxkLCBfZXh0ZW5kcyh7XG4gICAgZmllbGQ6IGZpZWxkXG4gIH0sIHByb3BzKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRm9ybUNvbXBvbmVudHMsIHtcbiAgICBjb21wb25lbnRzOiB1aUJlZm9yZVxuICB9KSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQXJyYXlGaWVsZC5JdGVtcywgbnVsbCwgZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgdmFyIGZpZWxkID0gX3JlZjIuZmllbGQ7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChGb3JtQ29tcG9uZW50cywge1xuICAgICAgY29tcG9uZW50czogaXRlbXNbJ3VpOmJlZm9yZSddXG4gICAgfSksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZvcm1GaWVsZHMsIHtcbiAgICAgIHNjaGVtYTogaXRlbXMsXG4gICAgICBwcmVmaXg6IGZpZWxkXG4gICAgfSksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZvcm1Db21wb25lbnRzLCB7XG4gICAgICBjb21wb25lbnRzOiBpdGVtc1sndWk6YWZ0ZXInXVxuICAgIH0pKTtcbiAgfSksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZvcm1Db21wb25lbnRzLCB7XG4gICAgY29tcG9uZW50czogdWlBZnRlclxuICB9KSk7XG59O1xuXG52YXIgZGVmYXVsdEZpZWxkTWFwID0ge1xuICBzZWxlY3Q6IFNlbGVjdCQxLFxuICBpbnB1dDogVGV4dCQxLFxuICB0ZXh0YXJlYTogVGV4dEFyZWEkMSxcbiAgY2hlY2tib3g6IENoZWNrYm94JDEsXG4gIHJhZGlvOiBSYWRpb0dyb3VwJDEsXG4gIGFkZDogQWRkQnV0dG9uLFxuICByZW1vdmU6IEFkZEJ1dHRvbiQxLFxuICBhcnJheTogQXJyYXlGaWVsZCQxXG59O1xuXG52YXIgZGVidWckMiA9IGRlYnVnKCdpbmZvcm1lZDpDb250cm9sbGVyJyArICdcXHQnKTtcblxudmFyIGlzRXhwZWN0ZWQgPSBmdW5jdGlvbiBpc0V4cGVjdGVkKHBhdGgsIGV4cGVjdGVkUmVtb3ZhbHMpIHtcbiAgdmFyIGluY2x1ZGVkS2V5ID0gT2JqZWN0LmtleXMoZXhwZWN0ZWRSZW1vdmFscykuZmluZChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIHBhdGguaW5jbHVkZXMoa2V5KTtcbiAgfSk7XG4gIGlmICghaW5jbHVkZWRLZXkpIHJldHVybjtcbiAgdmFyIHN0YXJ0ID0gcGF0aC5zbGljZSgwLCBpbmNsdWRlZEtleS5sZW5ndGgpO1xuICByZXR1cm4gc3RhcnQgPT09IGluY2x1ZGVkS2V5O1xufTtcblxudmFyIG5vb3AgPSBmdW5jdGlvbiBub29wKCkge307XG5cbnZhciBGb3JtQ29udHJvbGxlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0V2ZW50RW1pdHRlcikge1xuICBfaW5oZXJpdHMoRm9ybUNvbnRyb2xsZXIsIF9FdmVudEVtaXR0ZXIpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoRm9ybUNvbnRyb2xsZXIpO1xuXG4gIGZ1bmN0aW9uIEZvcm1Db250cm9sbGVyKCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGb3JtQ29udHJvbGxlcik7XG5cbiAgICAvLyBEb250IGZvcmdldCB0byBjYWxsIHN1cGVyISA6KVxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgX3RoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdmFyIGFqdiA9IG9wdGlvbnMuYWp2LFxuICAgICAgICBzY2hlbWEgPSBvcHRpb25zLnNjaGVtYSxcbiAgICAgICAgZmllbGRNYXAgPSBvcHRpb25zLmZpZWxkTWFwOyAvLyBEZWJvdW5jZWQgY2hhbmdlXG4gICAgLy8gY29uc3QgY2hhbmdlID0gKCkgPT4ge1xuICAgIC8vICAgdGhpcy5yZWJ1aWxkU3RhdGUoKTtcbiAgICAvLyAgIHRoaXMuZW1pdCgnY2hhbmdlJyk7XG4gICAgLy8gfTtcbiAgICAvLyB0aGlzLmNoYW5nZSA9IGRlYm91bmNlKGNoYW5nZSwgMjUwKTtcbiAgICAvLyBDcmVhdGUgbmV3IGFqdiBpbnN0YW5jZSBpZiBwYXNzZWRcblxuICAgIF90aGlzLmFqdiA9IGFqdiA/IG5ldyBhanYoe1xuICAgICAgYWxsRXJyb3JzOiB0cnVlXG4gICAgfSkgOiBudWxsO1xuICAgIF90aGlzLmFqdlZhbGlkYXRlID0gYWp2ID8gX3RoaXMuYWp2LmNvbXBpbGUoc2NoZW1hKSA6IG51bGw7IC8vIEFkZCBmaWVsZCBtYXAgKCBkZWZhdWx0cyB0byBvdXIgZmllbGQgbWFwIClcblxuICAgIF90aGlzLmZpZWxkTWFwID0gZmllbGRNYXAgfHwgZGVmYXVsdEZpZWxkTWFwOyAvLyBNYXAgd2lsbCBzdG9yZSBhbGwgZmllbGRzIGJ5IGlkXG4gICAgLy8gS2V5ID0+IHV1aWRcbiAgICAvLyBWYWwgPT4gZmllbGRPYmpcbiAgICAvLyBXaHk/IHNvIHRoZSBmb3JtIGNhbiBjb250cm9sIHRoZSBmaWVsZHMhXG5cbiAgICBfdGhpcy5maWVsZHNCeUlkID0gbmV3IE1hcCgpOyAvLyBNYXAgd2lsbCBzdG9yZSBhbGwgZmllbGRzIGJ5IG5hbWVcbiAgICAvLyBLZXkgPT4gZmllbGROYW1lIC0gZXhhbXBsZTogXCJmb28uYmFyWzNdLmJhelwiXG4gICAgLy8gVmFsID0+IGZpZWxkT2JqXG4gICAgLy8gV2h5PyBzbyB0aGUgZm9ybSBjYW4gY29udHJvbCB0aGUgZmllbGRzIVxuXG4gICAgX3RoaXMuZmllbGRzQnlOYW1lID0ge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQobmFtZSkge1xuICAgICAgICB2YXIgZmllbGRCeU5hbWU7IC8vIFRPRE8gc3BlZWQgdGhpcyB1cCBtYXliZVxuXG4gICAgICAgIF90aGlzLmZpZWxkc0J5SWQuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICBpZiAodmFsdWUgJiYgdmFsdWUuZmllbGQgPT09IG5hbWUpIHtcbiAgICAgICAgICAgIGZpZWxkQnlOYW1lID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZmllbGRCeU5hbWU7XG4gICAgICB9XG4gICAgfTsgLy8gTWFwIHRvIHN0b3JlIHdob3Mgb24gdGhlIHNjcmVlblxuXG4gICAgX3RoaXMub25TY3JlZW4gPSB7fTsgLy8gTWFwIHRvIHN0b3JlIGZpZWxkcyBiZWluZyByZW1vdmVkXG5cbiAgICBfdGhpcy5leHBlY3RlZFJlbW92YWxzID0ge307XG4gICAgX3RoaXMucHVsbGVkT3V0ID0ge307IC8vIE1hcCBvZiBzYXZlZCB2YWx1ZXNcblxuICAgIF90aGlzLnNhdmVkVmFsdWVzID0ge307IC8vIEluaXRpYWxpemUgdGhlIGNvbnRyb2xsZXIgc3RhdGVcblxuICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgcHJpc3RpbmU6IHRydWUsXG4gICAgICBkaXJ0eTogZmFsc2UsXG4gICAgICBpbnZhbGlkOiBmYWxzZSxcbiAgICAgIHN1Ym1pdHM6IDAsXG4gICAgICBzdGVwOiAwLFxuICAgICAgdmFsaWRhdGluZzogMCxcbiAgICAgIHN1Ym1pdHRpbmc6IGZhbHNlLFxuICAgICAgdmFsdWVzOiB7fSxcbiAgICAgIGVycm9yczoge30sXG4gICAgICB0b3VjaGVkOiB7fVxuICAgIH07IC8vIEluaXRpYWxpemUgYSBkdW1teSBmaWVsZCAoIHNlZSBnZXRGaWVsZCBmb3IgZXhhbXBsZSB1c2UgKVxuXG4gICAgX3RoaXMuZHVtbXlGaWVsZCA9IHtcbiAgICAgIGZpZWxkQXBpOiB7XG4gICAgICAgIHNldFZhbHVlOiBub29wLFxuICAgICAgICBzZXRUb3VjaGVkOiBub29wLFxuICAgICAgICBzZXRFcnJvcjogbm9vcCxcbiAgICAgICAgcmVzZXQ6IG5vb3AsXG4gICAgICAgIHZhbGlkYXRlOiBub29wLFxuICAgICAgICBnZXRWYWx1ZTogbm9vcCxcbiAgICAgICAgZ2V0VG91Y2hlZDogbm9vcCxcbiAgICAgICAgZ2V0RXJyb3I6IG5vb3AsXG4gICAgICAgIGdldEZpZWxkU3RhdGU6IG5vb3AsXG4gICAgICAgIGNoZWNrUmVsZXZhbnQ6IG5vb3BcbiAgICAgIH1cbiAgICB9OyAvLyBCaW5kIGZ1bmN0aW9ucyB0aGF0IHdpbGwgYmUgY2FsbGVkIGV4dGVybmFsbHlcblxuICAgIF90aGlzLmRlcmVnaXN0ZXIgPSBfdGhpcy5kZXJlZ2lzdGVyLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgIF90aGlzLnJlZ2lzdGVyID0gX3RoaXMucmVnaXN0ZXIuYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgX3RoaXMuZ2V0VmFsdWUgPSBfdGhpcy5nZXRWYWx1ZS5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICBfdGhpcy5nZXRUb3VjaGVkID0gX3RoaXMuZ2V0VG91Y2hlZC5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICBfdGhpcy5nZXRFcnJvciA9IF90aGlzLmdldEVycm9yLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgIF90aGlzLmdldEVycm9ycyA9IF90aGlzLmdldEVycm9ycy5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICBfdGhpcy5zZXRWYWx1ZSA9IF90aGlzLnNldFZhbHVlLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgIF90aGlzLmdldFZhbHVlcyA9IF90aGlzLmdldFZhbHVlcy5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICBfdGhpcy5nZXRTdGVwID0gX3RoaXMuZ2V0U3RlcC5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICBfdGhpcy5zZXRTdGVwID0gX3RoaXMuc2V0U3RlcC5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICBfdGhpcy5iYWNrID0gX3RoaXMuYmFjay5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICBfdGhpcy5uZXh0ID0gX3RoaXMubmV4dC5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICBfdGhpcy5zZXRDdXJyZW50ID0gX3RoaXMuc2V0Q3VycmVudC5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICBfdGhpcy5zZXRUb3VjaGVkID0gX3RoaXMuc2V0VG91Y2hlZC5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICBfdGhpcy5zZXRFcnJvciA9IF90aGlzLnNldEVycm9yLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgIF90aGlzLnNldEZvcm1FcnJvciA9IF90aGlzLnNldEZvcm1FcnJvci5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICBfdGhpcy5zdWJtaXRGb3JtID0gX3RoaXMuc3VibWl0Rm9ybS5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICBfdGhpcy5yZXNldCA9IF90aGlzLnJlc2V0LmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgIF90aGlzLnVwZGF0ZSA9IF90aGlzLnVwZGF0ZS5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICBfdGhpcy52YWxpZGF0ZSA9IF90aGlzLnZhbGlkYXRlLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgIF90aGlzLnNjcmVlblZhbGlkID0gX3RoaXMuc2NyZWVuVmFsaWQuYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgX3RoaXMua2V5RG93biA9IF90aGlzLmtleURvd24uYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgX3RoaXMuZ2V0RmllbGQgPSBfdGhpcy5nZXRGaWVsZC5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICBfdGhpcy5nZXRJbml0aWFsVmFsdWUgPSBfdGhpcy5nZXRJbml0aWFsVmFsdWUuYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgX3RoaXMuc2V0SW5pdGlhbFZhbHVlID0gX3RoaXMuc2V0SW5pdGlhbFZhbHVlLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgIF90aGlzLmdldE9wdGlvbnMgPSBfdGhpcy5nZXRPcHRpb25zLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgIF90aGlzLmdldEZvcm1TdGF0ZSA9IF90aGlzLmdldEZvcm1TdGF0ZS5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICBfdGhpcy5leHBlY3RSZW1vdmFsID0gX3RoaXMuZXhwZWN0UmVtb3ZhbC5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICBfdGhpcy5nZXRTYXZlZFZhbHVlID0gX3RoaXMuZ2V0U2F2ZWRWYWx1ZS5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICBfdGhpcy5yZW1vdmVTYXZlZFN0YXRlID0gX3RoaXMucmVtb3ZlU2F2ZWRTdGF0ZS5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICBfdGhpcy5nZXREZXJyaXZlZFZhbHVlID0gX3RoaXMuZ2V0RGVycml2ZWRWYWx1ZS5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICBfdGhpcy5zZXRWYWx1ZXMgPSBfdGhpcy5zZXRWYWx1ZXMuYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgX3RoaXMucmVzZXRGaWVsZCA9IF90aGlzLnJlc2V0RmllbGQuYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgX3RoaXMuZmllbGRFeGlzdHMgPSBfdGhpcy5maWVsZEV4aXN0cy5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICBfdGhpcy52YWxpZGF0ZUZpZWxkID0gX3RoaXMudmFsaWRhdGVGaWVsZC5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICBfdGhpcy5ub3RpZnkgPSBfdGhpcy5ub3RpZnkuYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgX3RoaXMudmFsaWRhdGluZyA9IF90aGlzLnZhbGlkYXRpbmcuYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgX3RoaXMudmFsaWRhdGVkID0gX3RoaXMudmFsaWRhdGVkLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpOyAvLyB0aGlzLmNoYW5nZSA9IHRoaXMuY2hhbmdlLmJpbmQodGhpcyk7XG4gICAgLy8gdGhpcy5jbGVhciA9IHRoaXMuY2xlYXIuYmluZCh0aGlzKTtcbiAgICAvLyBVcGRhdGVyIHdpbGwgYmUgdXNlZCBieSBmaWVsZHMgdG8gdXBkYXRlIGFuZCByZWdpc3RlclxuXG4gICAgX3RoaXMudXBkYXRlciA9IHtcbiAgICAgIHJlZ2lzdGVyOiBfdGhpcy5yZWdpc3RlcixcbiAgICAgIGRlcmVnaXN0ZXI6IF90aGlzLmRlcmVnaXN0ZXIsXG4gICAgICBnZXRGaWVsZDogX3RoaXMuZ2V0RmllbGQsXG4gICAgICB1cGRhdGU6IF90aGlzLnVwZGF0ZSxcbiAgICAgIC8vIGNsZWFyOiB0aGlzLmNsZWFyLFxuICAgICAgZmllbGRNYXA6IF90aGlzLmZpZWxkTWFwLFxuICAgICAgc2V0VmFsdWU6IGZ1bmN0aW9uIHNldFZhbHVlKGZpZWxkSWQsIHZhbHVlKSB7XG4gICAgICAgIHZhciBlbWl0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0cnVlO1xuXG4gICAgICAgIHZhciBmaWVsZCA9IF90aGlzLmZpZWxkc0J5SWQuZ2V0KGZpZWxkSWQpO1xuXG4gICAgICAgIGlmICghZmllbGQuc2hhZG93KSB7XG4gICAgICAgICAgT2JqZWN0TWFwLnNldChfdGhpcy5zdGF0ZS52YWx1ZXMsIGZpZWxkLmZpZWxkLCBmaWVsZC5maWVsZEFwaS5nZXRWYWx1ZSgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZmllbGQuZmllbGRBcGkucmVsZXZhbnQoX3RoaXMuc3RhdGUudmFsdWVzKSkge1xuICAgICAgICAgIE9iamVjdE1hcFtcImRlbGV0ZVwiXShfdGhpcy5zdGF0ZS52YWx1ZXMsIGZpZWxkLmZpZWxkKTtcbiAgICAgICAgfSAvLyBDbGVhbnVwIHBoYXNlIHRvIGdldCByaWQgb2YgaXJyZWxldmFudCBmaWVsZHNcbiAgICAgICAgLy8gQWxzbyBldmFsdWF0ZSByZWxldmFuY2Ugb24gYWxsIGZpZWxkc1xuXG5cbiAgICAgICAgX3RoaXMuZmllbGRzQnlJZC5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgLy8gSWYgYSBmaWVsZHMgd2l0aGluIGFuIGlycmVsaXZhbnQgc3RlcCB0aGVuIHJlbW92ZSBpdFxuICAgICAgICAgIC8vIE90aGVyd2lzZSwgY2hlY2sgdG8gc2VlIGlmIGl0cyByZWxldmFudCBhbmQgb25seSByZW1vdmUgaWYga2VlcCBzdGF0ZSBpcyBmYWxzZVxuICAgICAgICAgIHZhciBuZXdSZWwgPSBmLmZpZWxkQXBpLmNoZWNrUmVsZXZhbnQoKTtcblxuICAgICAgICAgIGlmICghZi5maWVsZEFwaS5tdWx0aXN0ZXBSZWxldmFudChfdGhpcy5zdGF0ZS52YWx1ZXMpIHx8ICFuZXdSZWwgJiYgIWYua2VlcFN0YXRlKSB7XG4gICAgICAgICAgICBPYmplY3RNYXBbXCJkZWxldGVcIl0oX3RoaXMuc3RhdGUudmFsdWVzLCBmLmZpZWxkKTtcbiAgICAgICAgICAgIE9iamVjdE1hcFtcImRlbGV0ZVwiXShfdGhpcy5zdGF0ZS50b3VjaGVkLCBmLmZpZWxkKTtcbiAgICAgICAgICAgIE9iamVjdE1hcFtcImRlbGV0ZVwiXShfdGhpcy5zdGF0ZS5lcnJvcnMsIGYuZmllbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGVtaXQpIHtcbiAgICAgICAgICBfdGhpcy5lbWl0KCdjaGFuZ2UnKTtcblxuICAgICAgICAgIF90aGlzLmVtaXQoJ3ZhbHVlJywgZmllbGQuZmllbGQsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNldFRvdWNoZWQ6IGZ1bmN0aW9uIHNldFRvdWNoZWQoZmllbGRJZCwgdG91Y2gpIHtcbiAgICAgICAgdmFyIGVtaXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRydWU7XG5cbiAgICAgICAgdmFyIGZpZWxkID0gX3RoaXMuZmllbGRzQnlJZC5nZXQoZmllbGRJZCk7XG5cbiAgICAgICAgaWYgKCFmaWVsZC5zaGFkb3cgJiYgZmllbGQuZmllbGRBcGkuZ2V0SXNSZWxldmFudCgpKSB7XG4gICAgICAgICAgT2JqZWN0TWFwLnNldChfdGhpcy5zdGF0ZS50b3VjaGVkLCBmaWVsZC5maWVsZCwgZmllbGQuZmllbGRBcGkuZ2V0VG91Y2hlZCgpKTtcbiAgICAgICAgfSAvLyBTaGFkb3cgdmFsdWVzIG92ZXJyaWRlIHVubGVzcyB1bmRlZmluZWRcblxuXG4gICAgICAgIGlmIChmaWVsZC5zaGFkb3cgJiYgZmllbGQuZmllbGRBcGkuZ2V0RXJyb3IoKSAhPSB1bmRlZmluZWQgJiYgZmllbGQuZmllbGRBcGkucmVsZXZhbnQoX3RoaXMuc3RhdGUudmFsdWVzKSkge1xuICAgICAgICAgIE9iamVjdE1hcC5zZXQoX3RoaXMuc3RhdGUudG91Y2hlZCwgZmllbGQuZmllbGQsIGZpZWxkLmZpZWxkQXBpLmdldFRvdWNoZWQoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW1pdCkge1xuICAgICAgICAgIF90aGlzLmVtaXQoJ2NoYW5nZScpOyAvL3RoaXMuZW1pdCgndG91Y2gnLCBmaWVsZC5maWVsZCwgdG91Y2gpO1xuXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzZXRFcnJvcjogZnVuY3Rpb24gc2V0RXJyb3IoZmllbGRJZCwgZXJyb3IpIHtcbiAgICAgICAgdmFyIGVtaXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRydWU7XG5cbiAgICAgICAgdmFyIGZpZWxkID0gX3RoaXMuZmllbGRzQnlJZC5nZXQoZmllbGRJZCk7XG5cbiAgICAgICAgaWYgKCFmaWVsZC5zaGFkb3cgJiYgZmllbGQuZmllbGRBcGkuZ2V0SXNSZWxldmFudCgpKSB7XG4gICAgICAgICAgT2JqZWN0TWFwLnNldChfdGhpcy5zdGF0ZS5lcnJvcnMsIGZpZWxkLmZpZWxkLCBmaWVsZC5maWVsZEFwaS5nZXRFcnJvcigpKTtcbiAgICAgICAgfSAvLyBTaGFkb3cgdmFsdWVzIG92ZXJyaWRlIHVubGVzcyB1bmRlZmluZWRcblxuXG4gICAgICAgIHZhciBjdXJyZW50RXJyb3IgPSBPYmplY3RNYXAuZ2V0KF90aGlzLnN0YXRlLmVycm9ycywgZmllbGQuZmllbGQpO1xuXG4gICAgICAgIGlmIChmaWVsZC5zaGFkb3cgJiYgZmllbGQuZmllbGRBcGkuZ2V0RXJyb3IoKSAhPSB1bmRlZmluZWQgJiYgZmllbGQuZmllbGRBcGkucmVsZXZhbnQoX3RoaXMuc3RhdGUudmFsdWVzKSkge1xuICAgICAgICAgIE9iamVjdE1hcC5zZXQoX3RoaXMuc3RhdGUuZXJyb3JzLCBmaWVsZC5maWVsZCwgZmllbGQuZmllbGRBcGkuZ2V0RXJyb3IoKSk7XG4gICAgICAgIH0gLy8gU3BlY2lhbCBjYXNlIGZvciBhdHRlbXB0aW5nIHRvIHNldCBzaGFkb3cgdG8gdW5kZWZpZW5kXG4gICAgICAgIGVsc2UgaWYgKGZpZWxkLnNoYWRvdyAmJiBmaWVsZC5maWVsZEFwaS5nZXRFcnJvcigpID09PSB1bmRlZmluZWQgJiYgZmllbGQuZmllbGRBcGkucmVsZXZhbnQoX3RoaXMuc3RhdGUudmFsdWVzKSAmJiAvLyBUT0RPIG1heWJlIGNoZWNrIGlmIG9iamVjdCBvciBhcnJheVxuICAgICAgICAgIHR5cGVvZiBjdXJyZW50RXJyb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBPYmplY3RNYXAuc2V0KF90aGlzLnN0YXRlLmVycm9ycywgZmllbGQuZmllbGQsIGZpZWxkLmZpZWxkQXBpLmdldEVycm9yKCkpO1xuICAgICAgICAgIH1cblxuICAgICAgICBpZiAoZW1pdCkge1xuICAgICAgICAgIF90aGlzLmVtaXQoJ2NoYW5nZScpOyAvL3RoaXMuZW1pdCgnZXJyb3InLCBmaWVsZC5maWVsZCwgZXJyb3IpO1xuXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBleHBlY3RSZW1vdmFsOiBfdGhpcy5leHBlY3RSZW1vdmFsLFxuICAgICAgZ2V0SW5pdGlhbFZhbHVlOiBfdGhpcy5nZXRJbml0aWFsVmFsdWVcbiAgICB9OyAvLyBEZWZpbmUgdGhlIGZvcm1BcGlcblxuICAgIF90aGlzLmZvcm1BcGkgPSB7XG4gICAgICBzZXRWYWx1ZTogX3RoaXMuc2V0VmFsdWUsXG4gICAgICBzZXRUb3VjaGVkOiBfdGhpcy5zZXRUb3VjaGVkLFxuICAgICAgc2V0RXJyb3I6IF90aGlzLnNldEVycm9yLFxuICAgICAgc2V0Rm9ybUVycm9yOiBfdGhpcy5zZXRGb3JtRXJyb3IsXG4gICAgICBzZXRWYWx1ZXM6IF90aGlzLnNldFZhbHVlcyxcbiAgICAgIHNldEluaXRpYWxWYWx1ZTogX3RoaXMuc2V0SW5pdGlhbFZhbHVlLFxuICAgICAgZ2V0VmFsdWU6IF90aGlzLmdldFZhbHVlLFxuICAgICAgZ2V0VG91Y2hlZDogX3RoaXMuZ2V0VG91Y2hlZCxcbiAgICAgIGdldEVycm9yOiBfdGhpcy5nZXRFcnJvcixcbiAgICAgIHJlc2V0OiBfdGhpcy5yZXNldCxcbiAgICAgIHN1Ym1pdEZvcm06IF90aGlzLnN1Ym1pdEZvcm0sXG4gICAgICBnZXRTdGF0ZTogX3RoaXMuZ2V0Rm9ybVN0YXRlLFxuICAgICAgZ2V0VmFsdWVzOiBfdGhpcy5nZXRWYWx1ZXMsXG4gICAgICBnZXRGdWxsRmllbGQ6IF90aGlzLmdldEZ1bGxGaWVsZCxcbiAgICAgIGZpZWxkRXhpc3RzOiBfdGhpcy5maWVsZEV4aXN0cyxcbiAgICAgIGdldEluaXRpYWxWYWx1ZTogX3RoaXMuZ2V0SW5pdGlhbFZhbHVlLFxuICAgICAgdmFsaWRhdGU6IF90aGlzLnZhbGlkYXRlLFxuICAgICAgdmFsaWRhdGVGaWVsZDogX3RoaXMudmFsaWRhdGVGaWVsZCxcbiAgICAgIHNjcmVlblZhbGlkOiBfdGhpcy5zY3JlZW5WYWxpZCxcbiAgICAgIHJlc2V0RmllbGQ6IF90aGlzLnJlc2V0RmllbGQsXG4gICAgICBnZXRPcHRpb25zOiBfdGhpcy5nZXRPcHRpb25zLFxuICAgICAgZW1pdHRlcjogX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksXG4gICAgICBnZXRTYXZlZFZhbHVlOiBfdGhpcy5nZXRTYXZlZFZhbHVlLFxuICAgICAgcmVtb3ZlU2F2ZWRTdGF0ZTogX3RoaXMucmVtb3ZlU2F2ZWRTdGF0ZSxcbiAgICAgIGdldERlcnJpdmVkVmFsdWU6IF90aGlzLmdldERlcnJpdmVkVmFsdWUsXG4gICAgICBnZXRTdGVwOiBfdGhpcy5nZXRTdGVwLFxuICAgICAgc2V0U3RlcDogX3RoaXMuc2V0U3RlcCxcbiAgICAgIG5leHQ6IF90aGlzLm5leHQsXG4gICAgICBiYWNrOiBfdGhpcy5iYWNrLFxuICAgICAgc2V0Q3VycmVudDogX3RoaXMuc2V0Q3VycmVudCxcbiAgICAgIHZhbGlkYXRlZDogX3RoaXMudmFsaWRhdGVkLFxuICAgICAgdmFsaWRhdGluZzogX3RoaXMudmFsaWRhdGluZ1xuICAgIH07XG5cbiAgICBfdGhpcy5vbigndmFsdWUnLCBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgIC8vIFRoZSBmb3JtcyB2YWx1ZXMgaGF2ZSBjaGFuZ2VkIHNvIHdlIHdhbnQgdG8gY2xlYXIgZm9ybSBsZXZlbCBlcnJvclxuICAgICAgZGVsZXRlIF90aGlzLnN0YXRlLmVycm9yO1xuXG4gICAgICBfdGhpcy5ub3RpZnkoZmllbGQpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gU2V0dGVycyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblxuICBfY3JlYXRlQ2xhc3MoRm9ybUNvbnRyb2xsZXIsIFt7XG4gICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRWYWx1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRWYWx1ZShuYW1lLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgdGhpcy5nZXRGaWVsZChuYW1lKS5maWVsZEFwaS5zZXRWYWx1ZSh2YWx1ZSwgbnVsbCwgX29iamVjdFNwcmVhZDIoe1xuICAgICAgICBhbGxvd0VtcHR5U3RyaW5nOiB0aGlzLm9wdGlvbnMuYWxsb3dFbXB0eVN0cmluZ3NcbiAgICAgIH0sIG9wdGlvbnMpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0VG91Y2hlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRUb3VjaGVkKG5hbWUsIHZhbHVlKSB7XG4gICAgICB0aGlzLmdldEZpZWxkKG5hbWUpLmZpZWxkQXBpLnNldFRvdWNoZWQodmFsdWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRFcnJvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRFcnJvcihuYW1lLCB2YWx1ZSkge1xuICAgICAgdGhpcy5nZXRGaWVsZChuYW1lKS5maWVsZEFwaS5zZXRFcnJvcih2YWx1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldEZvcm1FcnJvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRGb3JtRXJyb3IodmFsdWUpIHtcbiAgICAgIHRoaXMuc3RhdGUuZXJyb3IgPSB2YWx1ZTtcbiAgICAgIHRoaXMuZW1pdCgnY2hhbmdlJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZhbGlkYXRpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsaWRhdGluZygpIHtcbiAgICAgIHRoaXMuc3RhdGUudmFsaWRhdGluZyA9IHRoaXMuc3RhdGUudmFsaWRhdGluZyArIDE7XG4gICAgICB0aGlzLmVtaXQoJ2NoYW5nZScpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ2YWxpZGF0ZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsaWRhdGVkKG5hbWUsIGVycm9yKSB7XG4gICAgICAvLyBEZWNyZW1lbnQgdGhlIHZhbGlkYXRpbmdcbiAgICAgIHRoaXMuc3RhdGUudmFsaWRhdGluZyA9IHRoaXMuc3RhdGUudmFsaWRhdGluZyAtIDE7IC8vIFNldCB0aGUgZXJyb3IgaWYgdGhlcmUgaXMgbm90IGFscmVhZHkgb25lICggc3luYyBlcnJvciBmaXJzdCApXG5cbiAgICAgIGlmICghdGhpcy5nZXRFcnJvcihuYW1lKSkge1xuICAgICAgICB0aGlzLnNldEVycm9yKG5hbWUsIGVycm9yKTtcbiAgICAgIH0gLy8gSWYgd2UgYXJlIG5vdCBzdGlsbCB2YWxpZGF0aW5nLCBhbmQgd2Ugd2VyZSBzdWJtaXR0aW5nLCB0aGVuIHN1Ym1pdCBmb3JtXG4gICAgICAvLyBJZiB3ZSBhcmUgYXN5bmMgdmFsaWRhdGluZyB0aGVuIGRvbnQgc3VibWl0IHlldFxuXG5cbiAgICAgIGlmICh0aGlzLnN0YXRlLnZhbGlkYXRpbmcgPiAwKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnY2hhbmdlJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gSWYgd2Ugd2VyZSBzdWJtaXR0aW5nXG5cblxuICAgICAgaWYgKHRoaXMuc3RhdGUuc3VibWl0dGluZykge1xuICAgICAgICAvLyBDaGVjayB2YWxpZGl0eSBhbmQgcGVyZm9ybSBzdWJtaXNzaW9uIGlmIHZhbGlkXG4gICAgICAgIGlmICh0aGlzLnZhbGlkKCkpIHtcbiAgICAgICAgICBkZWJ1ZyQyKCdTdWJtaXQnLCB0aGlzLnN0YXRlKTtcbiAgICAgICAgICB0aGlzLmVtaXQoJ3N1Ym1pdCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlYnVnJDIoJ1N1Ym1pdCcsIHRoaXMuc3RhdGUpO1xuICAgICAgICAgIHRoaXMuZW1pdCgnZmFpbHVyZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdGF0ZS5zdWJtaXR0aW5nID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZW1pdCgnY2hhbmdlJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFN0ZXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U3RlcCh2YWx1ZSkge1xuICAgICAgdGhpcy5zdGF0ZS5zdGVwID0gdmFsdWU7XG4gICAgICB0aGlzLmVtaXQoJ2NoYW5nZScpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRDdXJyZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEN1cnJlbnQoY29tcG9uZW50KSB7XG4gICAgICB0aGlzLnN0YXRlLkN1cnJlbnQgPSBjb21wb25lbnQ7XG4gICAgICB0aGlzLmVtaXQoJ2NoYW5nZScpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJiYWNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJhY2socHJldkNvbXBvbmVudCkge1xuICAgICAgdGhpcy5zdGF0ZS5zdGVwID0gdGhpcy5zdGF0ZS5zdGVwIC0gMTtcbiAgICAgIHRoaXMuc3RhdGUuQ3VycmVudCA9IHByZXZDb21wb25lbnQ7XG4gICAgICB0aGlzLmVtaXQoJ2NoYW5nZScpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJuZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5leHQobmV4dENvbXBvbmVudCkge1xuICAgICAgLy8gVmFsaWRhdGUgdGhlIGVudGlyZSBmb3JtXG4gICAgICB0aGlzLnZhbGlkYXRlKCk7IC8vIElmIGZpZWxkcyBvbiB0aGUgc2NyZWVuICggY3VycmVudGx5IHJlbmRlcmVkICkgYXJlIHZhbGlkIG1vdmUgb25cblxuICAgICAgaWYgKHRoaXMuc2NyZWVuVmFsaWQoKSkge1xuICAgICAgICB0aGlzLnN0YXRlLnN0ZXAgPSB0aGlzLnN0YXRlLnN0ZXAgKyAxO1xuICAgICAgICB0aGlzLnN0YXRlLkN1cnJlbnQgPSBuZXh0Q29tcG9uZW50O1xuICAgICAgfSAvLyBTdGF0ZSB3aWxsIGhhdmUgY2hhbmdlZFxuXG5cbiAgICAgIHRoaXMuZW1pdCgnY2hhbmdlJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldEluaXRpYWxWYWx1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRJbml0aWFsVmFsdWUoZmllbGQsIHZhbHVlKSB7XG4gICAgICBPYmplY3RNYXAuc2V0KHRoaXMub3B0aW9ucy5pbml0aWFsVmFsdWVzLCBmaWVsZCwgdmFsdWUpO1xuICAgIH1cbiAgICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEdldHRlcnMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgdGhlIGV4dGVybmFsIGZvcm0gc3RhdGUgdGhhdCB3aWxsIGJlIGV4cG9zZWQgdG8gdGhlIHVzZXJzXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBGb3JtIFN0YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRGb3JtU3RhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Rm9ybVN0YXRlKCkge1xuICAgICAgZGVidWckMignUmV0dXJuaW5nIGZvcm0gc3RhdGUnKTtcbiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgdGhpcy5zdGF0ZSksIHt9LCB7XG4gICAgICAgIHByaXN0aW5lOiB0aGlzLnByaXN0aW5lKCksXG4gICAgICAgIGRpcnR5OiB0aGlzLmRpcnR5KCksXG4gICAgICAgIGludmFsaWQ6IHRoaXMuaW52YWxpZCgpXG4gICAgICB9KTtcbiAgICB9IC8vIHJlYnVpbGRTdGF0ZSgpIHtcbiAgICAvLyAgIGRlYnVnKCdHZW5lcmF0aW5nIGZvcm0gc3RhdGUnKTtcbiAgICAvLyAgIC8vIFJlYnVpbGQgdmFsdWVzLCBlcnJvcnMsIGFuZCB0b3VjaGVkXG4gICAgLy8gICBjb25zdCB2YWx1ZXMgPSB7fTtcbiAgICAvLyAgIGNvbnN0IGVycm9ycyA9IHt9O1xuICAgIC8vICAgY29uc3QgdG91Y2hlZCA9IHt9O1xuICAgIC8vICAgdGhpcy5maWVsZHNCeUlkLmZvckVhY2goZmllbGQgPT4ge1xuICAgIC8vICAgICBpZiAoIWZpZWxkLnNoYWRvdykge1xuICAgIC8vICAgICAgIC8vIEdldCB0aGUgdmFsdWVzIGZyb20gdGhlIGZpZWxkXG4gICAgLy8gICAgICAgY29uc3QgdmFsdWUgPSBmaWVsZC5maWVsZEFwaS5nZXRWYWx1ZSgpO1xuICAgIC8vICAgICAgIGNvbnN0IGVycm9yID0gZmllbGQuZmllbGRBcGkuZ2V0RXJyb3IoKTtcbiAgICAvLyAgICAgICBjb25zdCB0ID0gZmllbGQuZmllbGRBcGkuZ2V0VG91Y2hlZCgpO1xuICAgIC8vICAgICAgIC8vIFNldCB0aGUgdmFsdWVcbiAgICAvLyAgICAgICBPYmplY3RNYXAuc2V0KHZhbHVlcywgZmllbGQuZmllbGQsIHZhbHVlKTtcbiAgICAvLyAgICAgICBPYmplY3RNYXAuc2V0KGVycm9ycywgZmllbGQuZmllbGQsIGVycm9yKTtcbiAgICAvLyAgICAgICBPYmplY3RNYXAuc2V0KHRvdWNoZWQsIGZpZWxkLmZpZWxkLCB0KTtcbiAgICAvLyAgICAgICAvLyBjb25zb2xlLmxvZygnU0VUVElORycsIGZpZWxkLmZpZWxkKTtcbiAgICAvLyAgICAgfVxuICAgIC8vICAgfSk7XG4gICAgLy8gICB0aGlzLnN0YXRlID0ge1xuICAgIC8vICAgICAuLi50aGlzLnN0YXRlLFxuICAgIC8vICAgICB2YWx1ZXMsXG4gICAgLy8gICAgIGVycm9ycyxcbiAgICAvLyAgICAgdG91Y2hlZCxcbiAgICAvLyAgICAgcHJpc3RpbmU6IHRoaXMucHJpc3RpbmUoKSxcbiAgICAvLyAgICAgZGlydHk6IHRoaXMuZGlydHkoKSxcbiAgICAvLyAgICAgaW52YWxpZDogdGhpcy5pbnZhbGlkKClcbiAgICAvLyAgIH07XG4gICAgLy8gfVxuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Rm9ybUFwaVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRGb3JtQXBpKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZm9ybUFwaTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RGVycml2ZWRWYWx1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREZXJyaXZlZFZhbHVlKG5hbWUpIHtcbiAgICAgIHZhciB2YWx1ZXMgPSB0aGlzLmdldFZhbHVlcygpO1xuICAgICAgcmV0dXJuIE9iamVjdE1hcC5nZXQodmFsdWVzLCBuYW1lKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VmFsdWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VmFsdWUobmFtZSkge1xuICAgICAgdmFyIHZhbHVlID0gdGhpcy5nZXRGaWVsZChuYW1lKS5maWVsZEFwaS5nZXRWYWx1ZSgpO1xuICAgICAgZGVidWckMignR2V0dGluZyB2YWx1ZSBmb3InLCBuYW1lLCB2YWx1ZSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFRvdWNoZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VG91Y2hlZChmaWVsZCkge1xuICAgICAgdmFyIHRvdWNoZWQgPSB0aGlzLmdldEZpZWxkKGZpZWxkKS5maWVsZEFwaS5nZXRUb3VjaGVkKCk7XG4gICAgICBkZWJ1ZyQyKCdHZXR0aW5nIHRvdWNoZWQgZm9yJywgZmllbGQsIHRvdWNoZWQpO1xuICAgICAgcmV0dXJuIHRvdWNoZWQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEVycm9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEVycm9yKGZpZWxkKSB7XG4gICAgICB2YXIgZXJyb3IgPSB0aGlzLmdldEZpZWxkKGZpZWxkKS5maWVsZEFwaS5nZXRFcnJvcigpO1xuICAgICAgZGVidWckMignR2V0dGluZyBlcnJvciBmb3InLCBmaWVsZCwgZXJyb3IpO1xuICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRWYWx1ZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VmFsdWVzKCkge1xuICAgICAgZGVidWckMignR2V0dGluZ3MgdmFsdWVzJyk7XG4gICAgICByZXR1cm4gdGhpcy5zdGF0ZS52YWx1ZXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEFsbFRvdWNoZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QWxsVG91Y2hlZCgpIHtcbiAgICAgIGRlYnVnJDIoJ0dldHRpbmdzIHRvdWNoZWQnKTtcbiAgICAgIHJldHVybiB0aGlzLnN0YXRlLnRvdWNoZWQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEVycm9yc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRFcnJvcnMoKSB7XG4gICAgICBkZWJ1ZyQyKCdHZXR0aW5ncyBlcnJvcnMnKTtcbiAgICAgIHJldHVybiB0aGlzLnN0YXRlLmVycm9ycztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRPcHRpb25zKCkge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U3RlcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTdGVwKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuc3RlcDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U2F2ZWRWYWx1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTYXZlZFZhbHVlKG5hbWUpIHtcbiAgICAgIHZhciBmaWVsZCA9IHRoaXMuZmllbGRzQnlOYW1lLmdldChuYW1lKTtcblxuICAgICAgaWYgKGZpZWxkICYmIGZpZWxkLnNoYWRvdykge1xuICAgICAgICByZXR1cm4gT2JqZWN0TWFwLmdldCh0aGlzLnNhdmVkVmFsdWVzLCBcInNoYWRvdy1cIi5jb25jYXQobmFtZSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gT2JqZWN0TWFwLmdldCh0aGlzLnNhdmVkVmFsdWVzLCBuYW1lKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlU2F2ZWRTdGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVTYXZlZFN0YXRlKG5hbWUpIHtcbiAgICAgIHZhciBmaWVsZCA9IHRoaXMuZmllbGRzQnlOYW1lLmdldChuYW1lKTtcblxuICAgICAgaWYgKGZpZWxkICYmIGZpZWxkLnNoYWRvdykge1xuICAgICAgICByZXR1cm4gT2JqZWN0TWFwW1wiZGVsZXRlXCJdKHRoaXMuc2F2ZWRWYWx1ZXMsIFwic2hhZG93LVwiLmNvbmNhdChuYW1lKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBPYmplY3RNYXBbXCJkZWxldGVcIl0odGhpcy5zYXZlZFZhbHVlcywgbmFtZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEZ1bGxGaWVsZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRGdWxsRmllbGQoZmllbGQpIHtcbiAgICAgIHJldHVybiBmaWVsZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0SW5pdGlhbFZhbHVlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEluaXRpYWxWYWx1ZShmaWVsZCkge1xuICAgICAgcmV0dXJuIE9iamVjdE1hcC5nZXQodGhpcy5vcHRpb25zLmluaXRpYWxWYWx1ZXMsIGZpZWxkKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RmllbGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RmllbGQobmFtZSkge1xuICAgICAgZGVidWckMignR2V0dGluZyBGaWVsZCcsIG5hbWUpO1xuICAgICAgdmFyIGZpZWxkID0gdGhpcy5maWVsZHNCeU5hbWUuZ2V0KG5hbWUpO1xuXG4gICAgICBpZiAoIWZpZWxkKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgIGNvbnNvbGUud2FybihcIkF0dGVtcHRpbmcgdG8gZ2V0IGZpZWxkIFwiLmNvbmNhdChuYW1lLCBcIiBidXQgaXQgZG9lcyBub3QgZXhpc3RcIikpOyAvLyBQcmV2ZW50IGFwcCBmcm9tIGNyYXNoaW5nXG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZHVtbXlGaWVsZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZpZWxkO1xuICAgIH0gLy8gTm90aWZ5IG90aGVyIGZpZWxkc1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibm90aWZ5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5vdGlmeShmaWVsZCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIC8vIEV4YW1wbGUgZmllbGQgLSBzaWJsaW5nc1swXS5tYXJyaWVkXG4gICAgICAvLyBHZXQgdGhlIG5vdGlmaWVyXG4gICAgICB2YXIgbm90aWZpZXIgPSB0aGlzLmdldEZpZWxkKGZpZWxkKTsgLy8gSWYgd2UgaGF2ZSBhIGxpc3Qgd2UgbXVzdCBub3RpZnkgZWFjaCBvbmVcblxuICAgICAgaWYgKG5vdGlmaWVyICYmIG5vdGlmaWVyLm5vdGlmeSkge1xuICAgICAgICAvLyBFeGFtcGxlOiBbJ3Nwb3VzZSddXG4gICAgICAgIG5vdGlmaWVyLm5vdGlmeS5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZE5hbWUpIHtcbiAgICAgICAgICAvLyBHZXQgdGhlIGZpZWxkIHRvTm90aWZ5XG4gICAgICAgICAgdmFyIEpTUEFOID0gXCIuXCIuY29uY2F0KGZpZWxkKTtcbiAgICAgICAgICB2YXIgcGF0aCA9IFwiXCIuY29uY2F0KEpTUEFOLnJlcGxhY2UoLyguKilbLltdLiovLCAnJDEnKSwgXCIuXCIpLmNvbmNhdChmaWVsZE5hbWUpLnNsaWNlKDEpOyAvLyBjb25zb2xlLmxvZygnUEFUSCcsIHBhdGgpO1xuICAgICAgICAgIC8vIEV4YW1wbGUgcGF0aCAtIHNpYmxpbmdzWzBdLnNwb3VzZVxuXG4gICAgICAgICAgdmFyIHRvTm90aWZ5ID0gX3RoaXMyLmdldEZpZWxkKHBhdGgpO1xuXG4gICAgICAgICAgaWYgKHRvTm90aWZ5KSB7XG4gICAgICAgICAgICBkZWJ1ZyQyKCdOb3RpZnlpbmcnLCB0b05vdGlmeS5maWVsZCk7XG4gICAgICAgICAgICB0b05vdGlmeS5maWVsZEFwaS52YWxpZGF0ZSgpO1xuICAgICAgICAgICAgdG9Ob3RpZnkuZmllbGRBcGkuY2hlY2tSZWxldmFudCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZhbGlkYXRlRmllbGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsaWRhdGVGaWVsZChmaWVsZCkge1xuICAgICAgdGhpcy5nZXRGaWVsZChmaWVsZCkuZmllbGRBcGkudmFsaWRhdGUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVzZXRGaWVsZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNldEZpZWxkKGZpZWxkKSB7XG4gICAgICB0aGlzLmdldEZpZWxkKGZpZWxkKS5maWVsZEFwaS5yZXNldCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaWVsZEV4aXN0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaWVsZEV4aXN0cyhmaWVsZCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmllbGRzQnlOYW1lLmdldChmaWVsZCkgIT0gbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidmFsaWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsaWQoKSB7XG4gICAgICB2YXIgZXJyb3JzID0gdGhpcy5nZXRFcnJvcnMoKTtcbiAgICAgIHJldHVybiAhIShPYmplY3RNYXAuZW1wdHkoZXJyb3JzKSAmJiAhdGhpcy5zdGF0ZS5lcnJvcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNjcmVlblZhbGlkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNjcmVlblZhbGlkKCkge1xuICAgICAgLy8gUmV0dXJuIGZhbHNlIGlmIGFueSBvZiB0aGUgZmllbGRzIG9uIHRoZSBzY3JlZW4gYXJlIGludmFsaWRcbiAgICAgIHZhciBlcnJvciA9IE9iamVjdC5lbnRyaWVzKHRoaXMub25TY3JlZW4pLnNvbWUoZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgdmFyIF9yZWYyID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMiksXG4gICAgICAgICAgICBmaWVsZCA9IF9yZWYyWzFdO1xuXG4gICAgICAgIHJldHVybiBmaWVsZC5maWVsZEFwaS5nZXRFcnJvcigpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gIWVycm9yO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnZhbGlkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGludmFsaWQoKSB7XG4gICAgICB2YXIgZXJyb3JzID0gdGhpcy5nZXRFcnJvcnMoKTtcbiAgICAgIHJldHVybiAhISghT2JqZWN0TWFwLmVtcHR5KGVycm9ycykgfHwgdGhpcy5zdGF0ZS5lcnJvcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInByaXN0aW5lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByaXN0aW5lKCkge1xuICAgICAgdmFyIHRvdWNoZWQgPSB0aGlzLmdldEFsbFRvdWNoZWQoKTtcbiAgICAgIHZhciB2YWx1ZXMgPSB0aGlzLmdldFZhbHVlcygpO1xuICAgICAgcmV0dXJuIE9iamVjdE1hcC5lbXB0eSh0b3VjaGVkKSAmJiBPYmplY3RNYXAuZW1wdHkodmFsdWVzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGlydHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlydHkoKSB7XG4gICAgICByZXR1cm4gIXRoaXMucHJpc3RpbmUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICBkZWJ1ZyQyKCdSZXNldHRpbmcnKTsgLy8gU28gYmVjYXVzZSBhbGwgZmllbGRzIGNvbnRyb2xsIHRoZW1zZWx2ZXMgYW5kLCBcImluZm9ybVwiLCB0aGlzIGNvbnRyb2xsZXJcbiAgICAgIC8vIG9mIHRoZWlyIGNoYW5nZXMsIHdlIG5lZWQgdG8gbGl0ZXJhbGx5IGl0dGVyYXRlIHRocm91Z2ggYWxsIHJlZ2lzdGVyZWQgZmllbGRzXG4gICAgICAvLyBhbmQgcmVzZXQgdGhlbS4gTm90IGEgYmlnIGRlYWwgYnV0IHZlcnkgaW1wb3J0YW50IHRvIHJlbWVtYmVyIHRoYXQgeW91IGNhbnQgc2ltcGx5XG4gICAgICAvLyByZXNldCB0aGlzIGNvbnRyb2xsZXJzIHN0YXRlIVxuXG4gICAgICB0aGlzLmZpZWxkc0J5SWQuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgICAgZmllbGQuZmllbGRBcGkucmVzZXQoe1xuICAgICAgICAgIHByZXZlbnRVcGRhdGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZW1pdCgncmVzZXQnKTtcbiAgICAgIHRoaXMuZW1pdCgnY2hhbmdlJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFZhbHVlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRWYWx1ZXModmFsdWVzKSB7XG4gICAgICBkZWJ1ZyQyKCdTZXR0aW5nIHZhbHVlcycpOyAvLyBTbyB3ZSBiZWNhdXNlIGFsbCBmaWVsZHMgY29udHJvbGwgdGhlbXNlbHZlcyBhbmQsIFwiaW5mb3JtXCIsIHRoaXMgY29udHJvbGxlclxuICAgICAgLy8gb2YgdGhlaXIgY2hhbmdlcywgd2UgbmVlZCB0byBsaXRlcmFsbHkgaXR0ZXJhdGUgdGhyb3VnaCBhbGwgcmVnaXN0ZXJlZCBmaWVsZHNcbiAgICAgIC8vIGFuZCBzZXQgdGhlbS4gTm90IGEgYmlnIGRlYWwgYnV0IHZlcnkgaW1wb3J0YW50IHRvIHJlbWVtYmVyIHRoYXQgeW91IGNhbnQgc2ltcGx5XG4gICAgICAvLyBzZXQgdGhpcyBjb250cm9sbGVycyBzdGF0ZSFcblxuICAgICAgdGhpcy5maWVsZHNCeUlkLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgIC8vIEluaXRpYWxpemUgdGhlIHZhbHVlcyBpZiBpdCBuZWVkcyB0byBiZVxuICAgICAgICB2YXIgdmFsdWUgPSBPYmplY3RNYXAuZ2V0KHZhbHVlcywgZmllbGQuZmllbGQpO1xuXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZmllbGQuZmllbGRBcGkuc2V0VmFsdWUodmFsdWUsIG51bGwsIHtcbiAgICAgICAgICAgIHByZXZlbnRVcGRhdGU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLmVtaXQoJ2NoYW5nZScpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ2YWxpZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWxpZGF0ZSgpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICBkZWJ1ZyQyKCdWYWxpZGF0aW5nIGFsbCBmaWVsZHMnKTtcbiAgICAgIHZhciB2YWx1ZXMgPSB0aGlzLmdldFZhbHVlcygpOyAvLyBWYWxpZGF0ZSBzY2hlbWEgaWYgbmVlZGVkXG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudmFsaWRhdGlvblNjaGVtYSkge1xuICAgICAgICB2YXIgZXJyb3JzID0gdmFsaWRhdGVZdXBTY2hlbWEodGhpcy5vcHRpb25zLnZhbGlkYXRpb25TY2hlbWEsIHZhbHVlcyk7IC8vIFNvIHdlIGJlY2F1c2UgYWxsIGZpZWxkcyBjb250cm9sbCB0aGVtc2VsdmVzIGFuZCwgXCJpbmZvcm1cIiwgdGhpcyBjb250cm9sbGVyXG4gICAgICAgIC8vIG9mIHRoZWlyIGNoYW5nZXMsIHdlIG5lZWQgdG8gbGl0ZXJhbGx5IGl0dGVyYXRlIHRocm91Z2ggYWxsIHJlZ2lzdGVyZWQgZmllbGRzXG4gICAgICAgIC8vIGFuZCBzZXQgdGhlbS4gTm90IGEgYmlnIGRlYWwgYnV0IHZlcnkgaW1wb3J0YW50IHRvIHJlbWVtYmVyIHRoYXQgeW91IGNhbnQgc2ltcGx5XG4gICAgICAgIC8vIHNldCB0aGlzIGNvbnRyb2xsZXJzIHN0YXRlIVxuXG4gICAgICAgIHRoaXMuZmllbGRzQnlJZC5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiB0aGVyZSBpcyBhbiBlcnJvciB0byBzZXRcbiAgICAgICAgICAvLyBOb3RlOiB3ZSB1c2UgaGFzIGJlY3VhdXNlIHZhbHVlIG1heSBiZSB0aGVyZSBidXQgdW5kZWZpbmVkXG4gICAgICAgICAgaWYgKE9iamVjdE1hcC5oYXMoZXJyb3JzLCBmaWVsZC5maWVsZCkpIHtcbiAgICAgICAgICAgIHZhciBlcnJvciA9IE9iamVjdE1hcC5nZXQoZXJyb3JzLCBmaWVsZC5maWVsZCk7IC8vIElmIHRoZXJlIGlzIGFuIGVycm9yIHRoZW4gc2V0IGl0XG5cbiAgICAgICAgICAgIF90aGlzMy5zZXRFcnJvcihmaWVsZC5maWVsZCwgZXJyb3IpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBhcmUgZG9pbmcgc2NoZW1hIHZhbGlkYXRpb24gdGhlbiB3ZSBuZWVkIHRvIGNsZWFyIG91dCBhbnkgb2xkIGVycm9yc1xuICAgICAgICAgICAgX3RoaXMzLnNldEVycm9yKGZpZWxkLmZpZWxkLCB1bmRlZmluZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IC8vIFZhbGlkYXRlIEFKViBzY2hlbWEgaWYgbmVlZGVkXG5cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zY2hlbWEgJiYgdGhpcy5vcHRpb25zLmFqdikge1xuICAgICAgICB2YXIgX2Vycm9ycyA9IHZhbGlkYXRlQWp2U2NoZW1hKHRoaXMuYWp2VmFsaWRhdGUsIHZhbHVlcyk7IC8vIFNvIHdlIGJlY2F1c2UgYWxsIGZpZWxkcyBjb250cm9sbCB0aGVtc2VsdmVzIGFuZCwgXCJpbmZvcm1cIiwgdGhpcyBjb250cm9sbGVyXG4gICAgICAgIC8vIG9mIHRoZWlyIGNoYW5nZXMsIHdlIG5lZWQgdG8gbGl0ZXJhbGx5IGl0dGVyYXRlIHRocm91Z2ggYWxsIHJlZ2lzdGVyZWQgZmllbGRzXG4gICAgICAgIC8vIGFuZCBzZXQgdGhlbS4gTm90IGEgYmlnIGRlYWwgYnV0IHZlcnkgaW1wb3J0YW50IHRvIHJlbWVtYmVyIHRoYXQgeW91IGNhbnQgc2ltcGx5XG4gICAgICAgIC8vIHNldCB0aGlzIGNvbnRyb2xsZXJzIHN0YXRlIVxuXG5cbiAgICAgICAgdGhpcy5maWVsZHNCeUlkLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIHRoZXJlIGlzIGFuIGVycm9yIHRvIHNldFxuICAgICAgICAgIC8vIE5vdGU6IHdlIHVzZSBoYXMgYmVjdWF1c2UgdmFsdWUgbWF5IGJlIHRoZXJlIGJ1dCB1bmRlZmluZWRcbiAgICAgICAgICBpZiAoT2JqZWN0TWFwLmhhcyhfZXJyb3JzLCBmaWVsZC5maWVsZCkpIHtcbiAgICAgICAgICAgIHZhciBlcnJvciA9IE9iamVjdE1hcC5nZXQoX2Vycm9ycywgZmllbGQuZmllbGQpOyAvLyBJZiB0aGVyZSBpcyBhbiBlcnJvciB0aGVuIHNldCBpdFxuXG4gICAgICAgICAgICBfdGhpczMuc2V0RXJyb3IoZmllbGQuZmllbGQsIGVycm9yKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgd2UgYXJlIGRvaW5nIHNjaGVtYSB2YWxpZGF0aW9uIHRoZW4gd2UgbmVlZCB0byBjbGVhciBvdXQgYW55IG9sZCBlcnJvcnNcbiAgICAgICAgICAgIF90aGlzMy5zZXRFcnJvcihmaWVsZC5maWVsZCwgdW5kZWZpbmVkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSAvLyBJdHRlcmF0ZSB0aHJvdWdoIGFuZCBjYWxsIHZhbGlkYXRlIG9uIGV2ZXJ5IGZpZWxkXG5cblxuICAgICAgdGhpcy5maWVsZHNCeUlkLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgIGZpZWxkLmZpZWxkQXBpLnZhbGlkYXRlKHZhbHVlcyk7IC8vIFNlY29uZCBwYXJhbSB0byBwcmV2ZW50IHZhbGlkYXRpb25cblxuICAgICAgICBmaWVsZC5maWVsZEFwaS5zZXRUb3VjaGVkKHRydWUsIHRydWUpO1xuICAgICAgfSk7IC8vIENhbGwgdGhlIGZvcm0gbGV2ZWwgdmFsaWRhdGlvbiBpZiBpdHMgcHJlc2VudFxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnZhbGlkYXRlKSB7XG4gICAgICAgIHZhciByZXMgPSB0aGlzLm9wdGlvbnMudmFsaWRhdGUodmFsdWVzKTtcbiAgICAgICAgdGhpcy5zZXRGb3JtRXJyb3IocmVzKTtcbiAgICAgIH0gLy8gQ2FsbCB0aGUgZm9ybXMgZmllbGQgbGV2ZWwgdmFsaWRhdGlvblxuXG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudmFsaWRhdGVGaWVsZHMpIHtcbiAgICAgICAgdmFyIF9lcnJvcnMyID0gdGhpcy5vcHRpb25zLnZhbGlkYXRlRmllbGRzKHZhbHVlcyk7IC8vIFNvIHdlIGJlY2F1c2UgYWxsIGZpZWxkcyBjb250cm9sbCB0aGVtc2VsdmVzIGFuZCwgXCJpbmZvcm1cIiwgdGhpcyBjb250cm9sbGVyXG4gICAgICAgIC8vIG9mIHRoZWlyIGNoYW5nZXMsIHdlIG5lZWQgdG8gbGl0ZXJhbGx5IGl0dGVyYXRlIHRocm91Z2ggYWxsIHJlZ2lzdGVyZWQgZmllbGRzXG4gICAgICAgIC8vIGFuZCBzZXQgdGhlbS4gTm90IGEgYmlnIGRlYWwgYnV0IHZlcnkgaW1wb3J0YW50IHRvIHJlbWVtYmVyIHRoYXQgeW91IGNhbnQgc2ltcGx5XG4gICAgICAgIC8vIHNldCB0aGlzIGNvbnRyb2xsZXJzIHN0YXRlIVxuXG5cbiAgICAgICAgdGhpcy5maWVsZHNCeUlkLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIHRoZXJlIGlzIGFuIGVycm9yIHRvIHNldFxuICAgICAgICAgIC8vIE5vdGU6IHdlIHVzZSBoYXMgYmVjdWF1c2UgdmFsdWUgbWF5IGJlIHRoZXJlIGJ1dCB1bmRlZmluZWRcbiAgICAgICAgICBpZiAoT2JqZWN0TWFwLmhhcyhfZXJyb3JzMiwgZmllbGQuZmllbGQpKSB7XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSBPYmplY3RNYXAuZ2V0KF9lcnJvcnMyLCBmaWVsZC5maWVsZCk7IC8vIElmIHRoZXJlIGlzIGFuIGVycm9yIHRoZW4gc2V0IGl0XG5cbiAgICAgICAgICAgIF90aGlzMy5zZXRFcnJvcihmaWVsZC5maWVsZCwgZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFzeW5jVmFsaWRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXN5bmNWYWxpZGF0ZSgpIHtcbiAgICAgIGRlYnVnJDIoJ0FzeW5jIFZhbGlkYXRpbmcgYWxsIGZpZWxkcycpO1xuICAgICAgdmFyIHZhbHVlcyA9IHRoaXMuZ2V0VmFsdWVzKCk7IC8vIEl0dGVyYXRlIHRocm91Z2ggYW5kIGNhbGwgdmFsaWRhdGUgb24gZXZlcnkgZmllbGRcblxuICAgICAgdGhpcy5maWVsZHNCeUlkLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgIGZpZWxkLmZpZWxkQXBpLmFzeW5jVmFsaWRhdGUodmFsdWVzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJrZXlEb3duXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGtleURvd24oZSkge1xuICAgICAgLy8gSWYgcHJldmVudEVudGVyIHRoZW4gcmV0dXJuXG4gICAgICBpZiAoZS5rZXlDb2RlID09IDEzICYmIHRoaXMub3B0aW9ucy5wcmV2ZW50RW50ZXIpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdChlKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdWJtaXRGb3JtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN1Ym1pdEZvcm0oZSkge1xuICAgICAgLy8gSW5jcmltZW50IG51bWJlciBvZiBzdWJtaXQgYXR0ZW1wdHNcbiAgICAgIHRoaXMuc3RhdGUuc3VibWl0cyA9IHRoaXMuc3RhdGUuc3VibWl0cyArIDE7XG4gICAgICB0aGlzLnN0YXRlLnN1Ym1pdHRpbmcgPSB0cnVlO1xuXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5kb250UHJldmVudERlZmF1bHQgJiYgZSkge1xuICAgICAgICAvLyBQcmV2ZW50IGRlZmF1bHQgYnJvd3NlciBmb3JtIHN1Ym1pc3Npb25cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdChlKTtcbiAgICAgIH0gLy8gVmFsaWRhdGUgdGhlIGZvcm1cblxuXG4gICAgICB0aGlzLnZhbGlkYXRlKCk7IC8vIEVtaXQgYSBjaGFuZ2VcblxuICAgICAgdGhpcy5lbWl0KCdjaGFuZ2UnKTsgLy8gVHJpZ2dlciBhbGwgYXN5bmMgdmFsaWRhdGlvbnNcblxuICAgICAgdGhpcy5hc3luY1ZhbGlkYXRlKCk7IC8vIElmIHdlIGFyZSBhc3luYyB2YWxpZGF0aW5nIHRoZW4gZG9udCBzdWJtaXQgeWV0XG5cbiAgICAgIGlmICh0aGlzLnN0YXRlLnZhbGlkYXRpbmcgPiAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gQ2hlY2sgdmFsaWRpdHkgYW5kIHBlcmZvcm0gc3VibWlzc2lvbiBpZiB2YWxpZFxuXG5cbiAgICAgIGlmICh0aGlzLnZhbGlkKCkpIHtcbiAgICAgICAgZGVidWckMignU3VibWl0JywgdGhpcy5zdGF0ZSk7XG4gICAgICAgIHRoaXMuZW1pdCgnc3VibWl0Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWJ1ZyQyKCdTdWJtaXQnLCB0aGlzLnN0YXRlKTtcbiAgICAgICAgdGhpcy5lbWl0KCdmYWlsdXJlJyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3RhdGUuc3VibWl0dGluZyA9IGZhbHNlO1xuICAgICAgdGhpcy5lbWl0KCdjaGFuZ2UnKTtcbiAgICB9XG4gICAgLyogLS0tLS0tLS0tLS0tLS0tLSBVcGRhdGVyIEZ1bmN0aW9ucyAodXNlZCBieSBmaWVsZHMpIC0tLS0tLS0tLS0tLS0tLS0gKi9cbiAgICAvLyBBRERFRCBpbml0aWFsUmVuZGVyIHBhcmFtZXRlciBiZWNhdXNlIG9mIHJlYWN0IDE2LjEzLjAgd2FybmluZyB0aGF0IGRvZXMgbm90IGxpa2VcbiAgICAvLyBzZXR0aW5nIGluaXRpYWwgdmFsdWUgZHVyaW5nIGZpcnN0IHJlbmRlclxuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVnaXN0ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVnaXN0ZXIoaWQsIGZpZWxkLCBpbml0aWFsUmVuZGVyKSB7XG4gICAgICB2YXIgbmFtZSA9IGZpZWxkLmZpZWxkLFxuICAgICAgICAgIHN0YXRlID0gZmllbGQuc3RhdGU7XG4gICAgICBkZWJ1ZyQyKCdSZWdpc3RlciBJRDonLCBpZCwgJ05hbWU6JywgbmFtZSwgc3RhdGUsICdJbml0aWFsJywgaW5pdGlhbFJlbmRlcik7IC8vIEV4YW1wbGUgZm9vLmJhci5iYXpbM10uYmF6ID4+Pj4gZm9vLmJhci5iYXpbM11cblxuICAgICAgdmFyIG1hZ2ljVmFsdWUgPSBuYW1lLnNsaWNlKDAsIG5hbWUubGFzdEluZGV4T2YoJ1snKSAhPSAtMSA/IG5hbWUubGFzdEluZGV4T2YoJ10nKSArIDEgOiBuYW1lLmxlbmd0aCk7IC8vIEZpZWxkIG1pZ2h0IGJlIGNvbWluZyBiYWNrIGFmdGVyIHJlbmRlciByZW1vdmUgb2xkIGZpZWxkXG5cbiAgICAgIHZhciBhbHJlYWR5UmVnaXN0ZXJlZDtcbiAgICAgIHRoaXMuZmllbGRzQnlJZC5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS5maWVsZCA9PT0gbmFtZSkge1xuICAgICAgICAgIGFscmVhZHlSZWdpc3RlcmVkID0ga2V5O1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKCAvLyF0aGlzLmV4cGVjdGVkUmVtb3ZhbHNbbWFnaWNWYWx1ZV0gJiZcbiAgICAgIGFscmVhZHlSZWdpc3RlcmVkICYmIChmaWVsZC5rZWVwU3RhdGUgfHwgZmllbGQuaW5NdWx0aXN0ZXApKSB7XG4gICAgICAgIGRlYnVnJDIoJ0FscmVhZHkgUmVnaXN0ZXJlZCcsIG5hbWUpO1xuICAgICAgICB0aGlzLmZpZWxkc0J5SWRbXCJkZWxldGVcIl0oYWxyZWFkeVJlZ2lzdGVyZWQpO1xuICAgICAgfSBlbHNlIGlmICggLy8hdGhpcy5leHBlY3RlZFJlbW92YWxzW21hZ2ljVmFsdWVdICYmXG4gICAgICBhbHJlYWR5UmVnaXN0ZXJlZCAmJiAoIWZpZWxkLmtlZXBTdGF0ZSB8fCAhZmllbGQuaW5NdWx0aXN0ZXApKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgIGNvbnNvbGUud2FybignQ2hlY2sgdG8gbWFrZSBzdXJlIHlvdSBoYXZlIG5vdCByZWdpc3RlcmVkIHR3byBmaWVsZHMgd2l0aCB0aGUgZmllbGROYW1lJywgbmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGRlYnVnJDIoJ0ZpZWxkcyBSZWdpc3RlcmVkJywgdGhpcy5maWVsZHNCeUlkLnNpemUpOyAvLyBUaGUgZmllbGQgaXMgb24gdGhlIHNjcmVlblxuXG4gICAgICB0aGlzLm9uU2NyZWVuW2lkXSA9IGZpZWxkOyAvLyBBbHdheXMgcmVnaXN0ZXIgdGhlIGZpZWxkXG5cbiAgICAgIHRoaXMuZmllbGRzQnlJZC5zZXQoaWQsIGZpZWxkKTsgLy8gQWx3YXlzIGNsZWFyIG91dCBleHBlY3RlZCByZW1vdmFscyB3aGVuIGEgcmVyZWdpc3RlcmluZyBhcnJheSBmaWVsZCBjb21lcyBpblxuXG4gICAgICBkZWJ1ZyQyKCdjbGVhcmluZyBleHBlY3RlZCByZW1vdmFsJywgbWFnaWNWYWx1ZSk7XG4gICAgICBkZWxldGUgdGhpcy5leHBlY3RlZFJlbW92YWxzW21hZ2ljVmFsdWVdO1xuICAgICAgZGVsZXRlIHRoaXMucHVsbGVkT3V0W21hZ2ljVmFsdWVdOyAvLyBUaGUgZmllbGQgaXMgYSBzaGFkb3cgZmllbGQgb29vIHNwb29reSBzbyBkb250IHNldCBhbnl0aGluZ1xuXG4gICAgICBpZiAoZmllbGQuc2hhZG93KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gVXBkYXRlIHRoZSBmb3JtcyBzdGF0ZSByaWdodCBhd2F5XG5cblxuICAgICAgdGhpcy51cGRhdGVyLnNldFZhbHVlKGlkLCBmaWVsZC5maWVsZEFwaS5nZXRWYWx1ZSgpLCBmYWxzZSk7XG4gICAgICB0aGlzLnVwZGF0ZXIuc2V0RXJyb3IoaWQsIGZpZWxkLmZpZWxkQXBpLmdldEVycm9yKCksIGZhbHNlKTtcbiAgICAgIHRoaXMudXBkYXRlci5zZXRUb3VjaGVkKGlkLCBmaWVsZC5maWVsZEFwaS5nZXRUb3VjaGVkKCksIGZhbHNlKTsgLy8gV2UgcmVnaXN0ZXIgZmllbGQgcmlnaHQgYXdheSBidXQgZG9udCB3YW50IGl0IHRvIHRyaWdlciBhIHJlcmVuZGVyXG5cbiAgICAgIGlmICghaW5pdGlhbFJlbmRlcikge1xuICAgICAgICB0aGlzLmVtaXQoJ2NoYW5nZScpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZXJlZ2lzdGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlcmVnaXN0ZXIoaWQpIHtcbiAgICAgIHZhciBmaWVsZCA9IHRoaXMuZmllbGRzQnlJZC5nZXQoaWQpO1xuICAgICAgdmFyIG5hbWUgPSBmaWVsZC5maWVsZDtcbiAgICAgIGRlYnVnJDIoJ0RlcmVnaXN0ZXInLCBpZCwgbmFtZSk7IC8vIFRoZSBmaWVsZCBpcyBvZmYgdGhlIHNjcmVlblxuXG4gICAgICBkZWxldGUgdGhpcy5vblNjcmVlbltpZF07IC8vIEV4YW1wbGUgZm9vLmJhci5iYXpbM10gLS0+IGZvby5iYXIuYmF6WzNdLmJheiAmJiBmb28uYmFyLmJhelszXS50YXoucmF6WzRdLm5helxuXG4gICAgICB2YXIgZXhwZWN0ZWRSZW1vdmFsID0gaXNFeHBlY3RlZChuYW1lLCB0aGlzLmV4cGVjdGVkUmVtb3ZhbHMpOyAvLyBFeGFtcGxlIGZvby5iYXIuYmF6WzNdLmJheiA+Pj4+IGZvby5iYXIuYmF6WzNdXG5cbiAgICAgIHZhciBtYWdpY1ZhbHVlID0gbmFtZS5zbGljZSgwLCBuYW1lLmxhc3RJbmRleE9mKCdbJykgIT0gLTEgPyBuYW1lLmxhc3RJbmRleE9mKCddJykgKyAxIDogbmFtZS5sZW5ndGgpOyAvLyBJZiB0aGUgZmllbGRzIHN0YXRlIGlzIHRvIGJlIGtlcHQgdGhlbiBzYXZlIHRoZSB2YWx1ZVxuXG4gICAgICBpZiAoIC8vIFdlIGFyZSBpbiBhIG11bHRpc3RlcCBvciB3YW50IHRvIGtlZXAgdGhlIHN0YXRlXG4gICAgICAoZmllbGQua2VlcFN0YXRlIHx8IGZpZWxkLmluTXVsdGlzdGVwKSAmJiAvLyBXZSBhcmUgTk9UIGV4cGVjdGVkIHRvIGJlIHJlbW92ZWRcbiAgICAgICFleHBlY3RlZFJlbW92YWwpIHtcbiAgICAgICAgLy8gVE9ETyA/PyBFeGNlcHRpb24gd2hlcmUgdGhlIGZpZWxkIGlzIGlycmVsaXZhbnQgQU5EIGtlZXAgc3RhdGUgd2FzIG5vdCBwYXNzZWQgPz9cbiAgICAgICAgZGVidWckMihcIlNhdmluZyBmaWVsZCBcIi5jb25jYXQobmFtZSwgXCIncyB2YWx1ZVwiKSwgZmllbGQuZmllbGRBcGkuZ2V0RmllbGRTdGF0ZSgpKTtcblxuICAgICAgICBpZiAoIWZpZWxkLnNoYWRvdykge1xuICAgICAgICAgIE9iamVjdE1hcC5zZXQodGhpcy5zYXZlZFZhbHVlcywgbmFtZSwgZmllbGQuZmllbGRBcGkuZ2V0RmllbGRTdGF0ZSgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBXZSBhcmUgc2hhZG93IGZpZWxkIGFuZCB3aWxsIHN0b3JlIHRoaXMgdmFsdWUgaW4gdGhlIHNoYWRvd3NcbiAgICAgICAgICBPYmplY3RNYXAuc2V0KHRoaXMuc2F2ZWRWYWx1ZXMsIFwic2hhZG93LVwiLmNvbmNhdChuYW1lKSwgZmllbGQuZmllbGRBcGkuZ2V0RmllbGRTdGF0ZSgpKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBSZW1vdmUgaWYgaXRzIGFuIGV4cGVjdGVkIHJlbW92YWwgT1Igd2UgZG9udCBoYXZlIGtlZXAgc3RhdGVcblxuXG4gICAgICBpZiAoIC8vIFRoaXMgZmllbGQgd2FzIGV4cGVjdGVkIHRvIGJlIHJlbW92ZWRcbiAgICAgIGV4cGVjdGVkUmVtb3ZhbCB8fCAvLyBUaGlzIGZpZWxkIGRvZXMgbm90IGhhdmUga2VlcHN0YXRlIGFuZCBpcyBOT1Qgd2l0aGluIGEgbXVsdGlzdGVwXG4gICAgICAhZmllbGQua2VlcFN0YXRlICYmICFmaWVsZC5pbk11bHRpc3RlcCB8fCAvLyBJZiBmaWVsZCBpcyBpbiBtdWx0aXN0ZXAgdGhlbiB3ZSB3b3VsZCBhbHdheXMga2VlcCBkdWUgdG8gZmllbGQuaW5NdWx0aXN0ZXBcbiAgICAgIC8vIEJVVC4uIHdlIG5lZWQgdG8gYWxzbyBjaGVjayBpZiB0aGUgZmllbGQgaXMgaXJyZWxpdmFudFxuICAgICAgLy8gYmVjYXVzZSBpZiBpdCBnZXRzIHVubW91bnRlZCwgZXZlbiBpZiBpdHMgcGFydCBvZiBhIG11bHRpc3RlcCwgd2Ugd2FudCB0byByZW1vdmVcbiAgICAgIC8vIHRoZSBmaWVsZCBjb21wbGV0bGV5LCB1bmxlc3Mga2VlcCBzdGF0ZSB3YXMgcGFzc2VkLlxuICAgICAgIWZpZWxkLmZpZWxkQXBpLmdldElzUmVsZXZhbnQoKSAmJiAhZmllbGQua2VlcFN0YXRlKSB7XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgZmllbGQgY29tcGxldGxleVxuICAgICAgICBkZWJ1ZyQyKCdSZW1vdmluZyBmaWVsZCcsIG5hbWUpO1xuICAgICAgICB0aGlzLmZpZWxkc0J5SWRbXCJkZWxldGVcIl0oaWQpOyAvLyBDbGVhbiB1cCBzdGF0ZSBvbmx5IGlmIGl0cyBub3QgZXhwZWN0ZWQgcmVtb3ZhbCwgb3RoZXJ3aXNlIHdlIHdpbGwganVzdCBwdWxsIGl0IG91dFxuXG4gICAgICAgIGlmICghZXhwZWN0ZWRSZW1vdmFsKSB7XG4gICAgICAgICAgT2JqZWN0TWFwW1wiZGVsZXRlXCJdKHRoaXMuc3RhdGUudmFsdWVzLCBuYW1lKTtcbiAgICAgICAgICBPYmplY3RNYXBbXCJkZWxldGVcIl0odGhpcy5zdGF0ZS50b3VjaGVkLCBuYW1lKTtcbiAgICAgICAgICBPYmplY3RNYXBbXCJkZWxldGVcIl0odGhpcy5zdGF0ZS5lcnJvcnMsIG5hbWUpO1xuXG4gICAgICAgICAgaWYgKCFmaWVsZC5zaGFkb3cpIHtcbiAgICAgICAgICAgIE9iamVjdE1hcFtcImRlbGV0ZVwiXSh0aGlzLnNhdmVkVmFsdWVzLCBuYW1lKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgT2JqZWN0TWFwW1wiZGVsZXRlXCJdKHRoaXMuc2F2ZWRWYWx1ZXMsIFwic2hhZG93LVwiLmNvbmNhdChuYW1lKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIElmIHdlIGV4cGVjdGVkIHRoaXMgcmVtb3ZhbCB0aGVuIHB1bGxPdXRcblxuXG4gICAgICAgIGlmIChleHBlY3RlZFJlbW92YWwgJiYgdGhpcy5wdWxsZWRPdXRbbWFnaWNWYWx1ZV0pIHtcbiAgICAgICAgICBkZWJ1ZyQyKCdQdWxsaW5nIG91dCcsIG5hbWUsICd3aXRoIG1hZ2ljIHZhbHVlJywgbWFnaWNWYWx1ZSk7XG4gICAgICAgICAgT2JqZWN0TWFwLnB1bGxPdXQodGhpcy5zdGF0ZS52YWx1ZXMsIG1hZ2ljVmFsdWUpO1xuICAgICAgICAgIE9iamVjdE1hcC5wdWxsT3V0KHRoaXMuc3RhdGUudG91Y2hlZCwgbWFnaWNWYWx1ZSk7XG4gICAgICAgICAgT2JqZWN0TWFwLnB1bGxPdXQodGhpcy5zdGF0ZS5lcnJvcnMsIG1hZ2ljVmFsdWUpO1xuICAgICAgICAgIE9iamVjdE1hcC5wdWxsT3V0KHRoaXMuc2F2ZWRWYWx1ZXMsIG1hZ2ljVmFsdWUpOyAvLyBjb25zb2xlLmxvZygnUHVsbDEnLCB0aGlzLnN0YXRlLnZhbHVlcyk7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ1B1bGwyJywgdGhpcy5zYXZlZFZhbHVlcyk7XG5cbiAgICAgICAgICBkZWxldGUgdGhpcy5wdWxsZWRPdXRbbWFnaWNWYWx1ZV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5lbWl0KCdjaGFuZ2UnKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXhwZWN0UmVtb3ZhbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBleHBlY3RSZW1vdmFsKG5hbWUpIHtcbiAgICAgIGRlYnVnJDIoJ0V4cGVjdGluZyByZW1vdmFsIG9mJywgbmFtZSk7XG4gICAgICB0aGlzLmV4cGVjdGVkUmVtb3ZhbHNbbmFtZV0gPSB0cnVlO1xuICAgICAgdGhpcy5wdWxsZWRPdXRbbmFtZV0gPSB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKGlkLCBmaWVsZCwgb2xkTmFtZSkge1xuICAgICAgZGVidWckMignVXBkYXRlJywgaWQsIGZpZWxkLmZpZWxkLCBvbGROYW1lLCBmaWVsZC5maWVsZFN0YXRlLnZhbHVlKTsgLy8gdGhpcy5jaGFuZ2UoKTtcbiAgICAgIC8vIFVwZGF0ZSB0aGUgZXJyb3IgdG91Y2hlZCBhbmQgdmFsdWVzIG9mIHRoaXMgZmllbGRcblxuICAgICAgdmFyIHZhbHVlID0gZmllbGQuZmllbGRBcGkuZ2V0VmFsdWUoKTtcbiAgICAgIHZhciBlcnJvciA9IGZpZWxkLmZpZWxkQXBpLmdldEVycm9yKCk7XG4gICAgICB2YXIgdCA9IGZpZWxkLmZpZWxkQXBpLmdldFRvdWNoZWQoKTsgLy8gQ2xlYXIgdGhlIG9sZCB2YWx1ZSBvdXRcblxuICAgICAgdmFyIG9sZEZpZWxkID0gdGhpcy5maWVsZHNCeU5hbWUuZ2V0KG9sZE5hbWUpOyAvLyBPbmx5IGNsZWFyIGlmIHdlIGhhZCBhbiBvbGQgbmFtZSAoIG91ciBuYW1lIGNoYW5nZWQgKVxuICAgICAgLy8gJSUgdGhlIG9sZEZpZWxkIGlzIGdvbmUhXG5cbiAgICAgIGlmIChvbGROYW1lICYmICFvbGRGaWVsZCkge1xuICAgICAgICAvLyBTZXR0aW5nIG5vdGhpbmcgc2V0cyB0byB1bmRlZmluZWQgYW5kIGRvZXMgTk9UIHB1bGwgb3V0XG4gICAgICAgIE9iamVjdE1hcC5zZXQodGhpcy5zdGF0ZS52YWx1ZXMsIG9sZE5hbWUpO1xuICAgICAgICBPYmplY3RNYXAuc2V0KHRoaXMuc3RhdGUuZXJyb3JzLCBvbGROYW1lKTtcbiAgICAgICAgT2JqZWN0TWFwLnNldCh0aGlzLnN0YXRlLnRvdWNoZWQsIG9sZE5hbWUpO1xuICAgICAgfSAvLyBTZXQgdGhlIHZhbHVlXG5cblxuICAgICAgT2JqZWN0TWFwLnNldCh0aGlzLnN0YXRlLnZhbHVlcywgZmllbGQuZmllbGQsIHZhbHVlKTtcbiAgICAgIE9iamVjdE1hcC5zZXQodGhpcy5zdGF0ZS5lcnJvcnMsIGZpZWxkLmZpZWxkLCBlcnJvcik7XG4gICAgICBPYmplY3RNYXAuc2V0KHRoaXMuc3RhdGUudG91Y2hlZCwgZmllbGQuZmllbGQsIHQpO1xuICAgICAgdGhpcy5lbWl0KCdjaGFuZ2UnKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRm9ybUNvbnRyb2xsZXI7XG59KEV2ZW50RW1pdHRlcik7XG5cbnZhciBsb2dnZXIkNSA9IGRlYnVnKCdpbmZvcm1lZDpGb3JtUHJvdmlkZXInICsgJ1xcdFxcdCcpO1xuXG52YXIgRm9ybVByb3ZpZGVyID0gZnVuY3Rpb24gRm9ybVByb3ZpZGVyKF9yZWYpIHtcbiAgdmFyIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbixcbiAgICAgIGZvcm1BcGkgPSBfcmVmLmZvcm1BcGksXG4gICAgICBmb3JtQ29udHJvbGxlciA9IF9yZWYuZm9ybUNvbnRyb2xsZXIsXG4gICAgICBmb3JtU3RhdGUgPSBfcmVmLmZvcm1TdGF0ZSxcbiAgICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgW1wiY2hpbGRyZW5cIiwgXCJmb3JtQXBpXCIsIFwiZm9ybUNvbnRyb2xsZXJcIiwgXCJmb3JtU3RhdGVcIl0pO1xuXG4gIGxvZ2dlciQ1KCdSZW5kZXIgRm9ybVByb3ZpZGVyJyk7XG5cbiAgaWYgKGZvcm1BcGkpIHtcbiAgICBsb2dnZXIkNSgnUmVuZGVyIEZvcm1Qcm92aWRlciB3aXRoIGdpdmVuIHZhbHVlcycpO1xuICAgIC8qIC0tLSBDcmVhdGUgUHJvdmlkZXIgd2l0aCBnaXZlbiB2YWx1ZXMgYW5kIHJlbmRlciBDb250ZW50IC0tLSAqL1xuXG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZvcm1SZWdpc3RlckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgIHZhbHVlOiBmb3JtQ29udHJvbGxlci51cGRhdGVyXG4gICAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRm9ybUFwaUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgIHZhbHVlOiBmb3JtQXBpXG4gICAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRm9ybVN0YXRlQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgdmFsdWU6IGZvcm1TdGF0ZVxuICAgIH0sIGNoaWxkcmVuKSkpO1xuICB9XG5cbiAgbG9nZ2VyJDUoJ1JlbmRlciBGb3JtUHJvdmlkZXIgd2l0aCBnZW5lcmF0ZWQgdmFsdWVzJyk7XG4gIC8qIC0tLSBVc2VyIGRpZCBub3QgcGFzcyB2YWx1ZXMgc28gY3JlYXRlIHRoZW0gLS0tICovXG5cbiAgdmFyIHZhbHVlID0gdXNlRm9ybShyZXN0KTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZvcm1SZWdpc3RlckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogdmFsdWUuZm9ybUNvbnRyb2xsZXIudXBkYXRlclxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChGb3JtQXBpQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiB2YWx1ZS5mb3JtQXBpXG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZvcm1TdGF0ZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogdmFsdWUuZm9ybVN0YXRlXG4gIH0sIGNoaWxkcmVuKSkpO1xufTtcblxudmFyIGxvZ2dlciQ2ID0gZGVidWcoJ2luZm9ybWVkOnVzZUZvcm0nICsgJ1xcdFxcdCcpO1xuXG52YXIgdXNlRm9ybSA9IGZ1bmN0aW9uIHVzZUZvcm0oX3JlZikge1xuICB2YXIgZG9udFByZXZlbnREZWZhdWx0ID0gX3JlZi5kb250UHJldmVudERlZmF1bHQsXG4gICAgICBpbml0aWFsVmFsdWVzID0gX3JlZi5pbml0aWFsVmFsdWVzLFxuICAgICAgdmFsaWRhdGUgPSBfcmVmLnZhbGlkYXRlLFxuICAgICAgdmFsaWRhdGVGaWVsZHMgPSBfcmVmLnZhbGlkYXRlRmllbGRzLFxuICAgICAgYWxsb3dFbXB0eVN0cmluZ3MgPSBfcmVmLmFsbG93RW1wdHlTdHJpbmdzLFxuICAgICAgcHJldmVudEVudGVyID0gX3JlZi5wcmV2ZW50RW50ZXIsXG4gICAgICBnZXRBcGkgPSBfcmVmLmdldEFwaSxcbiAgICAgIGFwaVJlZiA9IF9yZWYuYXBpUmVmLFxuICAgICAgb25DaGFuZ2UgPSBfcmVmLm9uQ2hhbmdlLFxuICAgICAgb25SZXNldCA9IF9yZWYub25SZXNldCxcbiAgICAgIG9uU3VibWl0ID0gX3JlZi5vblN1Ym1pdCxcbiAgICAgIG9uVmFsdWVDaGFuZ2UgPSBfcmVmLm9uVmFsdWVDaGFuZ2UsXG4gICAgICBvblN1Ym1pdEZhaWx1cmUgPSBfcmVmLm9uU3VibWl0RmFpbHVyZSxcbiAgICAgIHZhbGlkYXRpb25TY2hlbWEgPSBfcmVmLnZhbGlkYXRpb25TY2hlbWEsXG4gICAgICBzY2hlbWEgPSBfcmVmLnNjaGVtYSxcbiAgICAgIGFqdiA9IF9yZWYuYWp2LFxuICAgICAgZmllbGRNYXAgPSBfcmVmLmZpZWxkTWFwLFxuICAgICAgb25seVZhbGlkYXRlU2NoZW1hID0gX3JlZi5vbmx5VmFsaWRhdGVTY2hlbWEsXG4gICAgICB1c2VyUHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgW1wiZG9udFByZXZlbnREZWZhdWx0XCIsIFwiaW5pdGlhbFZhbHVlc1wiLCBcInZhbGlkYXRlXCIsIFwidmFsaWRhdGVGaWVsZHNcIiwgXCJhbGxvd0VtcHR5U3RyaW5nc1wiLCBcInByZXZlbnRFbnRlclwiLCBcImdldEFwaVwiLCBcImFwaVJlZlwiLCBcIm9uQ2hhbmdlXCIsIFwib25SZXNldFwiLCBcIm9uU3VibWl0XCIsIFwib25WYWx1ZUNoYW5nZVwiLCBcIm9uU3VibWl0RmFpbHVyZVwiLCBcInZhbGlkYXRpb25TY2hlbWFcIiwgXCJzY2hlbWFcIiwgXCJhanZcIiwgXCJmaWVsZE1hcFwiLCBcIm9ubHlWYWxpZGF0ZVNjaGVtYVwiXSk7XG5cbiAgbG9nZ2VyJDYoJ1JlbmRlciB1c2VGb3JtJyk7IC8vIEdlbmVyYXRlIGZvcm0gY29udHJvbGxlciBvcHRpb25zXG5cbiAgdmFyIGZvcm1Db250cm9sbGVyT3B0aW9ucyA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBkb250UHJldmVudERlZmF1bHQ6IGRvbnRQcmV2ZW50RGVmYXVsdCxcbiAgICAgIGluaXRpYWxWYWx1ZXM6IGluaXRpYWxWYWx1ZXMsXG4gICAgICB2YWxpZGF0ZTogdmFsaWRhdGUsXG4gICAgICB2YWxpZGF0ZUZpZWxkczogdmFsaWRhdGVGaWVsZHMsXG4gICAgICBhbGxvd0VtcHR5U3RyaW5nczogYWxsb3dFbXB0eVN0cmluZ3MsXG4gICAgICBwcmV2ZW50RW50ZXI6IHByZXZlbnRFbnRlcixcbiAgICAgIHZhbGlkYXRpb25TY2hlbWE6IHZhbGlkYXRpb25TY2hlbWEsXG4gICAgICBzY2hlbWE6IHNjaGVtYSxcbiAgICAgIGFqdjogYWp2LFxuICAgICAgZmllbGRNYXA6IGZpZWxkTWFwXG4gICAgfTtcbiAgfSwgW2RvbnRQcmV2ZW50RGVmYXVsdCwgaW5pdGlhbFZhbHVlcywgdmFsaWRhdGUsIHZhbGlkYXRlRmllbGRzLCBhbGxvd0VtcHR5U3RyaW5ncywgcHJldmVudEVudGVyLCB2YWxpZGF0aW9uU2NoZW1hLCBzY2hlbWEsIGFqdiwgZmllbGRNYXBdKTsgLy8gQ3JlYXRlIGZvcm0gY29udHJvbGxlclxuXG4gIHZhciBfdXNlU3RhdGUgPSB1c2VTdGF0ZShmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBGb3JtQ29udHJvbGxlcihmb3JtQ29udHJvbGxlck9wdGlvbnMpO1xuICB9KSxcbiAgICAgIF91c2VTdGF0ZTIgPSBfc2xpY2VkVG9BcnJheShfdXNlU3RhdGUsIDEpLFxuICAgICAgZm9ybUNvbnRyb2xsZXIgPSBfdXNlU3RhdGUyWzBdOyAvLyBVcGRhdGUgdGhlIG9wdGlvbnMgd2hlbiB0aGV5IGNoYW5nZVxuXG5cbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBmb3JtQ29udHJvbGxlci5zZXRPcHRpb25zKGZvcm1Db250cm9sbGVyT3B0aW9ucyk7XG4gIH0sIFtmb3JtQ29udHJvbGxlck9wdGlvbnNdKTsgLy8gRm9ybSBzdGF0ZSB3aWxsIGJlIHVzZWQgdG8gdHJpZ2dlciByZXJlbmRlcnNcblxuICB2YXIgX3VzZVN0YXRlMyA9IHVzZVN0YXRlKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZm9ybUNvbnRyb2xsZXIuZ2V0Rm9ybVN0YXRlKCk7XG4gIH0pLFxuICAgICAgX3VzZVN0YXRlNCA9IF9zbGljZWRUb0FycmF5KF91c2VTdGF0ZTMsIDIpLFxuICAgICAgZm9ybVN0YXRlID0gX3VzZVN0YXRlNFswXSxcbiAgICAgIHNldEZvcm1TdGF0ZSA9IF91c2VTdGF0ZTRbMV07IC8vIFJlZ2lzdGVyIGZvciBldmVudHNcblxuXG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHZhciBvbkNoYW5nZUhhbmRsZXIgPSBmdW5jdGlvbiBvbkNoYW5nZUhhbmRsZXIoKSB7XG4gICAgICByZXR1cm4gb25DaGFuZ2UgJiYgb25DaGFuZ2UoZm9ybUNvbnRyb2xsZXIuZ2V0Rm9ybVN0YXRlKCkpO1xuICAgIH07XG5cbiAgICB2YXIgb25SZXNldEhhbmRsZXIgPSBmdW5jdGlvbiBvblJlc2V0SGFuZGxlcigpIHtcbiAgICAgIHJldHVybiBvblJlc2V0ICYmIG9uUmVzZXQoKTtcbiAgICB9O1xuXG4gICAgdmFyIG9uU3VibWl0SGFuZGxlciA9IGZ1bmN0aW9uIG9uU3VibWl0SGFuZGxlcigpIHtcbiAgICAgIHJldHVybiBvblN1Ym1pdCAmJiBvblN1Ym1pdChmb3JtQ29udHJvbGxlci5nZXRGb3JtU3RhdGUoKS52YWx1ZXMpO1xuICAgIH07XG5cbiAgICB2YXIgb25WYWx1ZUhhbmRsZXIgPSBmdW5jdGlvbiBvblZhbHVlSGFuZGxlcigpIHtcbiAgICAgIHJldHVybiBvblZhbHVlQ2hhbmdlICYmIG9uVmFsdWVDaGFuZ2UoZm9ybUNvbnRyb2xsZXIuZ2V0Rm9ybVN0YXRlKCkudmFsdWVzKTtcbiAgICB9O1xuXG4gICAgdmFyIG9uRmFpbHVyZUhhbmRsZXIgPSBmdW5jdGlvbiBvbkZhaWx1cmVIYW5kbGVyKCkge1xuICAgICAgcmV0dXJuIG9uU3VibWl0RmFpbHVyZSAmJiBvblN1Ym1pdEZhaWx1cmUoZm9ybUNvbnRyb2xsZXIuZ2V0Rm9ybVN0YXRlKCkuZXJyb3JzKTtcbiAgICB9OyAvLyBSZWdpc3RlciBmb3IgZXZlbnRzXG5cblxuICAgIGZvcm1Db250cm9sbGVyLm9uKCdjaGFuZ2UnLCBvbkNoYW5nZUhhbmRsZXIpO1xuICAgIGZvcm1Db250cm9sbGVyLm9uKCdyZXNldCcsIG9uUmVzZXRIYW5kbGVyKTtcbiAgICBmb3JtQ29udHJvbGxlci5vbignc3VibWl0Jywgb25TdWJtaXRIYW5kbGVyKTtcbiAgICBmb3JtQ29udHJvbGxlci5vbigndmFsdWUnLCBvblZhbHVlSGFuZGxlcik7XG4gICAgZm9ybUNvbnRyb2xsZXIub24oJ2ZhaWx1cmUnLCBvbkZhaWx1cmVIYW5kbGVyKTsgLy8gVW5yZWdpc3RlciBldmVudHNcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3JtQ29udHJvbGxlci5yZW1vdmVMaXN0ZW5lcignY2hhbmdlJywgb25DaGFuZ2VIYW5kbGVyKTtcbiAgICAgIGZvcm1Db250cm9sbGVyLnJlbW92ZUxpc3RlbmVyKCdyZXNldCcsIG9uUmVzZXRIYW5kbGVyKTtcbiAgICAgIGZvcm1Db250cm9sbGVyLnJlbW92ZUxpc3RlbmVyKCdzdWJtaXQnLCBvblN1Ym1pdEhhbmRsZXIpO1xuICAgICAgZm9ybUNvbnRyb2xsZXIucmVtb3ZlTGlzdGVuZXIoJ3ZhbHVlJywgb25WYWx1ZUhhbmRsZXIpO1xuICAgICAgZm9ybUNvbnRyb2xsZXIucmVtb3ZlTGlzdGVuZXIoJ2ZhaWx1cmUnLCBvbkZhaWx1cmVIYW5kbGVyKTtcbiAgICB9O1xuICB9LCBbb25DaGFuZ2UsIG9uUmVzZXQsIG9uU3VibWl0LCBvblZhbHVlQ2hhbmdlLCBvblN1Ym1pdEZhaWx1cmVdKTsgLy8gSW5pdGlhbGl6ZSBjb2RlIGxpa2UgY29uc3RydWN0b3IgYnV0IG5vdCBtdWhhaGFoXG5cbiAgdXNlU3RhdGUoZnVuY3Rpb24gKCkge1xuICAgIC8vIFVwZGF0ZSB0aGUgZm9ybSBzdGF0ZSB0byB0cmlnZ2VyIHJlcmVuZGVyIVxuICAgIHZhciBvbkNoYW5nZUhhbmRsZXJSZXJlbmRlciA9IGZ1bmN0aW9uIG9uQ2hhbmdlSGFuZGxlclJlcmVuZGVyKCkge1xuICAgICAgbG9nZ2VyJDYoJ1NldHRpbmcgZm9ybSBzdGF0ZScpO1xuICAgICAgc2V0Rm9ybVN0YXRlKGZvcm1Db250cm9sbGVyLmdldEZvcm1TdGF0ZSgpKTtcbiAgICB9OyAvLyBjb25zdCBkZWJvdW5jZWQgPSBkZWJvdW5jZShvbkNoYW5nZUhhbmRsZXJSZXJlbmRlciwgMjUwKTtcblxuXG4gICAgZm9ybUNvbnRyb2xsZXIub24oJ2NoYW5nZScsIG9uQ2hhbmdlSGFuZGxlclJlcmVuZGVyKTsgLy8gR2l2ZSBhY2Nlc3MgdG8gYXBpIG91dHNpZGVcblxuICAgIGlmIChnZXRBcGkpIHtcbiAgICAgIGdldEFwaShmb3JtQ29udHJvbGxlci5nZXRGb3JtQXBpKCkpO1xuICAgIH1cblxuICAgIGlmIChhcGlSZWYpIHtcbiAgICAgIGFwaVJlZi5jdXJyZW50ID0gZm9ybUNvbnRyb2xsZXIuZ2V0Rm9ybUFwaSgpO1xuICAgIH1cbiAgfSk7IC8vIFdlIGRvbnQgd2FudCB0aGlzIHRvIGhhcHBlbiBvbiBldmVyeSByZW5kZXIgc28gdGhhdHMgd2h5IHVzZVN0YXRlIGlzIHVzZWQgaGVyZVxuXG4gIHZhciBfdXNlU3RhdGU1ID0gdXNlU3RhdGUoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmb3JtQ29udHJvbGxlci5nZXRGb3JtQXBpKCk7XG4gIH0pLFxuICAgICAgX3VzZVN0YXRlNiA9IF9zbGljZWRUb0FycmF5KF91c2VTdGF0ZTUsIDEpLFxuICAgICAgZm9ybUFwaSA9IF91c2VTdGF0ZTZbMF07IC8vIFRPRE8gdGVjaG5pY2FsbHkgc3BlYWtpbmcgdGhpcyBjYW4gYmUgdW5zYWZlIGFzIHRoZXJlIGlzIGNpcmN1bGFyIGRlcGVuZGVuY3lcbiAgLy8gYmV0d2VlbiBmb3JtIHByb3ZpZGVyIGFuZCB1c2VGb3JtLi4gSXRzIG9rIGJlY2F1c2UgYW55b25lIHRoYXQgaW4gdGhlb3J5XG4gIC8vIFVzZXMgYSBmb3JtIHByb3ZpZGVyIGFuZCBhIHVzZSBmb3JtIGhvb2sgdGhlbXNlbHZlcyB3aWxsIG5ldmVyIGNhbGwgdGhlIHJlbmRlclxuICAvLyBmdW5jdGlvbiBjcmVhdGVkIGhlcmUuLi4gdGhhdCBiZWluZyBzYWlkIEkgd2lsbCBsb29rIGludG8gZml4aW5nIHRoYXQgd2FybmluZ1xuICAvLyBhdCBzb21lIHBvaW50IDopXG5cblxuICB2YXIgcmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKGNoaWxkcmVuKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZvcm1Qcm92aWRlciwge1xuICAgICAgZm9ybUFwaTogZm9ybUFwaSxcbiAgICAgIGZvcm1TdGF0ZTogZm9ybVN0YXRlLFxuICAgICAgZm9ybUNvbnRyb2xsZXI6IGZvcm1Db250cm9sbGVyXG4gICAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsICFjaGlsZHJlbiA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZvcm1GaWVsZHMsIHtcbiAgICAgIHNjaGVtYTogc2NoZW1hLFxuICAgICAgb25seVZhbGlkYXRlU2NoZW1hOiBvbmx5VmFsaWRhdGVTY2hlbWFcbiAgICB9KSA6IGNoaWxkcmVuKSk7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBmb3JtQXBpOiBmb3JtQXBpLFxuICAgIGZvcm1TdGF0ZTogZm9ybVN0YXRlLFxuICAgIGZvcm1Db250cm9sbGVyOiBmb3JtQ29udHJvbGxlcixcbiAgICByZW5kZXI6IHJlbmRlcixcbiAgICB1c2VyUHJvcHM6IHVzZXJQcm9wc1xuICB9O1xufTtcblxudmFyIGRlYnVnJDMgPSBkZWJ1ZygnaW5mb3JtZWQ6Rm9ybScgKyAnXFx0XFx0Jyk7XG5cbnZhciBGb3JtID0gZnVuY3Rpb24gRm9ybShfcmVmKSB7XG4gIHZhciBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICByZW5kZXJQcm9wID0gX3JlZi5yZW5kZXIsXG4gICAgICBjb21wb25lbnQgPSBfcmVmLmNvbXBvbmVudCxcbiAgICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgW1wiY2hpbGRyZW5cIiwgXCJyZW5kZXJcIiwgXCJjb21wb25lbnRcIl0pO1xuXG4gIGRlYnVnJDMoJ1JlbmRlciBGT1JNJyk7XG5cbiAgdmFyIF91c2VGb3JtID0gdXNlRm9ybShyZXN0KSxcbiAgICAgIGZvcm1BcGkgPSBfdXNlRm9ybS5mb3JtQXBpLFxuICAgICAgZm9ybUNvbnRyb2xsZXIgPSBfdXNlRm9ybS5mb3JtQ29udHJvbGxlcixcbiAgICAgIGZvcm1TdGF0ZSA9IF91c2VGb3JtLmZvcm1TdGF0ZSxcbiAgICAgIHJlbmRlciA9IF91c2VGb3JtLnJlbmRlcixcbiAgICAgIHVzZXJQcm9wcyA9IF91c2VGb3JtLnVzZXJQcm9wcztcblxuICB2YXIgZ2V0Q29udGVudCA9IGZ1bmN0aW9uIGdldENvbnRlbnQoKSB7XG4gICAgdmFyIHByb3BzID0ge1xuICAgICAgZm9ybVN0YXRlOiBmb3JtU3RhdGUsXG4gICAgICBmb3JtQXBpOiBmb3JtQXBpXG4gICAgfTtcblxuICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChjb21wb25lbnQsIHByb3BzLCBjaGlsZHJlbik7XG4gICAgfVxuXG4gICAgaWYgKHJlbmRlclByb3ApIHtcbiAgICAgIHJldHVybiByZW5kZXJQcm9wKHByb3BzKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNoaWxkcmVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gY2hpbGRyZW4ocHJvcHMpO1xuICAgIH1cblxuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfTtcbiAgLyogLS0tIFJlbmRlciBDb250ZW50IC0tLSAqL1xuXG5cbiAgcmV0dXJuIHJlbmRlciggLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJmb3JtXCIsIF9leHRlbmRzKHt9LCB1c2VyUHJvcHMsIHtcbiAgICBvblJlc2V0OiBmb3JtQ29udHJvbGxlci5yZXNldCxcbiAgICBvblN1Ym1pdDogZm9ybUNvbnRyb2xsZXIuc3VibWl0Rm9ybSxcbiAgICBvbktleURvd246IGZvcm1Db250cm9sbGVyLmtleURvd25cbiAgfSksIGdldENvbnRlbnQoKSkpO1xufTtcblxudmFyIGJ1aWxkU2NvcGVkRm9ybUFwaSQxID0gZnVuY3Rpb24gYnVpbGRTY29wZWRGb3JtQXBpKHNjb3BlLCBmb3JtQXBpKSB7XG4gIHJldHVybiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgZm9ybUFwaSksIHt9LCB7XG4gICAgZ2V0VmFsdWU6IGZ1bmN0aW9uIGdldFZhbHVlKGZpZWxkKSB7XG4gICAgICByZXR1cm4gZm9ybUFwaS5nZXRWYWx1ZShcIlwiLmNvbmNhdChzY29wZSwgXCIuXCIpLmNvbmNhdChmaWVsZCkpO1xuICAgIH0sXG4gICAgZ2V0VG91Y2hlZDogZnVuY3Rpb24gZ2V0VG91Y2hlZChmaWVsZCkge1xuICAgICAgcmV0dXJuIGZvcm1BcGkuZ2V0VG91Y2hlZChcIlwiLmNvbmNhdChzY29wZSwgXCIuXCIpLmNvbmNhdChmaWVsZCkpO1xuICAgIH0sXG4gICAgZ2V0RXJyb3I6IGZ1bmN0aW9uIGdldEVycm9yKGZpZWxkKSB7XG4gICAgICByZXR1cm4gZm9ybUFwaS5nZXRFcnJvcihcIlwiLmNvbmNhdChzY29wZSwgXCIuXCIpLmNvbmNhdChmaWVsZCkpO1xuICAgIH0sXG4gICAgc2V0VmFsdWU6IGZ1bmN0aW9uIHNldFZhbHVlKGZpZWxkLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGZvcm1BcGkuc2V0VmFsdWUoXCJcIi5jb25jYXQoc2NvcGUsIFwiLlwiKS5jb25jYXQoZmllbGQpLCB2YWx1ZSk7XG4gICAgfSxcbiAgICBzZXRUb3VjaGVkOiBmdW5jdGlvbiBzZXRUb3VjaGVkKGZpZWxkLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGZvcm1BcGkuc2V0VG91Y2hlZChcIlwiLmNvbmNhdChzY29wZSwgXCIuXCIpLmNvbmNhdChmaWVsZCksIHZhbHVlKTtcbiAgICB9LFxuICAgIHNldEVycm9yOiBmdW5jdGlvbiBzZXRFcnJvcihmaWVsZCwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBmb3JtQXBpLnNldEVycm9yKFwiXCIuY29uY2F0KHNjb3BlLCBcIi5cIikuY29uY2F0KGZpZWxkKSwgdmFsdWUpO1xuICAgIH0sXG4gICAgZ2V0SW5pdGlhbFZhbHVlOiBmdW5jdGlvbiBnZXRJbml0aWFsVmFsdWUoZmllbGQpIHtcbiAgICAgIHJldHVybiBmb3JtQXBpLmdldEluaXRpYWxWYWx1ZShcIlwiLmNvbmNhdChzY29wZSwgXCIuXCIpLmNvbmNhdChmaWVsZCkpO1xuICAgIH0sXG4gICAgZ2V0RnVsbEZpZWxkOiBmdW5jdGlvbiBnZXRGdWxsRmllbGQoZmllbGQpIHtcbiAgICAgIHJldHVybiBcIlwiLmNvbmNhdChmb3JtQXBpLmdldEZ1bGxGaWVsZChzY29wZSksIFwiLlwiKS5jb25jYXQoZmllbGQpO1xuICAgIH1cbiAgfSk7XG59O1xuXG52YXIgYnVpbGRTY29wZWRSZWdpc3RlciA9IGZ1bmN0aW9uIGJ1aWxkU2NvcGVkUmVnaXN0ZXIoc2NvcGUsIGZvcm1SZWdpc3Rlcikge1xuICB2YXIgX3JlZ2lzdGVyID0gZm9ybVJlZ2lzdGVyLnJlZ2lzdGVyLFxuICAgICAgX2RlcmVnaXN0ZXIgPSBmb3JtUmVnaXN0ZXIuZGVyZWdpc3RlcixcbiAgICAgIF9zZXRWYWx1ZSA9IGZvcm1SZWdpc3Rlci5zZXRWYWx1ZSxcbiAgICAgIF9zZXRUb3VjaGVkID0gZm9ybVJlZ2lzdGVyLnNldFRvdWNoZWQsXG4gICAgICBfc2V0RXJyb3IgPSBmb3JtUmVnaXN0ZXIuc2V0RXJyb3IsXG4gICAgICBfdXBkYXRlID0gZm9ybVJlZ2lzdGVyLnVwZGF0ZSxcbiAgICAgIF9nZXRGaWVsZCA9IGZvcm1SZWdpc3Rlci5nZXRGaWVsZCxcbiAgICAgIF9leHBlY3RSZW1vdmFsID0gZm9ybVJlZ2lzdGVyLmV4cGVjdFJlbW92YWwsXG4gICAgICBfZ2V0SW5pdGlhbFZhbHVlID0gZm9ybVJlZ2lzdGVyLmdldEluaXRpYWxWYWx1ZSxcbiAgICAgIGZpZWxkTWFwID0gZm9ybVJlZ2lzdGVyLmZpZWxkTWFwO1xuICByZXR1cm4ge1xuICAgIHJlZ2lzdGVyOiBmdW5jdGlvbiByZWdpc3RlcihmaWVsZCkge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9yZWdpc3Rlci5hcHBseSh2b2lkIDAsIFtcIlwiLmNvbmNhdChzY29wZSwgXCIuXCIpLmNvbmNhdChmaWVsZCldLmNvbmNhdChhcmdzKSk7XG4gICAgfSxcbiAgICBkZXJlZ2lzdGVyOiBmdW5jdGlvbiBkZXJlZ2lzdGVyKGZpZWxkKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2RlcmVnaXN0ZXIuYXBwbHkodm9pZCAwLCBbXCJcIi5jb25jYXQoc2NvcGUsIFwiLlwiKS5jb25jYXQoZmllbGQpXS5jb25jYXQoYXJncykpO1xuICAgIH0sXG4gICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUoZmllbGQpIHtcbiAgICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMyA+IDEgPyBfbGVuMyAtIDEgOiAwKSwgX2tleTMgPSAxOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgICAgIGFyZ3NbX2tleTMgLSAxXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfdXBkYXRlLmFwcGx5KHZvaWQgMCwgW1wiXCIuY29uY2F0KHNjb3BlLCBcIi5cIikuY29uY2F0KGZpZWxkKV0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIHNldFZhbHVlOiBmdW5jdGlvbiBzZXRWYWx1ZShmaWVsZCkge1xuICAgICAgZm9yICh2YXIgX2xlbjQgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW40ID4gMSA/IF9sZW40IC0gMSA6IDApLCBfa2V5NCA9IDE7IF9rZXk0IDwgX2xlbjQ7IF9rZXk0KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NCAtIDFdID0gYXJndW1lbnRzW19rZXk0XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9zZXRWYWx1ZS5hcHBseSh2b2lkIDAsIFtcIlwiLmNvbmNhdChzY29wZSwgXCIuXCIpLmNvbmNhdChmaWVsZCldLmNvbmNhdChhcmdzKSk7XG4gICAgfSxcbiAgICBzZXRUb3VjaGVkOiBmdW5jdGlvbiBzZXRUb3VjaGVkKGZpZWxkKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjUgPiAxID8gX2xlbjUgLSAxIDogMCksIF9rZXk1ID0gMTsgX2tleTUgPCBfbGVuNTsgX2tleTUrKykge1xuICAgICAgICBhcmdzW19rZXk1IC0gMV0gPSBhcmd1bWVudHNbX2tleTVdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3NldFRvdWNoZWQuYXBwbHkodm9pZCAwLCBbXCJcIi5jb25jYXQoc2NvcGUsIFwiLlwiKS5jb25jYXQoZmllbGQpXS5jb25jYXQoYXJncykpO1xuICAgIH0sXG4gICAgc2V0RXJyb3I6IGZ1bmN0aW9uIHNldEVycm9yKGZpZWxkKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjYgPiAxID8gX2xlbjYgLSAxIDogMCksIF9rZXk2ID0gMTsgX2tleTYgPCBfbGVuNjsgX2tleTYrKykge1xuICAgICAgICBhcmdzW19rZXk2IC0gMV0gPSBhcmd1bWVudHNbX2tleTZdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3NldEVycm9yLmFwcGx5KHZvaWQgMCwgW1wiXCIuY29uY2F0KHNjb3BlLCBcIi5cIikuY29uY2F0KGZpZWxkKV0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIGdldEZpZWxkOiBmdW5jdGlvbiBnZXRGaWVsZChmaWVsZCkge1xuICAgICAgZm9yICh2YXIgX2xlbjcgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW43ID4gMSA/IF9sZW43IC0gMSA6IDApLCBfa2V5NyA9IDE7IF9rZXk3IDwgX2xlbjc7IF9rZXk3KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NyAtIDFdID0gYXJndW1lbnRzW19rZXk3XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9nZXRGaWVsZC5hcHBseSh2b2lkIDAsIFtcIlwiLmNvbmNhdChzY29wZSwgXCIuXCIpLmNvbmNhdChmaWVsZCldLmNvbmNhdChhcmdzKSk7XG4gICAgfSxcbiAgICBleHBlY3RSZW1vdmFsOiBmdW5jdGlvbiBleHBlY3RSZW1vdmFsKGZpZWxkKSB7XG4gICAgICBmb3IgKHZhciBfbGVuOCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjggPiAxID8gX2xlbjggLSAxIDogMCksIF9rZXk4ID0gMTsgX2tleTggPCBfbGVuODsgX2tleTgrKykge1xuICAgICAgICBhcmdzW19rZXk4IC0gMV0gPSBhcmd1bWVudHNbX2tleThdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2V4cGVjdFJlbW92YWwuYXBwbHkodm9pZCAwLCBbXCJcIi5jb25jYXQoc2NvcGUsIFwiLlwiKS5jb25jYXQoZmllbGQpXS5jb25jYXQoYXJncykpO1xuICAgIH0sXG4gICAgZ2V0SW5pdGlhbFZhbHVlOiBmdW5jdGlvbiBnZXRJbml0aWFsVmFsdWUoZmllbGQpIHtcbiAgICAgIHJldHVybiBfZ2V0SW5pdGlhbFZhbHVlKFwiXCIuY29uY2F0KHNjb3BlLCBcIi5cIikuY29uY2F0KGZpZWxkKSk7XG4gICAgfSxcbiAgICBmaWVsZE1hcDogZmllbGRNYXBcbiAgfTtcbn07XG5cbnZhciBTY29wZSA9IGZ1bmN0aW9uIFNjb3BlKF9yZWYpIHtcbiAgdmFyIHNjb3BlID0gX3JlZi5zY29wZSxcbiAgICAgIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbjtcbiAgdmFyIGZvcm1SZWdpc3RlciA9IHVzZUNvbnRleHQoRm9ybVJlZ2lzdGVyQ29udGV4dCk7XG4gIHZhciBmb3JtQXBpID0gdXNlRm9ybUFwaSgpO1xuICB2YXIgZm9ybVN0YXRlID0gdXNlRm9ybVN0YXRlKCk7IC8vIFZFUlkgaW1wb3J0YW50IHRvIG1lbW9pemUgdGhlIGJ1aWxkZXJzIVxuXG4gIHZhciBzY29wZWRGb3JtQXBpID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGJ1aWxkU2NvcGVkRm9ybUFwaSQxKHNjb3BlLCBmb3JtQXBpKTtcbiAgfSwgW3Njb3BlXSk7XG4gIHZhciBzY29wZWRSZWdpc3RlciA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBidWlsZFNjb3BlZFJlZ2lzdGVyKHNjb3BlLCBmb3JtUmVnaXN0ZXIpO1xuICB9LCBbc2NvcGVdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZvcm1SZWdpc3RlckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogc2NvcGVkUmVnaXN0ZXJcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRm9ybUFwaUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogc2NvcGVkRm9ybUFwaVxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChGb3JtU3RhdGVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGZvcm1TdGF0ZVxuICB9LCBjaGlsZHJlbikpKTtcbn07XG5cbnZhciBGb3JtU3RhdGUgPSBmdW5jdGlvbiBGb3JtU3RhdGUocHJvcHMpIHtcbiAgdmFyIGZvcm1TdGF0ZSA9IHVzZUZvcm1TdGF0ZSgpO1xuICB2YXIgZGlzcGxheVN0YXRlID0ge307XG5cbiAgaWYgKE9iamVjdC5rZXlzKHByb3BzKS5sZW5ndGggPiAwKSB7XG4gICAgT2JqZWN0LmtleXMocHJvcHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgZGlzcGxheVN0YXRlW2tleV0gPSBmb3JtU3RhdGVba2V5XTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBkaXNwbGF5U3RhdGUgPSBmb3JtU3RhdGU7XG4gIH1cblxuICB2YXIgX2Rpc3BsYXlTdGF0ZSA9IGRpc3BsYXlTdGF0ZSxcbiAgICAgIHByaXN0aW5lID0gX2Rpc3BsYXlTdGF0ZS5wcmlzdGluZSxcbiAgICAgIGRpcnR5ID0gX2Rpc3BsYXlTdGF0ZS5kaXJ0eSxcbiAgICAgIGludmFsaWQgPSBfZGlzcGxheVN0YXRlLmludmFsaWQsXG4gICAgICB2YWx1ZXMgPSBfZGlzcGxheVN0YXRlLnZhbHVlcyxcbiAgICAgIGVycm9ycyA9IF9kaXNwbGF5U3RhdGUuZXJyb3JzLFxuICAgICAgdG91Y2hlZCA9IF9kaXNwbGF5U3RhdGUudG91Y2hlZCxcbiAgICAgIHZhbGlkYXRpbmcgPSBfZGlzcGxheVN0YXRlLnZhbGlkYXRpbmcsXG4gICAgICBzdWJtaXR0aW5nID0gX2Rpc3BsYXlTdGF0ZS5zdWJtaXR0aW5nO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwcmVcIiwgbnVsbCwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJjb2RlXCIsIG51bGwsIEpTT04uc3RyaW5naWZ5KHtcbiAgICBwcmlzdGluZTogcHJpc3RpbmUsXG4gICAgZGlydHk6IGRpcnR5LFxuICAgIGludmFsaWQ6IGludmFsaWQsXG4gICAgdmFsdWVzOiB2YWx1ZXMsXG4gICAgZXJyb3JzOiBlcnJvcnMsXG4gICAgdG91Y2hlZDogdG91Y2hlZCxcbiAgICB2YWxpZGF0aW5nOiB2YWxpZGF0aW5nLFxuICAgIHN1Ym1pdHRpbmc6IHN1Ym1pdHRpbmdcbiAgfSwgbnVsbCwgMikpKTtcbn07XG5cbnZhciB1c2VNdWx0aXN0ZXAgPSBmdW5jdGlvbiB1c2VNdWx0aXN0ZXAoX3JlZikge1xuICB2YXIgaW5pdGlhbFN0ZXAgPSBfcmVmLmluaXRpYWxTdGVwLFxuICAgICAgbXVsdGlzdGVwQXBpUmVmID0gX3JlZi5tdWx0aXN0ZXBBcGlSZWY7XG5cbiAgLy8gR2V0IHRoZSBmb3JtQXBpXG4gIHZhciBfdXNlRm9ybUFwaSA9IHVzZUZvcm1BcGkoKSxcbiAgICAgIGdldFZhbHVlcyA9IF91c2VGb3JtQXBpLmdldFZhbHVlcyxcbiAgICAgIHZhbGlkYXRlID0gX3VzZUZvcm1BcGkudmFsaWRhdGUsXG4gICAgICBzY3JlZW5WYWxpZCA9IF91c2VGb3JtQXBpLnNjcmVlblZhbGlkOyAvLyBUcmFjayBvdXIgc3RlcHMgYnkgbmFtZVxuXG5cbiAgdmFyIF91c2VTdGF0ZSA9IHVzZVN0YXRlKG5ldyBNYXAoKSksXG4gICAgICBfdXNlU3RhdGUyID0gX3NsaWNlZFRvQXJyYXkoX3VzZVN0YXRlLCAxKSxcbiAgICAgIHN0ZXBzQnlOYW1lID0gX3VzZVN0YXRlMlswXTsgLy8gRGVmaW5lIG91ciBzdGF0ZVxuXG5cbiAgdmFyIF91c2VTdGF0ZVdpdGhHZXR0ZXIgPSB1c2VTdGF0ZVdpdGhHZXR0ZXIoe1xuICAgIGN1cnJlbnQ6IGluaXRpYWxTdGVwLFxuICAgIHN0ZXBzOiBbXVxuICB9KSxcbiAgICAgIF91c2VTdGF0ZVdpdGhHZXR0ZXIyID0gX3NsaWNlZFRvQXJyYXkoX3VzZVN0YXRlV2l0aEdldHRlciwgMyksXG4gICAgICBtdWx0aXN0ZXBTdGF0ZSA9IF91c2VTdGF0ZVdpdGhHZXR0ZXIyWzBdLFxuICAgICAgc2V0TXVsdGlzdGVwU3RhdGUgPSBfdXNlU3RhdGVXaXRoR2V0dGVyMlsxXSxcbiAgICAgIGdldE11bHRpc3RlcFN0YXRlID0gX3VzZVN0YXRlV2l0aEdldHRlcjJbMl07IC8vIERlZmluZSBvdXIgYXBpXG5cblxuICB2YXIgX3VzZVN0YXRlMyA9IHVzZVN0YXRlKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZ2V0Q3VycmVudFN0ZXAgPSBmdW5jdGlvbiBnZXRDdXJyZW50U3RlcCgpIHtcbiAgICAgIC8vIEdldCB0aGUgY3VycmVudCBzdGF0ZVxuICAgICAgdmFyIF9nZXRNdWx0aXN0ZXBTdGF0ZSA9IGdldE11bHRpc3RlcFN0YXRlKCksXG4gICAgICAgICAgY3VycmVudCA9IF9nZXRNdWx0aXN0ZXBTdGF0ZS5jdXJyZW50OyAvLyBHZXQgdGhlIGN1cnJlbnQgc3RlcFxuXG5cbiAgICAgIHZhciBjdXJyZW50U3RlcCA9IHN0ZXBzQnlOYW1lLmdldChjdXJyZW50KTsgLy8gUmV0dXJuIGl0XG5cbiAgICAgIHJldHVybiBjdXJyZW50U3RlcDtcbiAgICB9O1xuXG4gICAgdmFyIGFwaSA9IHtcbiAgICAgIC8vIEdldHMgdGhlIHdob2xlIHN0YXRlXG4gICAgICBnZXRTdGF0ZTogZnVuY3Rpb24gZ2V0U3RhdGUoKSB7XG4gICAgICAgIHJldHVybiBnZXRNdWx0aXN0ZXBTdGF0ZSgpO1xuICAgICAgfSxcbiAgICAgIC8vIEdldHMganVzdCB0aGUgY3VycmVudFxuICAgICAgZ2V0Q3VycmVudFN0ZXA6IGdldEN1cnJlbnRTdGVwLFxuICAgICAgLy8gR2V0cyB0aGF0IHN0ZXBcbiAgICAgIGdldFN0ZXA6IGZ1bmN0aW9uIGdldFN0ZXAobmFtZSkge1xuICAgICAgICByZXR1cm4gc3RlcHNCeU5hbWUuZ2V0KG5hbWUpO1xuICAgICAgfSxcbiAgICAgIC8vIEdvZXMgdG8gbmV4dCBzdGVwXG4gICAgICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAvLyBWYWxpZGF0ZSB0aGUgZW50aXJlIGZvcm1cbiAgICAgICAgdmFsaWRhdGUoKTsgLy8gSWYgZmllbGRzIG9uIHRoZSBzY3JlZW4gKCBjdXJyZW50bHkgcmVuZGVyZWQgKSBhcmUgdmFsaWQgbW92ZSBvblxuXG4gICAgICAgIGlmIChzY3JlZW5WYWxpZCgpKSB7XG4gICAgICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IHN0ZXBcbiAgICAgICAgICB2YXIgX2dldEN1cnJlbnRTdGVwID0gZ2V0Q3VycmVudFN0ZXAoKSxcbiAgICAgICAgICAgICAgZ2V0TmV4dCA9IF9nZXRDdXJyZW50U3RlcC5nZXROZXh0O1xuXG4gICAgICAgICAgdmFyIG5leHQgPSBnZXROZXh0KCk7IC8vIERldGVybWluZSB3aGF0IHRoZSBuZXh0IHN0ZXAgc2hvdWxkIGJlXG5cbiAgICAgICAgICB2YXIgbmV4dFN0ZXAgPSB0eXBlb2YgbmV4dCA9PT0gJ2Z1bmN0aW9uJyA/IG5leHQoZ2V0VmFsdWVzKCkpIDogbmV4dDsgLy8gRGV0ZXJtaW5lIGlmIGl0IGhhcyBhIG5leHRcblxuICAgICAgICAgIGlmIChuZXh0U3RlcCkge1xuICAgICAgICAgICAgc2V0TXVsdGlzdGVwU3RhdGUoZnVuY3Rpb24gKHByZXYpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBwcmV2KSwge30sIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50OiBuZXh0U3RlcFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIEdvZXMgdG8gcHJldmlvdXMgc3RlcFxuICAgICAgYmFjazogZnVuY3Rpb24gYmFjaygpIHtcbiAgICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IHN0ZXBcbiAgICAgICAgdmFyIF9nZXRDdXJyZW50U3RlcDIgPSBnZXRDdXJyZW50U3RlcCgpLFxuICAgICAgICAgICAgZ2V0UHJldmlvdXMgPSBfZ2V0Q3VycmVudFN0ZXAyLmdldFByZXZpb3VzO1xuXG4gICAgICAgIHZhciBwcmV2aW91cyA9IGdldFByZXZpb3VzKCk7IC8vIERldGVybWluZSB3aGF0IHRoZSBwcmV2aW91cyBzdGVwIHNob3VsZCBiZVxuXG4gICAgICAgIHZhciBwcmV2aW91c1N0ZXAgPSB0eXBlb2YgcHJldmlvdXMgPT09ICdmdW5jdGlvbicgPyBwcmV2aW91cyhnZXRWYWx1ZXMoKSkgOiBwcmV2aW91czsgLy8gRGV0ZXJtaW5lIGlmIGl0IGhhcyBhIHByZXZpb3VzXG5cbiAgICAgICAgaWYgKHByZXZpb3VzU3RlcCkge1xuICAgICAgICAgIHNldE11bHRpc3RlcFN0YXRlKGZ1bmN0aW9uIChwcmV2KSB7XG4gICAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIHByZXYpLCB7fSwge1xuICAgICAgICAgICAgICBjdXJyZW50OiBwcmV2aW91c1N0ZXBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gR29lcyB0byBzcGVjaWZpZWQgc3RlcFxuICAgICAgc2V0Q3VycmVudDogZnVuY3Rpb24gc2V0Q3VycmVudChuZXh0KSB7XG4gICAgICAgIC8vIERldGVybWluZSBpZiBpdCBoYXMgYSBuZXh0XG4gICAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgICAgc2V0TXVsdGlzdGVwU3RhdGUoZnVuY3Rpb24gKHByZXYpIHtcbiAgICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgcHJldiksIHt9LCB7XG4gICAgICAgICAgICAgIGN1cnJlbnQ6IG5leHRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gUmVnaXN0ZXJzIHRoZSBzdGVwXG4gICAgICByZWdpc3RlcjogZnVuY3Rpb24gcmVnaXN0ZXIobmFtZSwgc3RlcCwgaW5pdGlhbCkge1xuICAgICAgICBzdGVwc0J5TmFtZS5zZXQobmFtZSwgc3RlcCk7XG5cbiAgICAgICAgaWYgKCFpbml0aWFsKSB7XG4gICAgICAgICAgc2V0TXVsdGlzdGVwU3RhdGUoZnVuY3Rpb24gKHByZXYpIHtcbiAgICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgcHJldiksIHt9LCB7XG4gICAgICAgICAgICAgIHN0ZXBzOiBBcnJheS5mcm9tKHN0ZXBzQnlOYW1lLmtleXMoKSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gRGVyZWdpc3RlcnMgdGhlIHN0ZXBcbiAgICAgIGRlcmVnaXN0ZXI6IGZ1bmN0aW9uIGRlcmVnaXN0ZXIobmFtZSkge1xuICAgICAgICBzdGVwc0J5TmFtZVtcImRlbGV0ZVwiXShuYW1lKTtcbiAgICAgICAgc2V0TXVsdGlzdGVwU3RhdGUoZnVuY3Rpb24gKHByZXYpIHtcbiAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIHByZXYpLCB7fSwge1xuICAgICAgICAgICAgc3RlcHM6IEFycmF5LmZyb20oc3RlcHNCeU5hbWUua2V5cygpKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKG11bHRpc3RlcEFwaVJlZikge1xuICAgICAgbXVsdGlzdGVwQXBpUmVmLmN1cnJlbnQgPSBhcGk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFwaTtcbiAgfSksXG4gICAgICBfdXNlU3RhdGU0ID0gX3NsaWNlZFRvQXJyYXkoX3VzZVN0YXRlMywgMSksXG4gICAgICBtdWx0aXN0ZXBBcGkgPSBfdXNlU3RhdGU0WzBdOyAvLyBSZW5kZXIgZnVudGlvbiB0aGF0IHdpbGwgcHJvdmlkZSBzdGF0ZSBhbmQgYXBpXG5cblxuICB2YXIgcmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKGNoaWxkcmVuKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KE11bHRpc3RlcEFwaUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgIHZhbHVlOiBtdWx0aXN0ZXBBcGlcbiAgICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChNdWx0aXN0ZXBTdGF0ZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgIHZhbHVlOiBtdWx0aXN0ZXBTdGF0ZVxuICAgIH0sIGNoaWxkcmVuKSk7XG4gIH07XG5cbiAgcmV0dXJuIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBtdWx0aXN0ZXBBcGkpLCBtdWx0aXN0ZXBTdGF0ZSksIHt9LCB7XG4gICAgcmVuZGVyOiByZW5kZXJcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiB1c2VNdWx0aXN0ZXBTdGF0ZSgpIHtcbiAgcmV0dXJuIHVzZUNvbnRleHQoTXVsdGlzdGVwU3RhdGVDb250ZXh0KTtcbn1cblxuZnVuY3Rpb24gdXNlTXVsdGlzdGVwQXBpKCkge1xuICByZXR1cm4gdXNlQ29udGV4dChNdWx0aXN0ZXBBcGlDb250ZXh0KTtcbn1cblxudmFyIHVzZU11bHRpc3RlcFN0ZXAgPSBmdW5jdGlvbiB1c2VNdWx0aXN0ZXBTdGVwKF9yZWYpIHtcbiAgdmFyIHN0ZXAgPSBfcmVmLnN0ZXAsXG4gICAgICBuZXh0ID0gX3JlZi5uZXh0LFxuICAgICAgcHJldmlvdXMgPSBfcmVmLnByZXZpb3VzLFxuICAgICAgcmVsZXZhbnQgPSBfcmVmLnJlbGV2YW50O1xuXG4gIHZhciBfdXNlRm9ybVN0YXRlID0gdXNlRm9ybVN0YXRlKCksXG4gICAgICB2YWx1ZXMgPSBfdXNlRm9ybVN0YXRlLnZhbHVlcztcblxuICB2YXIgX3VzZU11bHRpc3RlcFN0YXRlID0gdXNlTXVsdGlzdGVwU3RhdGUoKSxcbiAgICAgIGN1cnJlbnQgPSBfdXNlTXVsdGlzdGVwU3RhdGUuY3VycmVudDtcblxuICB2YXIgX3VzZU11bHRpc3RlcEFwaSA9IHVzZU11bHRpc3RlcEFwaSgpLFxuICAgICAgcmVnaXN0ZXIgPSBfdXNlTXVsdGlzdGVwQXBpLnJlZ2lzdGVyLFxuICAgICAgZGVyZWdpc3RlciA9IF91c2VNdWx0aXN0ZXBBcGkuZGVyZWdpc3RlcjtcblxuICB2YXIgaXNDdXJyZW50ID0gc3RlcCA9PT0gY3VycmVudDtcbiAgdmFyIGlzUmVsZXZhbnQgPSByZWxldmFudCA/IHJlbGV2YW50KHZhbHVlcykgOiB0cnVlO1xuICB2YXIgbmV4dFJlZiA9IHVzZVJlZihuZXh0KTtcbiAgdmFyIHByZXZSZWYgPSB1c2VSZWYocHJldmlvdXMpO1xuICB2YXIgcmVsZXZhbnRSZWYgPSB1c2VSZWYoKTtcbiAgbmV4dFJlZi5jdXJyZW50ID0gbmV4dDtcbiAgcHJldlJlZi5jdXJyZW50ID0gcHJldmlvdXM7XG4gIHJlbGV2YW50UmVmLmN1cnJlbnQgPSByZWxldmFudDtcbiAgdXNlU3RhdGUoZnVuY3Rpb24gKCkge1xuICAgIHJlZ2lzdGVyKHN0ZXAsIHtcbiAgICAgIG5hbWU6IHN0ZXAsXG4gICAgICBnZXROZXh0OiBmdW5jdGlvbiBnZXROZXh0KCkge1xuICAgICAgICByZXR1cm4gbmV4dFJlZi5jdXJyZW50O1xuICAgICAgfSxcbiAgICAgIGdldFByZXZpb3VzOiBmdW5jdGlvbiBnZXRQcmV2aW91cygpIHtcbiAgICAgICAgcmV0dXJuIHByZXZSZWYuY3VycmVudDtcbiAgICAgIH1cbiAgICB9LCB0cnVlKTtcbiAgfSk7XG4gIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgcmVnaXN0ZXIoc3RlcCwge1xuICAgICAgbmFtZTogc3RlcCxcbiAgICAgIGdldE5leHQ6IGZ1bmN0aW9uIGdldE5leHQoKSB7XG4gICAgICAgIHJldHVybiBuZXh0UmVmLmN1cnJlbnQ7XG4gICAgICB9LFxuICAgICAgZ2V0UHJldmlvdXM6IGZ1bmN0aW9uIGdldFByZXZpb3VzKCkge1xuICAgICAgICByZXR1cm4gcHJldlJlZi5jdXJyZW50O1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBkZXJlZ2lzdGVyKHN0ZXApO1xuICAgIH07XG4gIH0sIFtzdGVwXSk7XG5cbiAgdmFyIHJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcihjaGlsZHJlbikge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChNdWx0aXN0ZXBTdGVwQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgdmFsdWU6IHtcbiAgICAgICAgcmVsZXZhbnQ6IGZ1bmN0aW9uIHJlbGV2YW50KHBhcmFtcykge1xuICAgICAgICAgIHJldHVybiByZWxldmFudFJlZi5jdXJyZW50ID8gcmVsZXZhbnRSZWYuY3VycmVudChwYXJhbXMpIDogdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgbXVsdGlzdGVwOiB0cnVlXG4gICAgICB9XG4gICAgfSwgaXNDdXJyZW50ICYmIGlzUmVsZXZhbnQgPyBjaGlsZHJlbiA6IG51bGwpO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgaXNDdXJyZW50OiBpc0N1cnJlbnQsXG4gICAgaXNSZWxldmFudDogaXNSZWxldmFudCxcbiAgICBzdGVwOiBzdGVwLFxuICAgIHJlbmRlcjogcmVuZGVyXG4gIH07XG59O1xuXG5mdW5jdGlvbiBNdWx0aXN0ZXAoX3JlZikge1xuICB2YXIgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuLFxuICAgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgW1wiY2hpbGRyZW5cIl0pO1xuXG4gIHZhciBfdXNlTXVsdGlzdGVwID0gdXNlTXVsdGlzdGVwKHByb3BzKSxcbiAgICAgIHJlbmRlciA9IF91c2VNdWx0aXN0ZXAucmVuZGVyLFxuICAgICAgY29udGV4dCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfdXNlTXVsdGlzdGVwLCBbXCJyZW5kZXJcIl0pO1xuXG4gIGlmICh0eXBlb2YgY2hpbGRyZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gcmVuZGVyKGNoaWxkcmVuKGNvbnRleHQpKTtcbiAgfVxuXG4gIHJldHVybiByZW5kZXIoY2hpbGRyZW4pO1xufVxuXG5NdWx0aXN0ZXAuU3RlcCA9IGZ1bmN0aW9uIE11bHRpc3RlcFN0ZXAoX3JlZjIpIHtcbiAgdmFyIGNoaWxkcmVuID0gX3JlZjIuY2hpbGRyZW4sXG4gICAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmMiwgW1wiY2hpbGRyZW5cIl0pO1xuXG4gIHZhciBfdXNlTXVsdGlzdGVwU3RlcCA9IHVzZU11bHRpc3RlcFN0ZXAocHJvcHMpLFxuICAgICAgcmVuZGVyID0gX3VzZU11bHRpc3RlcFN0ZXAucmVuZGVyO1xuXG4gIHJldHVybiByZW5kZXIoY2hpbGRyZW4pO1xufTtcblxudmFyIEZvcm1GaWVsZCA9IGZ1bmN0aW9uIEZvcm1GaWVsZChfcmVmKSB7XG4gIHZhciBmaWVsZCA9IF9yZWYuZmllbGQ7XG5cbiAgLy8gR2V0IHRoZSBmaWVsZCBtYXAgb2ZmIHRoZSBmb3JtcyBjb250ZXh0XG4gIHZhciBfdXNlQ29udGV4dCA9IHVzZUNvbnRleHQoRm9ybVJlZ2lzdGVyQ29udGV4dCksXG4gICAgICBmaWVsZE1hcCA9IF91c2VDb250ZXh0LmZpZWxkTWFwOyAvLyBHcmFiIHRoZSBmb3JtIGFwaSAoIHdlIG5lZWQgaXQgdG8gZ2V0IHRoZSBhY3R1YWwgZmllbGQgbmFtZSBiZWNhdXNlIG1pZ2h0IGJlIGluIHNjb3BlIClcblxuXG4gIHZhciBfdXNlRm9ybUFwaSA9IHVzZUZvcm1BcGkoKSxcbiAgICAgIGdldEZ1bGxGaWVsZCA9IF91c2VGb3JtQXBpLmdldEZ1bGxGaWVsZCxcbiAgICAgIGdldE9wdGlvbnMgPSBfdXNlRm9ybUFwaS5nZXRPcHRpb25zOyAvLyBHcmFiIHRoZSBmdWxsIGZpZWxkXG5cblxuICB2YXIgZnVsbEZpZWxkID0gZ2V0RnVsbEZpZWxkKGZpZWxkKTsgLy8gR3JhcCB0aGUgc2NoZW1hXG5cbiAgdmFyIF9nZXRPcHRpb25zID0gZ2V0T3B0aW9ucygpLFxuICAgICAgc2NoZW1hID0gX2dldE9wdGlvbnMuc2NoZW1hOyAvLyBGaXJzdCBmaW5kIHByb3BlcnR5IGZyb20gdGhlIHNjaGVtYSB2aWEgdGhlIHBhdGggdG8gdGhhdCBmaWVsZFxuICAvLyBFeGFtcGxlc1xuICAvLyBmaWVsZCA9IFwibmFtZVwiIC0tLT4gcHJvcGVydGllcy5uYW1lXG4gIC8vIGZpZWxkID0gXCJicm90aGVyLm5hbWVcIiAtLS0+IHByb3BlcnRpZXMuYnJvdGhlci5wcm9wZXJ0aWVzLm5hbWVcbiAgLy8gZmllbGQgPSBcImJyb3RoZXIuc2libGluZ3NbMV0uZnJpZW5kLm5hbWVcIiAtLS0+IHByb3BlcnRpZXMuYnJvdGhlci5wcm9wZXJ0aWVzLnNpYmxpbmdzLml0ZW1zWzFdLnByb3BlcnRpZXMuZnJpZW5kLnByb3BlcnRpZXMubmFtZVxuXG5cbiAgdmFyIHBhdGggPSBnZXRTY2hlbWFQYXRoRnJvbUpzb25QYXRoKGZ1bGxGaWVsZCk7XG4gIHZhciBwcm9wZXJ0eSA9IE9iamVjdE1hcC5nZXQoc2NoZW1hLCBwYXRoKTsgLy8gSWYgcHJvcGVydHkgd2FzIG5vdCBmb3VuZCByZXR1cm4gbnVsbFxuXG4gIGlmICghcHJvcGVydHkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSAvLyBOZXh0IGNvbXB1dGUgdGhlIGZpZWxkIGZyb20gcHJvcGVydHlcblxuXG4gIHZhciBzY2hlbWFGaWVsZCA9IGNvbXB1dGVGaWVsZEZyb21Qcm9wZXJ0eShmaWVsZCwgcHJvcGVydHkpO1xuICB2YXIgcHJvcHMgPSBzY2hlbWFGaWVsZC5wcm9wcyxcbiAgICAgIGNvbXBvbmVudFR5cGUgPSBzY2hlbWFGaWVsZC5jb21wb25lbnRUeXBlO1xuICB2YXIgQ29tcG9uZW50ID0gZmllbGRNYXBbY29tcG9uZW50VHlwZV07XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIF9leHRlbmRzKHtcbiAgICBmaWVsZDogZmllbGRcbiAgfSwgcHJvcHMpKTtcbn07XG5cbnZhciBTY2hlbWFGaWVsZHMgPSBmdW5jdGlvbiBTY2hlbWFGaWVsZHMoKSB7XG4gIHZhciBfdXNlRm9ybUFwaSA9IHVzZUZvcm1BcGkoKSxcbiAgICAgIGdldE9wdGlvbnMgPSBfdXNlRm9ybUFwaS5nZXRPcHRpb25zOyAvLyBHcmFwIHRoZSBzY2hlbWFcblxuXG4gIHZhciBfZ2V0T3B0aW9ucyA9IGdldE9wdGlvbnMoKSxcbiAgICAgIHNjaGVtYSA9IF9nZXRPcHRpb25zLnNjaGVtYTtcblxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRm9ybUZpZWxkcywge1xuICAgIHNjaGVtYTogc2NoZW1hXG4gIH0pO1xufTtcblxudmFyIHdpdGhGb3JtQXBpID0gZnVuY3Rpb24gd2l0aEZvcm1BcGkoQ29tcG9uZW50KSB7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiAocHJvcHMsIHJlZikge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChGb3JtQXBpQ29udGV4dC5Db25zdW1lciwgbnVsbCwgZnVuY3Rpb24gKGZvcm1BcGkpIHtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIF9leHRlbmRzKHtcbiAgICAgICAgZm9ybUFwaTogZm9ybUFwaSxcbiAgICAgICAgcmVmOiByZWZcbiAgICAgIH0sIHByb3BzKSk7XG4gICAgfSk7XG4gIH0pO1xufTtcblxudmFyIHdpdGhGb3JtU3RhdGUgPSBmdW5jdGlvbiB3aXRoRm9ybVN0YXRlKENvbXBvbmVudCkge1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gKHByb3BzLCByZWYpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRm9ybVN0YXRlQ29udGV4dC5Db25zdW1lciwgbnVsbCwgZnVuY3Rpb24gKGZvcm1TdGF0ZSkge1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENvbXBvbmVudCwgX2V4dGVuZHMoe1xuICAgICAgICBmb3JtU3RhdGU6IGZvcm1TdGF0ZSxcbiAgICAgICAgcmVmOiByZWZcbiAgICAgIH0sIHByb3BzKSk7XG4gICAgfSk7XG4gIH0pO1xufTtcblxudmFyIGJ1aWxkRmllbGRBcGkgPSBmdW5jdGlvbiBidWlsZEZpZWxkQXBpKGZvcm1BcGksIGZpZWxkKSB7XG4gIHJldHVybiB7XG4gICAgLy8gVE9ETyByZWZhY3RvciB0byB1c2UgZmllbGQgYXBpIGZyb20gdXBkYXRlci4uIG5lZWQgdG8gbWFrZSBzdXJlIHRoaXMgXG4gICAgLy8gd2lsbCBiZSBzdGFibGVcbiAgICBnZXRWYWx1ZTogZnVuY3Rpb24gZ2V0VmFsdWUoKSB7XG4gICAgICByZXR1cm4gZm9ybUFwaS5nZXRWYWx1ZShmaWVsZCk7XG4gICAgfSxcbiAgICBzZXRWYWx1ZTogZnVuY3Rpb24gc2V0VmFsdWUodmFsdWUpIHtcbiAgICAgIHJldHVybiBmb3JtQXBpLnNldFZhbHVlKGZpZWxkLCB2YWx1ZSk7XG4gICAgfSxcbiAgICBnZXRUb3VjaGVkOiBmdW5jdGlvbiBnZXRUb3VjaGVkKCkge1xuICAgICAgcmV0dXJuIGZvcm1BcGkuZ2V0VG91Y2hlZChmaWVsZCk7XG4gICAgfSxcbiAgICBzZXRUb3VjaGVkOiBmdW5jdGlvbiBzZXRUb3VjaGVkKHZhbHVlKSB7XG4gICAgICByZXR1cm4gZm9ybUFwaS5zZXRUb3VjaGVkKGZpZWxkLCB2YWx1ZSk7XG4gICAgfSxcbiAgICBnZXRFcnJvcjogZnVuY3Rpb24gZ2V0RXJyb3IoKSB7XG4gICAgICByZXR1cm4gZm9ybUFwaS5nZXRFcnJvcihmaWVsZCk7XG4gICAgfSxcbiAgICBzZXRFcnJvcjogZnVuY3Rpb24gc2V0RXJyb3IodmFsdWUpIHtcbiAgICAgIHJldHVybiBmb3JtQXBpLnNldEVycm9yKGZpZWxkLCB2YWx1ZSk7XG4gICAgfSxcbiAgICByZXNldDogZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICByZXR1cm4gZm9ybUFwaS5yZXNldEZpZWxkKGZpZWxkKTtcbiAgICB9LFxuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiB2YWxpZGF0ZSgpIHtcbiAgICAgIHJldHVybiBmb3JtQXBpLnZhbGlkYXRlRmllbGQoZmllbGQpO1xuICAgIH0sXG4gICAgZXhpc3RzOiBmdW5jdGlvbiBleGlzdHMoKSB7XG4gICAgICByZXR1cm4gZm9ybUFwaS5maWVsZEV4aXN0cyhmaWVsZCk7XG4gICAgfVxuICB9O1xufTtcblxuZnVuY3Rpb24gdXNlRmllbGRBcGkoZmllbGQpIHtcbiAgdmFyIGZvcm1BcGkgPSB1c2VGb3JtQXBpKCk7XG4gIHZhciBmaWVsZEFwaSA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBidWlsZEZpZWxkQXBpKGZvcm1BcGksIGZpZWxkKTtcbiAgfSwgW2ZpZWxkXSk7XG4gIHJldHVybiBmaWVsZEFwaTtcbn1cblxudmFyIGJ1aWxkRmllbGRTdGF0ZSA9IGZ1bmN0aW9uIGJ1aWxkRmllbGRTdGF0ZShmaWVsZEFwaSkge1xuICByZXR1cm4ge1xuICAgIHZhbHVlOiBmaWVsZEFwaS5nZXRWYWx1ZSgpLFxuICAgIHRvdWNoZWQ6IGZpZWxkQXBpLmdldFRvdWNoZWQoKSxcbiAgICBlcnJvcjogZmllbGRBcGkuZ2V0RXJyb3IoKVxuICB9O1xufTtcblxuZnVuY3Rpb24gdXNlRmllbGRTdGF0ZShmaWVsZCkge1xuICB2YXIgZmllbGRBcGkgPSB1c2VGaWVsZEFwaShmaWVsZCk7IC8vIFRPRE8gZmluZCBiZXR0ZXIgd2F5IHRvIGdldCB0aGlzIHRvIHJlcmVuZGVyXG5cbiAgdmFyIGZvcm1TdGF0ZSA9IHVzZUZvcm1TdGF0ZSgpOyAvLyBUaGUgYWJvdmUgaXMgYSB0ZW1wIGhhY2tcblxuICB2YXIgZmllbGRTdGF0ZSA9IGJ1aWxkRmllbGRTdGF0ZShmaWVsZEFwaSk7XG4gIHJldHVybiBmaWVsZFN0YXRlO1xufVxuXG52YXIgd2l0aEZpZWxkU3RhdGUgPSBmdW5jdGlvbiB3aXRoRmllbGRTdGF0ZShmaWVsZCkge1xuICByZXR1cm4gZnVuY3Rpb24gKENvbXBvbmVudCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICAgIHZhciBmaWVsZFN0YXRlID0gdXNlRmllbGRTdGF0ZShmaWVsZCk7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50LCBfZXh0ZW5kcyh7XG4gICAgICAgIGZpZWxkU3RhdGU6IGZpZWxkU3RhdGVcbiAgICAgIH0sIHByb3BzKSk7XG4gICAgfTtcbiAgfTtcbn07XG5cbnZhciB3aXRoRmllbGRBcGkgPSBmdW5jdGlvbiB3aXRoRmllbGRBcGkoZmllbGQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChDb21wb25lbnQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgICB2YXIgZmllbGRBcGkgPSB1c2VGaWVsZEFwaShmaWVsZCk7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50LCBfZXh0ZW5kcyh7XG4gICAgICAgIGZpZWxkQXBpOiBmaWVsZEFwaVxuICAgICAgfSwgcHJvcHMpKTtcbiAgICB9O1xuICB9O1xufTtcblxudmFyIE9wdGlvbiA9IGZ1bmN0aW9uIE9wdGlvbihfcmVmKSB7XG4gIHZhciB2YWx1ZSA9IF9yZWYudmFsdWUsXG4gICAgICBmb3J3YXJkZWRSZWYgPSBfcmVmLmZvcndhcmRlZFJlZixcbiAgICAgIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbixcbiAgICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgW1widmFsdWVcIiwgXCJmb3J3YXJkZWRSZWZcIiwgXCJjaGlsZHJlblwiXSk7XG5cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIsIF9leHRlbmRzKHtcbiAgICByZWY6IGZvcndhcmRlZFJlZixcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAga2V5OiB2YWx1ZVxuICB9LCByZXN0KSwgY2hpbGRyZW4pO1xufTtcblxudmFyIElucHV0ID0gVGV4dCQxO1xuXG5leHBvcnQgeyBBcnJheUZpZWxkLCBDaGVja2JveCBhcyBCYXNpY0NoZWNrYm94LCBSYWRpbyBhcyBCYXNpY1JhZGlvLCBSYWRpb0dyb3VwIGFzIEJhc2ljUmFkaW9Hcm91cCwgU2VsZWN0IGFzIEJhc2ljU2VsZWN0LCBUZXh0IGFzIEJhc2ljVGV4dCwgVGV4dEFyZWEgYXMgQmFzaWNUZXh0QXJlYSwgQ2hlY2tib3gkMSBhcyBDaGVja2JveCwgRm9ybSwgRm9ybUNvbXBvbmVudHMsIEZvcm1GaWVsZCwgRm9ybUZpZWxkcywgRm9ybVByb3ZpZGVyLCBGb3JtU3RhdGUsIElucHV0LCBNdWx0aXN0ZXAsIE9wdGlvbiwgUmFkaW8kMSBhcyBSYWRpbywgUmFkaW9Hcm91cCQxIGFzIFJhZGlvR3JvdXAsIFJlbGV2YW50LCBTY2hlbWFGaWVsZHMsIFNjb3BlLCBTZWxlY3QkMSBhcyBTZWxlY3QsIFRleHQkMSBhcyBUZXh0LCBUZXh0QXJlYSQxIGFzIFRleHRBcmVhLCBhc0ZpZWxkLCB1c2VBcnJheUZpZWxkLCB1c2VBcnJheUZpZWxkQXBpLCB1c2VBcnJheUZpZWxkSXRlbUFwaSwgdXNlRmllbGQsIHVzZUZpZWxkQXBpLCB1c2VGaWVsZFN0YXRlLCB1c2VGb3JtLCB1c2VGb3JtQXBpLCB1c2VGb3JtU3RhdGUsIHVzZU11bHRpc3RlcEFwaSwgdXNlTXVsdGlzdGVwU3RhdGUsIHdpdGhGaWVsZEFwaSwgd2l0aEZpZWxkU3RhdGUsIHdpdGhGb3JtQXBpLCB3aXRoRm9ybVN0YXRlLCB3aXRoUmFkaW9Hcm91cCB9O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///./node_modules/informed/dist/esm/index.js\\n')}}]);","extractedComments":[]}